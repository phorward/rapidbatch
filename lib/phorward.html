<?xml version="1.0"
?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>The Phorward C/C++ Library and Toolkit</title>
<meta name="generator" content="http://txt2tags.org" />
<link rel="stylesheet" type="text/css" href="phorward.css" />
<link rel="stylesheet" type="text/css" href="prism.css" />
<script src="prism.js"></script>
</head>
<body>

<div class="header" id="header">
<h1>The Phorward C/C++ Library and Toolkit</h1>
<h2>libphorward 1.0.0</h2>
<h3>Nov 2019</h3>
</div>

<div class="body" id="body">

<h1 id="toc1">Table of Contents</h1>

<div class="toc">

  <ul>
  <li><a href="#toc1">Table of Contents</a>
  </li>
  <li><a href="#toc2">Introduction</a>
  </li>
  <li><a href="#toc3">Installation</a>
    <ul>
    <li><a href="#toc4">Building from sources</a>
    </li>
    <li><a href="#toc5">Local development build</a>
    </li>
    <li><a href="#toc6">Building on Windows</a>
    </li>
    </ul>
  </li>
  <li><a href="#toc7">Command-line tools</a>
      <ul>
      <li><a href="#c_pdoc">pdoc - C source code documentation tool</a>
      </li>
      <li><a href="#c_pinclude">pinclude - Generate big files from various smaller ones</a>
      </li>
      <li><a href="#c_plex">plex - Lexical analyzer generator and interpreter</a>
      </li>
      <li><a href="#c_pproto">pproto - C function prototype generator</a>
      </li>
      <li><a href="#c_pregex">pregex - Regular expression operations</a>
      </li>
      <li><a href="#c_ptest">ptest - C program test facilities</a>
      </li>
      </ul>
  </li>
  <li><a href="#toc14">General functions &amp; dynamic data structures</a>
    <ul>
    <li><a href="#toc15">Advanced memory management</a>
    </li>
    <li><a href="#pboolean">Boolean data type</a>
    </li>
    <li><a href="#ptrace">Debugging and tracing</a>
    </li>
    <li><a href="#toc18">System-related, platform-independent helpers</a>
    </li>
    <li><a href="#parray">Dynamically managed arrays &amp; stacks (parray)</a>
      <ul>
      <li><a href="#toc20">Overview</a>
      </li>
      <li><a href="#toc21">Construction and destruction</a>
      </li>
      <li><a href="#toc22">Inserting elements</a>
      </li>
      <li><a href="#toc23">Accessing and iterating elements</a>
      </li>
      <li><a href="#toc24">Removing elements</a>
      </li>
      <li><a href="#toc25">Sorting elements</a>
      </li>
      <li><a href="#toc26">Interchanging functions</a>
      </li>
      <li><a href="#toc27">Additional functions</a>
      </li>
      </ul>
    </li>
    <li><a href="#plist">Linked lists, hash-tables, queues &amp; stacks (plist)</a>
      <ul>
      <li><a href="#toc29">Overview</a>
      </li>
      <li><a href="#toc30">Construction and destruction</a>
      </li>
      <li><a href="#toc31">Inserting elements</a>
      </li>
      <li><a href="#plistel">Accessing and iterating elements</a>
      </li>
      <li><a href="#toc33">Removing elements</a>
      </li>
      <li><a href="#toc34">Sorting elements</a>
      </li>
      <li><a href="#toc35">Interchanging functions</a>
      </li>
      <li><a href="#toc36">Additional functions</a>
      </li>
      </ul>
    </li>
    <li><a href="#pccl">Character-classes (pccl)</a>
    </li>
    </ul>
  </li>
  <li><a href="#toc38">Regular expressions &amp; lexical analyzers (pregex, plex)</a>
    <ul>
    <li><a href="#toc39">Overview</a>
      <ul>
      <li><a href="#toc40">Meta constructs</a>
      </li>
      <li><a href="#toc41">Characters and escape sequences</a>
      </li>
      <li><a href="#toc42">Shorthand character classes</a>
      </li>
      <li><a href="#toc43">Anchoring</a>
      </li>
      <li><a href="#toc44">Examples</a>
      </li>
      </ul>
    </li>
    <li><a href="#pregex">Operating on regular expressions (pregex)</a>
      <ul>
      <li><a href="#toc46">Construction and destruction</a>
      </li>
      <li><a href="#toc47">Matching</a>
      </li>
      <li><a href="#toc48">Splitting</a>
      </li>
      <li><a href="#toc49">Replacing</a>
      </li>
      <li><a href="#toc50">Quick-access functions</a>
      </li>
      </ul>
    </li>
    <li><a href="#plex">Lexical analysis using regular expressions (plex)</a>
    </li>
    <li><a href="#toc52">Tools</a>
      <ul>
      <li><a href="#prange">Ranges</a>
      </li>
      <li><a href="#pregex_ptn">Regular Expression Patterns</a>
      </li>
      </ul>
    </li>
    </ul>
  </li>
  <li><a href="#pstr">String helper functions (pstr*, pwcs*)</a>
  </li>
  <li><a href="#toc56">Function reference</a>
    <ul>
    <li><a href="#toc57">Macros</a>
      <ul>
      <li><a href="#fn_BOOLEAN_STR">BOOLEAN_STR</a>
      </li>
      <li><a href="#fn_CORE">CORE</a>
      </li>
      <li><a href="#fn_FALSE">FALSE</a>
      </li>
      <li><a href="#fn_LOG">LOG</a>
      </li>
      <li><a href="#fn_MAKE_BOOLEAN">MAKE_BOOLEAN</a>
      </li>
      <li><a href="#fn_MISSINGCASE">MISSINGCASE</a>
      </li>
      <li><a href="#fn_MSG">MSG</a>
      </li>
      <li><a href="#fn_OUTOFMEM">OUTOFMEM</a>
      </li>
      <li><a href="#fn_PARMS">PARMS</a>
      </li>
      <li><a href="#fn_PROC">PROC</a>
      </li>
      <li><a href="#fn_RETURN">RETURN</a>
      </li>
      <li><a href="#fn_TODO">TODO</a>
      </li>
      <li><a href="#fn_TRUE">TRUE</a>
      </li>
      <li><a href="#fn_VARS">VARS</a>
      </li>
      <li><a href="#fn_VOIDRET">VOIDRET</a>
      </li>
      <li><a href="#fn_WRONGPARAM">WRONGPARAM</a>
      </li>
      <li><a href="#fn_parray_for">parray_for</a>
      </li>
      <li><a href="#fn_plist_for">plist_for</a>
      </li>
      </ul>
    </li>
    <li><a href="#toc76">Functions</a>
      <ul>
      <li><a href="#fn_parray_concat">parray_concat</a>
      </li>
      <li><a href="#fn_parray_count">parray_count</a>
      </li>
      <li><a href="#fn_parray_create">parray_create</a>
      </li>
      <li><a href="#fn_parray_diff">parray_diff</a>
      </li>
      <li><a href="#fn_parray_erase">parray_erase</a>
      </li>
      <li><a href="#fn_parray_first">parray_first</a>
      </li>
      <li><a href="#fn_parray_free">parray_free</a>
      </li>
      <li><a href="#fn_parray_get">parray_get</a>
      </li>
      <li><a href="#fn_parray_init">parray_init</a>
      </li>
      <li><a href="#fn_parray_insert">parray_insert</a>
      </li>
      <li><a href="#fn_parray_iter">parray_iter</a>
      </li>
      <li><a href="#fn_parray_last">parray_last</a>
      </li>
      <li><a href="#fn_parray_malloc">parray_malloc</a>
      </li>
      <li><a href="#fn_parray_next">parray_next</a>
      </li>
      <li><a href="#fn_parray_offset">parray_offset</a>
      </li>
      <li><a href="#fn_parray_partof">parray_partof</a>
      </li>
      <li><a href="#fn_parray_pop">parray_pop</a>
      </li>
      <li><a href="#fn_parray_prev">parray_prev</a>
      </li>
      <li><a href="#fn_parray_push">parray_push</a>
      </li>
      <li><a href="#fn_parray_put">parray_put</a>
      </li>
      <li><a href="#fn_parray_remove">parray_remove</a>
      </li>
      <li><a href="#fn_parray_reserve">parray_reserve</a>
      </li>
      <li><a href="#fn_parray_rget">parray_rget</a>
      </li>
      <li><a href="#fn_parray_riter">parray_riter</a>
      </li>
      <li><a href="#fn_parray_rmalloc">parray_rmalloc</a>
      </li>
      <li><a href="#fn_parray_rput">parray_rput</a>
      </li>
      <li><a href="#fn_parray_set_comparefn">parray_set_comparefn</a>
      </li>
      <li><a href="#fn_parray_set_sortfn">parray_set_sortfn</a>
      </li>
      <li><a href="#fn_parray_shift">parray_shift</a>
      </li>
      <li><a href="#fn_parray_sort">parray_sort</a>
      </li>
      <li><a href="#fn_parray_subsort">parray_subsort</a>
      </li>
      <li><a href="#fn_parray_swap">parray_swap</a>
      </li>
      <li><a href="#fn_parray_union">parray_union</a>
      </li>
      <li><a href="#fn_parray_unshift">parray_unshift</a>
      </li>
      <li><a href="#fn_pasprintf">pasprintf</a>
      </li>
      <li><a href="#fn_pawcsprintf">pawcsprintf</a>
      </li>
      <li><a href="#fn_pbasename">pbasename</a>
      </li>
      <li><a href="#fn_pccl_add">pccl_add</a>
      </li>
      <li><a href="#fn_pccl_addrange">pccl_addrange</a>
      </li>
      <li><a href="#fn_pccl_compare">pccl_compare</a>
      </li>
      <li><a href="#fn_pccl_compat">pccl_compat</a>
      </li>
      <li><a href="#fn_pccl_count">pccl_count</a>
      </li>
      <li><a href="#fn_pccl_create">pccl_create</a>
      </li>
      <li><a href="#fn_pccl_del">pccl_del</a>
      </li>
      <li><a href="#fn_pccl_delrange">pccl_delrange</a>
      </li>
      <li><a href="#fn_pccl_diff">pccl_diff</a>
      </li>
      <li><a href="#fn_pccl_dup">pccl_dup</a>
      </li>
      <li><a href="#fn_pccl_erase">pccl_erase</a>
      </li>
      <li><a href="#fn_pccl_free">pccl_free</a>
      </li>
      <li><a href="#fn_pccl_get">pccl_get</a>
      </li>
      <li><a href="#fn_pccl_instest">pccl_instest</a>
      </li>
      <li><a href="#fn_pccl_intersect">pccl_intersect</a>
      </li>
      <li><a href="#fn_pccl_negate">pccl_negate</a>
      </li>
      <li><a href="#fn_pccl_parse">pccl_parse</a>
      </li>
      <li><a href="#fn_pccl_parsechar">pccl_parsechar</a>
      </li>
      <li><a href="#fn_pccl_parseshorthand">pccl_parseshorthand</a>
      </li>
      <li><a href="#fn_pccl_print">pccl_print</a>
      </li>
      <li><a href="#fn_pccl_size">pccl_size</a>
      </li>
      <li><a href="#fn_pccl_test">pccl_test</a>
      </li>
      <li><a href="#fn_pccl_testrange">pccl_testrange</a>
      </li>
      <li><a href="#fn_pccl_to_str">pccl_to_str</a>
      </li>
      <li><a href="#fn_pccl_union">pccl_union</a>
      </li>
      <li><a href="#fn_pdbl_to_str">pdbl_to_str</a>
      </li>
      <li><a href="#fn_pdbl_to_wcs">pdbl_to_wcs</a>
      </li>
      <li><a href="#fn_pfileexists">pfileexists</a>
      </li>
      <li><a href="#fn_pfiletostr">pfiletostr</a>
      </li>
      <li><a href="#fn_pfree">pfree</a>
      </li>
      <li><a href="#fn_pgetline">pgetline</a>
      </li>
      <li><a href="#fn_pgetopt">pgetopt</a>
      </li>
      <li><a href="#fn_plex_create">plex_create</a>
      </li>
      <li><a href="#fn_plex_define">plex_define</a>
      </li>
      <li><a href="#fn_plex_dump_dot">plex_dump_dot</a>
      </li>
      <li><a href="#fn_plex_free">plex_free</a>
      </li>
      <li><a href="#fn_plex_lex">plex_lex</a>
      </li>
      <li><a href="#fn_plex_next">plex_next</a>
      </li>
      <li><a href="#fn_plex_prepare">plex_prepare</a>
      </li>
      <li><a href="#fn_plex_reset">plex_reset</a>
      </li>
      <li><a href="#fn_plex_tokenize">plex_tokenize</a>
      </li>
      <li><a href="#fn_plexctx_create">plexctx_create</a>
      </li>
      <li><a href="#fn_plexctx_free">plexctx_free</a>
      </li>
      <li><a href="#fn_plexctx_init">plexctx_init</a>
      </li>
      <li><a href="#fn_plexctx_lex">plexctx_lex</a>
      </li>
      <li><a href="#fn_plexctx_reset">plexctx_reset</a>
      </li>
      <li><a href="#fn_plist_access">plist_access</a>
      </li>
      <li><a href="#fn_plist_clear">plist_clear</a>
      </li>
      <li><a href="#fn_plist_concat">plist_concat</a>
      </li>
      <li><a href="#fn_plist_count">plist_count</a>
      </li>
      <li><a href="#fn_plist_create">plist_create</a>
      </li>
      <li><a href="#fn_plist_dbgstats">plist_dbgstats</a>
      </li>
      <li><a href="#fn_plist_diff">plist_diff</a>
      </li>
      <li><a href="#fn_plist_dup">plist_dup</a>
      </li>
      <li><a href="#fn_plist_erase">plist_erase</a>
      </li>
      <li><a href="#fn_plist_first">plist_first</a>
      </li>
      <li><a href="#fn_plist_free">plist_free</a>
      </li>
      <li><a href="#fn_plist_get">plist_get</a>
      </li>
      <li><a href="#fn_plist_get_by_key">plist_get_by_key</a>
      </li>
      <li><a href="#fn_plist_get_by_nkey">plist_get_by_nkey</a>
      </li>
      <li><a href="#fn_plist_get_by_ptr">plist_get_by_ptr</a>
      </li>
      <li><a href="#fn_plist_getkey">plist_getkey</a>
      </li>
      <li><a href="#fn_plist_hashnext">plist_hashnext</a>
      </li>
      <li><a href="#fn_plist_hashprev">plist_hashprev</a>
      </li>
      <li><a href="#fn_plist_init">plist_init</a>
      </li>
      <li><a href="#fn_plist_insert">plist_insert</a>
      </li>
      <li><a href="#fn_plist_iter">plist_iter</a>
      </li>
      <li><a href="#fn_plist_iter_access">plist_iter_access</a>
      </li>
      <li><a href="#fn_plist_key">plist_key</a>
      </li>
      <li><a href="#fn_plist_last">plist_last</a>
      </li>
      <li><a href="#fn_plist_malloc">plist_malloc</a>
      </li>
      <li><a href="#fn_plist_next">plist_next</a>
      </li>
      <li><a href="#fn_plist_offset">plist_offset</a>
      </li>
      <li><a href="#fn_plist_pop">plist_pop</a>
      </li>
      <li><a href="#fn_plist_prev">plist_prev</a>
      </li>
      <li><a href="#fn_plist_push">plist_push</a>
      </li>
      <li><a href="#fn_plist_remove">plist_remove</a>
      </li>
      <li><a href="#fn_plist_rget">plist_rget</a>
      </li>
      <li><a href="#fn_plist_riter">plist_riter</a>
      </li>
      <li><a href="#fn_plist_riter_access">plist_riter_access</a>
      </li>
      <li><a href="#fn_plist_rmalloc">plist_rmalloc</a>
      </li>
      <li><a href="#fn_plist_set_comparefn">plist_set_comparefn</a>
      </li>
      <li><a href="#fn_plist_set_printfn">plist_set_printfn</a>
      </li>
      <li><a href="#fn_plist_set_sortfn">plist_set_sortfn</a>
      </li>
      <li><a href="#fn_plist_shift">plist_shift</a>
      </li>
      <li><a href="#fn_plist_size">plist_size</a>
      </li>
      <li><a href="#fn_plist_sort">plist_sort</a>
      </li>
      <li><a href="#fn_plist_subsort">plist_subsort</a>
      </li>
      <li><a href="#fn_plist_swap">plist_swap</a>
      </li>
      <li><a href="#fn_plist_union">plist_union</a>
      </li>
      <li><a href="#fn_plist_unshift">plist_unshift</a>
      </li>
      <li><a href="#fn_pmalloc">pmalloc</a>
      </li>
      <li><a href="#fn_pmemdup">pmemdup</a>
      </li>
      <li><a href="#fn_prealloc">prealloc</a>
      </li>
      <li><a href="#fn_pregex_create">pregex_create</a>
      </li>
      <li><a href="#fn_pregex_find">pregex_find</a>
      </li>
      <li><a href="#fn_pregex_findall">pregex_findall</a>
      </li>
      <li><a href="#fn_pregex_free">pregex_free</a>
      </li>
      <li><a href="#fn_pregex_match">pregex_match</a>
      </li>
      <li><a href="#fn_pregex_ptn_create">pregex_ptn_create</a>
      </li>
      <li><a href="#fn_pregex_ptn_create_alt">pregex_ptn_create_alt</a>
      </li>
      <li><a href="#fn_pregex_ptn_create_char">pregex_ptn_create_char</a>
      </li>
      <li><a href="#fn_pregex_ptn_create_kle">pregex_ptn_create_kle</a>
      </li>
      <li><a href="#fn_pregex_ptn_create_opt">pregex_ptn_create_opt</a>
      </li>
      <li><a href="#fn_pregex_ptn_create_pos">pregex_ptn_create_pos</a>
      </li>
      <li><a href="#fn_pregex_ptn_create_refsub">pregex_ptn_create_refsub</a>
      </li>
      <li><a href="#fn_pregex_ptn_create_seq">pregex_ptn_create_seq</a>
      </li>
      <li><a href="#fn_pregex_ptn_create_string">pregex_ptn_create_string</a>
      </li>
      <li><a href="#fn_pregex_ptn_create_sub">pregex_ptn_create_sub</a>
      </li>
      <li><a href="#fn_pregex_ptn_dup">pregex_ptn_dup</a>
      </li>
      <li><a href="#fn_pregex_ptn_free">pregex_ptn_free</a>
      </li>
      <li><a href="#fn_pregex_ptn_parse">pregex_ptn_parse</a>
      </li>
      <li><a href="#fn_pregex_ptn_print">pregex_ptn_print</a>
      </li>
      <li><a href="#fn_pregex_ptn_to_dfa">pregex_ptn_to_dfa</a>
      </li>
      <li><a href="#fn_pregex_ptn_to_dfatab">pregex_ptn_to_dfatab</a>
      </li>
      <li><a href="#fn_pregex_ptn_to_nfa">pregex_ptn_to_nfa</a>
      </li>
      <li><a href="#fn_pregex_ptn_to_regex">pregex_ptn_to_regex</a>
      </li>
      <li><a href="#fn_pregex_qmatch">pregex_qmatch</a>
      </li>
      <li><a href="#fn_pregex_qreplace">pregex_qreplace</a>
      </li>
      <li><a href="#fn_pregex_qsplit">pregex_qsplit</a>
      </li>
      <li><a href="#fn_pregex_replace">pregex_replace</a>
      </li>
      <li><a href="#fn_pregex_split">pregex_split</a>
      </li>
      <li><a href="#fn_pregex_splitall">pregex_splitall</a>
      </li>
      <li><a href="#fn_pstr_to_wcs">pstr_to_wcs</a>
      </li>
      <li><a href="#fn_pstrcasecmp">pstrcasecmp</a>
      </li>
      <li><a href="#fn_pstrcatchar">pstrcatchar</a>
      </li>
      <li><a href="#fn_pstrcatstr">pstrcatstr</a>
      </li>
      <li><a href="#fn_pstrdup">pstrdup</a>
      </li>
      <li><a href="#fn_pstrget">pstrget</a>
      </li>
      <li><a href="#fn_pstrlen">pstrlen</a>
      </li>
      <li><a href="#fn_pstrltrim">pstrltrim</a>
      </li>
      <li><a href="#fn_pstrlwr">pstrlwr</a>
      </li>
      <li><a href="#fn_pstrncasecmp">pstrncasecmp</a>
      </li>
      <li><a href="#fn_pstrncatstr">pstrncatstr</a>
      </li>
      <li><a href="#fn_pstrndup">pstrndup</a>
      </li>
      <li><a href="#fn_pstrput">pstrput</a>
      </li>
      <li><a href="#fn_pstrrender">pstrrender</a>
      </li>
      <li><a href="#fn_pstrreplace">pstrreplace</a>
      </li>
      <li><a href="#fn_pstrrtrim">pstrrtrim</a>
      </li>
      <li><a href="#fn_pstrsplit">pstrsplit</a>
      </li>
      <li><a href="#fn_pstrtrim">pstrtrim</a>
      </li>
      <li><a href="#fn_pstrunescape">pstrunescape</a>
      </li>
      <li><a href="#fn_pstrupr">pstrupr</a>
      </li>
      <li><a href="#fn_putf8_char">putf8_char</a>
      </li>
      <li><a href="#fn_putf8_isutf">putf8_isutf</a>
      </li>
      <li><a href="#fn_putf8_move">putf8_move</a>
      </li>
      <li><a href="#fn_putf8_parse_char">putf8_parse_char</a>
      </li>
      <li><a href="#fn_putf8_seqlen">putf8_seqlen</a>
      </li>
      <li><a href="#fn_pvasprintf">pvasprintf</a>
      </li>
      <li><a href="#fn_pvawcsprintf">pvawcsprintf</a>
      </li>
      <li><a href="#fn_pwcs_to_str">pwcs_to_str</a>
      </li>
      <li><a href="#fn_pwcscatchar">pwcscatchar</a>
      </li>
      <li><a href="#fn_pwcscatstr">pwcscatstr</a>
      </li>
      <li><a href="#fn_pwcsdup">pwcsdup</a>
      </li>
      <li><a href="#fn_pwcsget">pwcsget</a>
      </li>
      <li><a href="#fn_pwcslen">pwcslen</a>
      </li>
      <li><a href="#fn_pwcsncatstr">pwcsncatstr</a>
      </li>
      <li><a href="#fn_pwcsndup">pwcsndup</a>
      </li>
      <li><a href="#fn_pwcsput">pwcsput</a>
      </li>
      <li><a href="#fn_pwhich">pwhich</a>
      </li>
      </ul>
    </li>
    </ul>
  </li>
  </ul>

</div>
<h1 id="toc2">Introduction</h1>

<p>
<b>phorward</b> (<i>libphorward</i>) is a generic C/C++ library and toolbox, serving platform-independent utilities for different purposes.
</p>

<ul>
<li>Data structures
    <ul>
    <li><a href="#parray">parray</a> - Dynamically managed arrays &amp; stacks
    </li>
    <li><a href="#pccl">pccl</a> - Character-classes
    </li>
    <li><a href="#plex">plex</a> - Lexical analyzers
    </li>
    <li><a href="#plist">plist</a> - Linked lists, hash-tables, queues &amp; stacks
    </li>
    <li><a href="#pregex">pregex</a> - Regular expressions
    </li>
    </ul>
</li>
<li>Generic helpers
    <ul>
    <li><a href="#ptrace">DEBUG-facilities</a> - Logging, tracing and run-time analysis
    </li>
    <li><a href="#fn_getopt">pgetopt</a> - Command-line options interpreter
    </li>
    <li><a href="#pstr">pstr*, pwcs*</a> - Enhanced string operations
    </li>
    </ul>
</li>
<li>Command-line tools
    <ul>
    <li><a href="#c_pdoc">pdoc</a> - C source code documentation tool
    </li>
    <li><a href="#c_pinclude">pinclude</a> - Generate big files from various smaller ones
    </li>
    <li><a href="#c_plex">plex</a> - Lexical analyzer generator and interpreter
    </li>
    <li><a href="#c_pproto">pproto</a> - C function prototype generator
    </li>
    <li><a href="#c_pregex">pregex</a> - Regular expressions match/find/split/replace
    </li>
    <li><a href="#c_ptest">ptest</a> - C program test facilities
    </li>
    </ul>
</li>
</ul>

<p>
The cornerstone for this C functions library was already laid in 2006 during some experimenting with several algorithms, data structures and their implementation. It rapidly turned out to become a general purpose library serving as the base toolchain for several, unfortunately mostly unfinished software projects which had their origin at <i>J.M.K S.F. Software Technologies</i>, which was later renamed to <i>Phorward Software Technologies</i>.
</p>
<p>
The library was then released as version 0.16 to the public in 2011, together with the open source parser generator <a href="http://unicc.phorward-software.com/">UniCC</a>. It was initially planned to use the library for other C-based software projects having their origin at Phorward Software Technologies also, but most of them where not continued, abandoned or evolved into other directions.
</p>
<p>
In 2019, the library was finally officially released as version 1.0, and will now be continued in several ways.
</p>

<h1 id="toc3">Installation</h1>

<h2 id="toc4">Building from sources</h2>

<p>
Building the Phorward C/C++ Library is as simple as every GNU-style open source program. Extract the release tarball or clone the Git repository into a directory of your choice.
</p>
<p>
Then, run
</p>

<pre><code class="language-c">
$ ./configure
</code></pre>

<p>
to configure the build-system and generate the Makefiles for your current platform. After successful configuration, run
</p>

<pre><code class="language-c">
$ make
</code></pre>

<p>
and
</p>

<pre><code class="language-c">
$ make install
</code></pre>

<p>
(properly as root), to install the toolkit into your system.
</p>

<h2 id="toc5">Local development build</h2>

<p>
Alternatively, there is also a simpler method for setting up a local build system for development and testing purposes.
</p>
<p>
To do so, type
</p>

<pre><code class="language-c">
$ make -f Makefile.gnu make_install
$ make
</code></pre>

<p>
This locally compiles the library or parts of it, and is ideal for development purposes.
</p>

<h2 id="toc6">Building on Windows</h2>

<p>
On Windows systems, the usage of Cygwin, Msys2, or another Unix shell environment is required.
</p>
<p>
The Phorward C/C++ Library also perfectly cross-compiles on Linux using the MinGW and MinGW_x86-64 compilers.
</p>

<pre><code class="language-c">
# To compile into 32-Bit Windows executables, configure with
$ ./configure --host=i486-mingw32 --prefix=/usr/i486-mingw32

# To compile into 64-Bit Windows executables, configure with
$ ./configure --host=x86_64-w64-mingw32 --prefix=/usr/x86_64-w64-mingw32
</code></pre>

<h1 id="toc7">Command-line tools</h1>

<p>
The Phorward C/C++ Library provides some useful command-line tools which can also be used or forked.
</p>

<h3 id="c_pdoc">pdoc - C source code documentation tool</h3>

<p>
<b>pdoc</b> is a tool to build documentation from C source code.
</p>

<pre><code class="language-c">
Usage: pdoc OPTIONS file...

    -d  --depth     DEPTH    Enforce headline level DEPTH (default:1)
    -h  --help               Show this help, and exit.
    -V  --version            Show version info and exit.

</code></pre>

<p>
pdoc currently is only used for libphorward's own library documentation, but can also be used as a base for similar documentation tools. It reads source code with C function definitions and preceding comments of the form
</p>

<pre><code class="language-c">
/**
This is a neat function.

It does something, and you //can// use txt2tags-relating formatting here, and
later run the result through txt2tags.
*/
int myLittleFunction( parray* a )
{
    ...
}
</code></pre>

<h3 id="c_pinclude">pinclude - Generate big files from various smaller ones</h3>

<p>
<b>pinclude</b> is some kind of simple pre-processor to generate one big file from various smaller ones.
</p>

<pre><code class="language-c">
Usage: pinclude OPTIONS file...

    -b  --begin     STRING   Configure block comment begin to STRING (/*)
    -e  --end       STRING   Configure block comment end to STRING (*/)
    -h  --help               Show this help, and exit.
    -l  --line      STRING   Configure line comment begin to STRING ()
    -q  --quiet              Disable commented output
    -V  --version            Show version info and exit.

</code></pre>

<p>
<div class="page-break"></div>
</p>

<h3 id="c_plex">plex - Lexical analyzer generator and interpreter</h3>

<p>
<b><a href="#plex">plex</a></b> is a command-line tool to construct and run lexical analyzers. It returns a list of tokens on success to stdout, and aims to be used in combination with shell scripts for lexical analysis.
</p>

<pre><code class="language-c">
Usage: plex OPTIONS patterns...

   -b  --begin     STRING    Use STRING as result begin separator
                             (' &gt;' is default)
   -e  --end       STRING    Use STRING as result end separator
                             ('&lt;\n' is default)
   -f  --file      FILENAME  Read input from FILENAME
   -h  --help                Show this help, and exit.
   -i  --input     INPUT     Use string INPUT as input.
   -V  --version             Show version info and exit.

</code></pre>

<p>
Example call:
</p>

<pre><code class="language-c">
plex -b ":" -e "\n" -i "123 abc456    78xy9" "\d+" "[a-z]+"
1:123
2:abc
1:456
1:78
2:xy
1:9
</code></pre>

<h3 id="c_pproto">pproto - C function prototype generator</h3>

<p>
<b>pproto</b> generates C function prototypes from C source code.
</p>

<pre><code class="language-c">
Usage: pproto OPTIONS file...

    -h  --help               Show this help, and exit.
    -n  --no-comments        Disable output of comments between files
    -s  --with-static        Output static declarations also
    -S  --only-static        Output static declarations only
    -V  --version            Show version info and exit.

</code></pre>

<p>
It can be seen as a very simple implementation of the well-known <i>cproto</i> command-line tool. It only accepts ANSI C functions as input. It recognizes #ifdef/#ifndef/#if/#endif-preprocessor directives around functions and emits them in the same manner to the output.
</p>
<p>
<div class="page-break"></div>
</p>

<h3 id="c_pregex">pregex - Regular expression operations</h3>

<p>
<b><a href="#pregex">pregex</a></b> is a command-line tool for regular expression operations on files and strings. It can be used for match, find, split and replace actions.
</p>

<pre><code class="language-c">
Usage: pregex OPTIONS {expression} input

   -a  --action    ACTION    Perform regular expression action:
                             match (default), find, split, replace
   -d  --delimiter STRING    Use STRING as result delimiter
                             (newline is default)
   -D                        Dump constructed DFA
   -e  --exec      EXPR      Use string EXPR as expression.
   -f  --file      FILENAME  Read expression from FILENAME
   -h  --help                Show this help, and exit.
   -i  --input     INPUT     Use string INPUT as input.
   -r  --replace   STRING    Replacement string for 'replace' action.
   -V  --version             Show version info and exit.

</code></pre>

<p>
Example call:
</p>

<pre><code class="language-c">
$ pregex -a find "\d+|[a-z]+" "123 abc456    78xy9"
123
abc
456
78
xy
9
</code></pre>

<p>
<div class="page-break"></div>
</p>

<h3 id="c_ptest">ptest - C program test facilities</h3>

<p>
<b>ptest</b> extracts test-cases (source snippets) from C code, compiles them, executes them and compares their result against a given output. If the output differs, the test failed, otherwise it succeeds.
</p>

<pre><code class="language-c">
Usage: ptest OPTIONS file...

    -D  --debug              Print test case outputs
    -h  --help               Show this help, and exit.
    -k  --keep               Keep generates files (for debugging)
    -V  --version            Show version info and exit.
</code></pre>

<p>
Example for a test case. Test-cases are defined as comments in the C source.
</p>

<pre><code class="language-c">
/*TESTCASE:parray_union
#include &lt;phorward.h&gt;

void dump( parray* a, void* p )
{
	printf( "%c%s", *((char*)p), p == parray_last( a ) ? "\n" : "" );
}

void testcase()
{
	parray  a;
	parray  b;

	parray_init( &amp;a, sizeof( char ), 0 );
	parray_init( &amp;b, sizeof( char ), 0 );

	parray_push( &amp;a, "a" );
	parray_push( &amp;a, "b" );
	parray_push( &amp;a, "c" );

	parray_push( &amp;b, "a" );
	parray_push( &amp;b, "d" );

	parray_iter( &amp;a, dump );
	parray_iter( &amp;b, dump );

	printf( "%ld\n", parray_union( &amp;b, &amp;a ) );

	parray_iter( &amp;a, dump );
	parray_iter( &amp;b, dump );
}
---
abc
ad
2
abc
adbc
*/
</code></pre>

<h1 id="toc14">General functions &amp; dynamic data structures</h1>

<h2 id="toc15">Advanced memory management</h2>

<p>
The standard memory management functions can be replaced by these pendants:
</p>

<ul>
<li><a href="#fn_pmalloc">pmalloc()</a> - allocate and zero-intialize memory, stop on error.
</li>
<li><a href="#fn_prealloc">prealloc()</a> - reallocate memory, stop on error.
</li>
<li><a href="#fn_pfree">pfree()</a> - free memory and return (void*)NULL pointer.
</li>
<li><a href="#fn_pmemdup">pmemdup()</a> - shorthand for a malloc() with memcpy().
</li>
</ul>

<p>
These functions are used throughout libphorward's internal object mapping functions.
</p>

<h2 id="pboolean">Boolean data type</h2>

<p>
libphorward makes heavy usage of the self-hosted data-type <b><a href="#pboolean">pboolean</a></b>, which is also referenced by a define <i>BOOLEAN</i>, and the constants <i>TRUE</i> and <i>FALSE</i>.
</p>
<p>
It is known, that several header files and projects define these constants on their own, so that <b><a href="#pboolean">pboolean</a></b>, the data-type, exists on its own using the p-prefix, but any of the defines are conditionally flagged with
</p>

<pre><code class="language-c">
#ifndef TRUE
#define TRUE					1
#endif
</code></pre>

<p>
within <code>phorward.h</code>.
</p>
<p>
See also
</p>

<ul>
<li><a href="#fn_BOOLEAN_STR">BOOLEAN_STR()</a> - converts a boolean expression into a string.
</li>
<li><a href="#fn_MAKE_BOOLEAN">MAKE_BOOLEAN()</a> - converts a boolean expression into a real <a href="#pboolean">pboolean</a> TRUE or FALSE.
</li>
</ul>

<p>
<div class="page-break"></div>
</p>

<h2 id="ptrace">Debugging and tracing</h2>

<p>
Although this option is not widely used in modern C/C++ projects, libphorward offers an own debug and trace facility that can be turned on for modules to detect bugs or view the program trace.
</p>
<p>
For this, the library provides the following macros:
</p>

<ul>
<li><a href="#fn_LOG">LOG()</a> - message logging with printf-style formatting
</li>
<li><a href="#fn_MSG">MSG()</a> - message logging (older style)
</li>
<li><a href="#fn_PROC">PROC()</a> - starting macro marking a functions entry point,
</li>
<li><a href="#fn_PARMS">PARMS()</a> - log function parameters,
</li>
<li><a href="#fn_RETURN">RETURN()</a> - return a value
</li>
<li><a href="#fn_VARS">VARS()</a> - log variables,
</li>
<li><a href="#fn_VOIDRET">VOIDRET</a> - return from a void function.
</li>
</ul>

<p>
So when a function is written like this in libphorward's way:
</p>

<pre><code class="language-c">
int faculty( int x )
{
	int ret;

	PROC( "faculty" );
	PARMS( "x", "%d", x );

	if( x &lt; 0 )
	{
		WRONGPARAM;
		RETURN( -1 );
	}
	else if( x == 0 )
	{
		MSG( "x is 0, so faculty is 1" );
		RETURN( 1 );
	}
	else
	{
		MSG( "Calling faculty recursively with:" );
		VARS( "x - 1", "%d", x - 1 );
		ret = x * faculty( x - 1 );
	}

	VARS( "ret", "%d", ret );
	RETURN( ret );
}
</code></pre>

<p>
Trace is written to stderr, and will be compiled into the executable code if the DEBUG preprocessor-flag is defined with a value &gt; 0.
</p>
<p>
Calling this function with
</p>

<pre><code class="language-c">
faculty( 3 );
</code></pre>

<p>
yields in a debug log
</p>

<pre><code class="language-c">
(faculty.c           :    7 0.000000) .ENTRY   : faculty
(faculty.c           :    8 0.000108) .PARMS   : x = &gt;3&lt;
(faculty.c           :   22 0.000055) .MSG     : Calling faculty recursively with:
(faculty.c           :   23 0.000042) .VARS    : x - 1 = &gt;2&lt;
(faculty.c           :    7 0.000039) ..ENTRY   : faculty
(faculty.c           :    8 0.000058) ..PARMS   : x = &gt;2&lt;
(faculty.c           :   22 0.000054) ..MSG     : Calling faculty recursively with:
(faculty.c           :   23 0.000045) ..VARS    : x - 1 = &gt;1&lt;
(faculty.c           :    7 0.000048) ...ENTRY   : faculty
(faculty.c           :    8 0.000078) ...PARMS   : x = &gt;1&lt;
(faculty.c           :   22 0.000072) ...MSG     : Calling faculty recursively with:
(faculty.c           :   23 0.000058) ...VARS    : x - 1 = &gt;0&lt;
(faculty.c           :    7 0.000048) ....ENTRY   : faculty
(faculty.c           :    8 0.000072) ....PARMS   : x = &gt;0&lt;
(faculty.c           :   17 0.000075) ....MSG     : x is 0, so faculty is 1
(faculty.c           :   18 0.000098) ....CLOCK   : faculty : 0.000155
(faculty.c           :   18 0.000087) ....RETURN  : faculty
(faculty.c           :   27 0.000068) ...VARS    : ret = &gt;1&lt;
(faculty.c           :   28 0.000070) ...CLOCK   : faculty : 0.000399
(faculty.c           :   28 0.000069) ...RETURN  : faculty
(faculty.c           :   27 0.000057) ..VARS    : ret = &gt;2&lt;
(faculty.c           :   28 0.000067) ..CLOCK   : faculty : 0.000592
(faculty.c           :   28 0.000059) ..RETURN  : faculty
(faculty.c           :   27 0.000052) .VARS    : ret = &gt;6&lt;
(faculty.c           :   28 0.000051) .CLOCK   : faculty : 0.000755
(faculty.c           :   28 0.000086) .RETURN  : faculty
</code></pre>

<p>
when previously setting the environment variable <code>TRACEMODULE="demo.c"</code> or <code>TRACEFUNCTION="faculty"</code>.
</p>
<p>
<div class="page-break"></div>
The following environment variables can be used when running programs using libphorward and compiled with <code>-DDEBUG</code>:
</p>

<table border="1">
<tr>
<th>Environment Variable</th>
<th>Example</th>
<th>Usage</th>
</tr>
<tr>
<td><code>TRACEMODULE</code></td>
<td><code>TRACEMODULE="faculty.c main.c"</code></td>
<td>Trace full C program module; multiple modules can be specified. Can be set to <code>*</code> to emit trace in ALL modules!</td>
</tr>
<tr>
<td><code>TRACEFUNCTION</code></td>
<td><code>TRACEFUNCTION="faculty plist_insert"</code></td>
<td>Trace only the functions specified. Can be set to <code>*</code> to emit trace of ALL functions!</td>
</tr>
<tr>
<td><code>TRACETYPE</code></td>
<td><code>TRACETYPE="ENTRY LOG RETURN"</code></td>
<td>Only print trace types given, ignore any other types. Can be set to <code>*</code> to emit all trace types (default)</td>
</tr>
<tr>
<td><code>TRACEDEPTH</code></td>
<td><code>TRACEDEPTH=5</code></td>
<td>Maximum trace depth, stop emitting trace when behind this level depth.</td>
</tr>
<tr>
<td><code>TRACEINDENT</code></td>
<td><code>TRACEINDENT=OFF</code></td>
<td>Enable/disable trace indentation; If switched OFF, the dots indicating the trace level depth are not emitted.</td>
</tr>
</table>

<p>
<div class="page-break"></div>
</p>

<h2 id="toc18">System-related, platform-independent helpers</h2>

<p>
The Phorward C/C++ Library provides some useful functions for system-related but platform independent operations.
</p>

<ul>
<li><a href="#fn_pbasename">pbasename()</a> returns the basename of a path (the last part),
</li>
<li><a href="#fn_pfiletostr">pfiletostr()</a> reads the content of an entire file into a dynamically allocated char*,
</li>
<li><a href="#fn_pfileexists">pfileexists()</a> checks for file existence,
</li>
<li><a href="#fn_pgetline">pgetline()</a> serves as a platform independent getline(),
</li>
<li><a href="#fn_pgetopt">pgetopt()</a> provides a simple to use, but effective GNU-style command-line argument parser,
</li>
<li><a href="#fn_pwhich">pwhich()</a> checks for a file using <a href="#fn_pfileexists">pfileexists()</a> in a PATH-like, delimited search path definition
</li>
</ul>

<p>
<div class="page-break"></div>
</p>

<h2 id="parray">Dynamically managed arrays &amp; stacks (parray)</h2>

<h3 id="toc20">Overview</h3>

<p>
The <a href="#parray">parray</a> object is a general-purpose data structure which can be used for several operations.
</p>
<p>
parray forms a data management container for handling homogeneous elements of the same size in a dynamic way. These elements can be atomic data types, pointers or structures. Elements are automatically allocated within a specified chunk-size, and can be appended or prepended to the given <a href="#parray">parray</a> object.
</p>
<p>
The <a href="#parray">parray</a> object implements:
</p>

<ul>
<li>dynamic stack functions
</li>
<li>data object collections
</li>
<li>set functions (unions, diffs)
</li>
</ul>

<p>
The <a href="#parray">parray</a> object brings the following advantages and disadvantages:
</p>

<ul>
<li><u>Advantages</u>
  <ul>
  <li>Chunk allocation requires lesser <a href="#fn_pmalloc">pmalloc()</a>/<a href="#fn_prealloc">prealloc()</a> operations than with <a href="#plist">plist</a>-objects
  </li>
  <li>Dynamic and quick implementation for huge data structures
  </li>
  <li>Elements are held in a real array on the heap
  </li>
  <li>Low memory consumption
  </li>
  <li>Fast iteration over elements
  </li>
  </ul>
</li>
<li><u>Disadvantages</u>
  <ul>
  <li>No hashable entries
  </li>
  <li>Not as flexible as plist; especially element rearrangement requires more care
  </li>
  <li>Removing elements or rechaining requires more computing power
  </li>
  <li>Careful programming necessary, problems with lost pointers may be
    encountered after memory-reallocations!
  </li>
  </ul>
</li>
</ul>

<h3 id="toc21">Construction and destruction</h3>

<p>
parray objects are created using <a href="#fn_parray_create">parray_create()</a> or initialized with <a href="#fn_parray_init">parray_init()</a>. The specific functions require the objects byte size that is required for every single element, and a chunk-size. Latter one can be omitted by specifing a chunk-size of 0, so that 128 elements per chunk will be the default. Objects can be cleared with <a href="#fn_parray_erase">parray_erase()</a>, respectively cleared and freed with <a href="#fn_parray_free">parray_free()</a>.
</p>

<pre><code class="language-c">
parray* a;

a = parray_create( sizeof( usertype ), 0 );

/* Do something... */

parray_free( a );
</code></pre>

<p>
<div class="page-break"></div>
</p>

<h3 id="toc22">Inserting elements</h3>

<p>
Elements can be inserted with
</p>

<ul>
<li><a href="#fn_parray_insert">parray_insert()</a> - insert element at any desired offset,
</li>
<li><a href="#fn_parray_push">parray_push()</a> - push element to end of array,
</li>
<li><a href="#fn_parray_shift">parray_shift()</a> - shift element on begin of array,
</li>
<li><a href="#fn_parray_malloc">parray_malloc()</a> - zero-initialize new element at end of array, and
</li>
<li><a href="#fn_parray_rmalloc">parray_rmalloc()</a> - zero-initialize new element at begin of array.
</li>
</ul>

<pre><code class="language-c">
parray* a;
usertype t;
usertype* tp;

fill_usertype( &amp;t );
parray_insert( a, 2, &amp;t );

fill_usertype( &amp;t );
parray_push( a, &amp;t );
parray_shift( a, &amp;t );

tp = (usertype*)parray_malloc( a );
fill_usertype( tp );
tp = (usertype*)parray_rmalloc( a );
fill_usertype( tp );
</code></pre>

<h3 id="toc23">Accessing and iterating elements</h3>

<p>
Direct access to specific elements is done using
</p>

<ul>
<li><a href="#fn_parray_get">parray_get()</a> - get element by offset from begin, and
</li>
<li><a href="#fn_parray_rget">parray_rget()</a> - get element by offset from end.
</li>
<li><a href="#fn_parray_for">parray_for()</a> - Expands into a for-loop iterating over elements.
</li>
<li><a href="#fn_parray_iter">parray_iter()</a> - Iterate over all elements and call a function on each element.
</li>
<li><a href="#fn_parray_riter">parray_riter()</a> - Like <a href="#fn_parray_iter">parray_iter()</a>, but backwards.
</li>
</ul>

<p>
Iterating over the elements:
</p>

<pre><code class="language-c">
parray* a;
usertype* tp;

/* Using a pointer ---------------------------------------------------------- */

for( tp = parray_first( a ); tp; tp = parray_next( a, tp ) )
	;

/* Shortcut */
parray_for( a, tp )
	;

/* Using a callback function ------------------------------------------------ */

void tp_callback( parray* a, usertype* tp )
{
	/* ... */
}

parray_iter( a, (parrayfn)tp_callback ); /* Forwards... */
parray_riter( a, (parrayfn)tp_callback ); /* Backwards... */

/* Using a counter ---------------------------------------------------------- */
int i;

/* Iterate from first to last. */
for( i = 0; ( tp = (usertype*)parray_get( a, i ) ); i++ )
	;

/* Iterate from last to first. */
for( i = 0; ( tp = (usertype*)parray_rget( a, i ) ); i++ )
	;
</code></pre>

<p>
Quick access to the first or last element is gained by <a href="#fn_parray_last">parray_last()</a> and <a href="#fn_parray_first">parray_first()</a>.
</p>
<p>
To get a predecessor or successor of an element, use <a href="#fn_parray_prev">parray_prev()</a> respectively <a href="#fn_parray_next">parray_next()</a>.
</p>
<p>
Elements can be replaced by <a href="#fn_parray_put">parray_put()</a> and <a href="#fn_parray_rput">parray_rput()</a> via their index.
</p>

<h3 id="toc24">Removing elements</h3>

<p>
Elements can be removed with
</p>

<ul>
<li><a href="#fn_parray_remove">parray_remove()</a> - remove element at any desired offset,
</li>
<li><a href="#fn_parray_pop">parray_pop()</a> - remove last element like from a stack, and
</li>
<li><a href="#fn_parray_unshift">parray_unshift()</a> - remove first element.
</li>
</ul>

<pre><code class="language-c">
parray* a;
usertype t;
usertype* tp;

parray_remove( a, 2, &amp;t );
tp = (usertype*)parray_pop( a );
tp = (usertype*)parray_unshift( a );
</code></pre>

<h3 id="toc25">Sorting elements</h3>

<p>
parray objects provide a sorting automatism, so that elements can be sorted on demand.
</p>
<p>
The sorting order and rule is defined using an element comparison callback-function, which returns element lower, greater or equality like memcmp() does.
</p>
<p>
This function can be individually set using <a href="#fn_parray_set_sortfn">parray_set_sortfn()</a>, and by default points to a callback function that uses memcmp() as the element comparison function.
</p>
<p>
As prototype and example, the following comparison function:
</p>

<pre><code class="language-c">
int my_compare( parray* a, usertype* p, usertype* q )
{
	if( p &lt; q )
		return -1;
	else if( p &gt; q )
		return 1;

	return 0;
}
</code></pre>

<p>
This function can then be attached to an <a href="#parray">parray</a> object with
</p>

<pre><code class="language-c">
parray_set_sortfn( a, my_compare );
</code></pre>

<p>
Sorting can be performed by invoking the functions
</p>

<ul>
<li><a href="#fn_parray_sort">parray_sort()</a> - to sort the entire array,
</li>
<li><a href="#fn_parray_subsort">parray_subsort()</a> - to sort only a part of the array (begin- and end-elements required).
</li>
</ul>

<p>
The used algorithm is quick-sort.
</p>

<h3 id="toc26">Interchanging functions</h3>

<p>
parray objects also provide functions to handle data collections and sets, by providing functions that can deal with two objects of kind <a href="#parray">parray</a>. Both arrays must be configured with the same element memory size, else all functions will fail.
</p>
<p>
To implement these functions, every <a href="#parray">parray</a> object also refers to a comparison-callback function. This is, by default, the same function as used for the sorting, and has also the same signature. This function can be implemented to check for element equality within set handling functions.
</p>

<ul>
<li><a href="#fn_parray_diff">parray_diff()</a> - checks two arrays for same items (equality),
</li>
<li><a href="#fn_parray_union">parray_union()</a> - extends an array to all elements of a secondary array that are not equal within the first array.
</li>
</ul>

<p>
<div class="page-break"></div>
</p>

<h3 id="toc27">Additional functions</h3>

<p>
Other, useful functions are
</p>

<ul>
<li><a href="#fn_parray_count">parray_count()</a> - get number of elements within object,
</li>
<li><a href="#fn_parray_offset">parray_offset()</a> - get offset of element by pointer,
</li>
<li><a href="#fn_parray_partof">parray_partof()</a> - check if element is part of object,
</li>
<li><a href="#fn_parray_swap">parray_swap()</a> - swap two elements within an object,
</li>
<li><a href="#fn_parray_reserve">parray_reserve()</a> - assume memory pre-allocation; This is interesting for stack operations.
</li>
</ul>

<p>
<div class="page-break"></div>
</p>

<h2 id="plist">Linked lists, hash-tables, queues &amp; stacks (plist)</h2>

<h3 id="toc29">Overview</h3>

<p>
Next to the <a href="#parray">parray</a> object, the <a href="#plist">plist</a> object is a powerful C implementation of a double-linked list with some extra features. It is also used for handling homogeneous elements of the same size in a dynamic way, and can be used for many tasks.
</p>
<p>
plist can be seen as a superset of the <a href="#parray">parray</a> object, because it features nearly the same operations but with other underlying data management methods.
</p>
<p>
The <a href="#plist">plist</a> object implements:
</p>

<ul>
<li>a double linked-list
</li>
<li>hashable entries (hash table, including same element key stacking)
</li>
<li>dynamic stack functionalities
</li>
<li>data object collections
</li>
<li>set functions
</li>
</ul>

<p>
plist can be used as a generic data structure for
</p>

<ul>
<li>hash tables
</li>
<li>queues
</li>
<li>arrays
</li>
<li>stacks
</li>
</ul>

<p>
The <a href="#plist">plist</a> object brings the following advantages and disadvantages:
</p>

<ul>
<li><u>Advantages</u>
  <ul>
  <li>Allows pointer-mode and entity-mode configuration (PLIST_MOD_PTR)
  </li>
  <li>Additionally find objects using a hash-table
  </li>
  <li>Provides element recycling methods (PLIST_MOD_RECYCLE)
  </li>
  <li>Elements are chained, can be re-arraged and have persistent pointers
  </li>
  <li>Automatical sorting using individual sort-functions
  </li>
  <li>Simple set-theory functions (union, diff)
  </li>
  </ul>
</li>
<li><u>Disadvantages</u>
  <ul>
  <li>High memory consumption, especially in case when used with hash-tables
  </li>
  <li>Iteration over elements is much slower
  </li>
  <li>List elements are chained as <a href="#plistel">plistel</a> data structures, while the data members must be called separately
  </li>
  <li>All operations require more computing power in comparison to parray
  </li>
  </ul>
</li>
</ul>

<p>
<div class="page-break"></div>
</p>

<h3 id="toc30">Construction and destruction</h3>

<p>
plist objects are created using <a href="#fn_plist_create">plist_create()</a> or initialized with <a href="#fn_plist_init">plist_init()</a>. The specific functions require the objects byte size that is required for every single element, and a flag configuration, that configures the <a href="#plist">plist</a> object to a specified behavior.
</p>
<p>
Possible flags are listed below, and can be combined using bitwise or (|).
</p>

<ul>
<li><b>PLIST_MOD_NONE</b> no flags, this can also be just 0.
</li>
<li><b>PLIST_MOD_PTR</b> to use the <a href="#plist">plist</a>-object in pointer-mode: Each element contains only a pointer to an object in memory and returns this, instead of copying from or into pointers.
</li>
<li><b>PLIST_MOD_RECYCLE</b> to configure that elements that are removed during list usage will be reused later, which reduces dynamic memory consumption.
</li>
<li><b>PLIST_MOD_AUTOSORT</b> to automatically sort the list on insert operations.
</li>
<li><b>PLIST_MOD_EXTKEYS</b> to configure that string pointers to hash-table key values are stored elsewhere, so the <a href="#plist">plist</a>-module only uses the original pointers instead of copying them.
</li>
<li><b>PLIST_MOD_PTRKEYS</b> disables string keys and uses the pointer/value provided as key directly.
</li>
<li><b>PLIST_MOD_UNIQUE</b> to disallow hash-table-key collisions, so elements with a key that already exists in the object will be rejected.
</li>
<li><b>PLIST_MOD_KEEPKEYS</b> holds the correct element insertation sequence. In case of a key collision, the inserted element is inserted <u>behind</u> the colliding element rather than <u>before</u>.
</li>
<li><b>PLIST_MOD_WCHAR</b> to let all key values handle as wide-character strings.
</li>
</ul>

<p>
The mode <b>PLIST_MOD_PTR</b> is automatically set if the elements size is specified as 0.
</p>
<p>
A <a href="#plist">plist</a> object must be freed using <a href="#fn_plist_free">plist_free()</a> or cleared with <a href="#fn_plist_clear">plist_clear()</a>.
</p>

<pre><code class="language-c">
plist* l;

l = plist_create( sizeof( usertype ), PLIST_MOD_RECYCLE );

/* Do something... */

plist_free( l );
</code></pre>

<p>
<div class="page-break"></div>
</p>

<h3 id="toc31">Inserting elements</h3>

<p>
Elements can be inserted with
</p>

<ul>
<li><a href="#fn_plist_insert">plist_insert()</a> - insert element, optionally with key, at any desired position,
</li>
<li><a href="#fn_plist_push">plist_push()</a> - push element to end of list,
</li>
<li><a href="#fn_plist_shift">plist_shift()</a> - shift element on begin of list,
</li>
<li><a href="#fn_plist_malloc">plist_malloc()</a> - zero-initialize new element at end of list, and
</li>
<li><a href="#fn_plist_rmalloc">plist_rmalloc()</a> - zero-initialize new element at begin of list.
</li>
</ul>

<pre><code class="language-c">
plist* l;
usertype t;
usertype* tp;

/* Insert to position */
fill_usertype( &amp;t );
plist_insert( l, plist_get( l, 2 ), (char*)NULL, &amp;t );

/* Insert to end, with key value */
plist_insert( l, (plistel*)NULL, "hello", &amp;t );

/* Insert to end and begin */
fill_usertype( &amp;t );
plist_push( a, &amp;t );
plist_shift( a, &amp;t );

/* Retrieve fresh element memory at end and begin */
tp = (usertype*)plist_malloc( a );
fill_usertype( tp );
tp = (usertype*)plist_rmalloc( a );
fill_usertype( tp );
</code></pre>

<p>
<div class="page-break"></div>
</p>

<h3 id="plistel">Accessing and iterating elements</h3>

<p>
Elements within a <a href="#plist">plist</a> object are referenced by <a href="#plistel">plistel</a> items. To access the data element behind a <a href="#plistel">plistel</a> item, the function <a href="#fn_plist_access">plist_access()</a> is used, in combination with element retrival functions, like
</p>

<ul>
<li><a href="#fn_plist_get">plist_get()</a> - get element by offset,
</li>
<li><a href="#fn_plist_rget">plist_rget()</a> - get element by offset from the end,
</li>
<li><a href="#fn_plist_first">plist_first()</a> - get first element,
</li>
<li><a href="#fn_plist_last">plist_last()</a> - get last element,
</li>
<li><a href="#fn_plist_get_by_key">plist_get_by_key()</a> - retrieve element by key (in a hash table),
</li>
<li><a href="#fn_plist_get_by_ptr">plist_get_by_ptr()</a> - retrieve element by its data pointer.
</li>
<li><a href="#fn_plist_for">plist_for()</a> - Expands into a for-loop iterating over elements.
</li>
<li><a href="#fn_plist_iter">plist_iter()</a> - Iterate over all elements and call a function on each element.
</li>
<li><a href="#fn_plist_riter">plist_riter()</a> - Like <a href="#fn_plist_iter">plist_iter()</a>, but backwards.
</li>
</ul>

<pre><code class="language-c">
plist* l;
plistel* e;
usertype* tp;
int i;

/* Get 6th data element */
tp = (usertype*)plist_access( plist_get( l, 5 ) );

/* Get data element with key "hello" */
tp = (usertype*)plist_access( plist_get_by_key( l, "hello" ) );

/* Iterate from begin to end */
for( e = plist_first( l ); e; e = plist_next( e ) )
	tp = (usertype*)plist_access( e );

/* Alternative: Using the plist_for()-macro */
plist_for( l, e )
	tp = (usertype*)plist_access( e );

/* Alternative: Using offset */
for( i = 0; ( tp = (usertype*)plist_access( plist_get( l, i ) ) ); i++ )
	;

/* Reversely iterate from end to begin */
for( e = plist_last( l ); e; e = plist_prev( e ) )
	tp = (usertype*)plist_access( e );

/* Reverse alternative: Using offset */
for( i = 0; ( tp = (usertype*)plist_access( plist_rget( l, i ) ) ); i++ ) ;
</code></pre>

<p>
<div class="page-break"></div>
</p>

<h3 id="toc33">Removing elements</h3>

<p>
To remove elements from a <a href="#plist">plist</a> object, the following functions can be used.
</p>

<ul>
<li><a href="#fn_plist_remove">plist_remove()</a> - remove any element,
</li>
<li><a href="#fn_plist_pop">plist_pop()</a> - pop last element as from a stack,
</li>
<li><a href="#fn_plist_unshift">plist_unshift()</a> - remove first element as from a queue.
</li>
</ul>

<pre><code class="language-c">
plist* l;
usertype t;

plist_remove( l, plist_get( l, 7 ) );
plist_pop( a, &amp;t );
plist_unshift( a, &amp;t );
</code></pre>

<h3 id="toc34">Sorting elements</h3>

<p>
plist objects provide a sorting automatism, so that elements can be sorted on demand or on the fly at each element insertion.
</p>
<p>
The sorting order and rule is defined using an element comparison callback-function, which returns element lower, greater or equality like strcmp() does.
This function can be individually set using <a href="#fn_plist_set_sortfn">plist_set_sortfn()</a>, and by default points to a callback function that uses memcmp() as the element comparison function.
</p>
<p>
As prototype and example, the following comparison function:
</p>

<pre><code class="language-c">
int my_compare( plist* list, plistel* l, plistel* r )
{
	usertype*	tr;
	usertype*	tl;

	tl = (usertype*)plist_access( l );
	tr = (usertype*)plist_access( r );

	if( tl &lt; tr )
		return -1;
	else if( tl &gt; tr )
		return 1;

	return 0;
}
</code></pre>

<p>
This can then be attached to the <a href="#plist">plist</a> object with
</p>

<pre><code class="language-c">
plist_set_sortfn( l, my_compare );
</code></pre>

<p>
To configure a <a href="#plist">plist</a> object to be auto-sorted, the flag PLIST_MOD_AUTOSORT should be used at construction.
Sorting can also be performed by invoking the functions
</p>

<ul>
<li><a href="#fn_plist_sort">plist_sort()</a> - to sort the entire list,
</li>
<li><a href="#fn_plist_subsort">plist_subsort()</a> - to sort only a part of the list (begin- and end-elements required).
</li>
</ul>

<p>
The used algorithm is quick-sort.
</p>

<h3 id="toc35">Interchanging functions</h3>

<p>
plist objects also provide functions to handle data collections and sets, by providing functions that can deal with two objects of kind <a href="#plist">plist</a>. Both lists must be configured with the same element memory size, else all functions will fail.
</p>
<p>
To implement these functions, every <a href="#plist">plist</a> object also refers to a comparison-callback function. This is, by default, the same function as used for the sorting, and has also the same signature. This function can be implemented to check for element equality within set handling functions.
</p>

<ul>
<li><a href="#fn_plist_diff">plist_diff()</a> - checks two lists for same items (equality),
</li>
<li><a href="#fn_plist_union">plist_union()</a> - extends a list to all elements of a second list that are not equal to elements in the first list.
</li>
</ul>

<h3 id="toc36">Additional functions</h3>

<p>
plist provides these additional functions:
</p>

<ul>
<li><a href="#fn_plist_swap">plist_swap()</a> - swaps the two elements within a list,
</li>
<li><a href="#fn_plist_dup">plist_dup()</a> - duplicate list and its items,
</li>
<li><a href="#fn_plist_count">plist_count()</a> - return number of items in a list.
</li>
</ul>

<p>
<div class="page-break"></div>
</p>

<h2 id="pccl">Character-classes (pccl)</h2>

<p>
The <a href="#pccl">pccl</a> object is established on top of the <a href="#plist">plist</a> object and encapsulates easy-to-handle low-level functions for character-class handling.
</p>
<p>
These functions are heavily used by the library's regular expressions, but may also be helpful for other related projects. <a href="#pccl">pccl</a> can handle character classes, by chaining ranges.
</p>
<p>
It supports a fully-fledged set theory automatism, including construction of intersections, unions, range removal or appending. <a href="#pccl">pccl</a> objects are designed to work on huge alphabets with low memory consumption. By default, characters are specified as <b>wchar_t</b> (wide-character unicode) values.
</p>

<ul>
<li><a href="#fn_pccl_create">pccl_create()</a> - create and optionally parse a new character-class,
</li>
<li><a href="#fn_pccl_parse">pccl_parse()</a> - parse characters and ranges from a string into a character-class,
</li>
<li><a href="#fn_pccl_negate">pccl_negate()</a> - negate a character-class over the character universe,
</li>
<li><a href="#fn_pccl_add">pccl_add()</a>, <a href="#fn_pccl_addrange">pccl_addrange()</a> - add single characters or ranges to the class,
</li>
<li><a href="#fn_pccl_del">pccl_del()</a>, <a href="#fn_pccl_delrange">pccl_delrange()</a> - delete single characters or ranges from the class,
</li>
<li><a href="#fn_pccl_test">pccl_test()</a>, <a href="#fn_pccl_testrange">pccl_testrange()</a> - test if a character or range matches a class,
</li>
<li><a href="#fn_pccl_to_str">pccl_to_str()</a> - convert a character-class into a string,
</li>
<li><a href="#fn_pccl_free">pccl_free()</a> - destroy a previously created character-class,
</li>
</ul>

<pre><code class="language-c">
pccl* ccl;

/* Construct a character-class within a universe of the ASCII-alphabet (0-255):
	"-0123456789ABCDEFGHIJKLMNOQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz"
*/
ccl = pccl_create( 0, 255, "A-Za-z0-9_-" );

/* Invert character class */
pccl_negate( ccl );

/* Remove system chars */
pccl_delrange( ccl, 0, 31 );

/* Oh, and delete the "z" */
pccl_del( ccl, 'z' );

/* But add tab again! */
pccl_add( ccl, '\t' );

/* Enable all from 32 to 126  */
pccl_addrange( ccl, ' ', '~' );

/* Alternative way: */
pccl_parse( ccl, " -~", TRUE );

/* Test for characters */
printf( "A is in? %s\n", BOOLEAN_STR( pccl_test( ccl, 'A' ) );
printf( "a-z are in? %s\n", BOOLEAN_STR( pccl_testrange( ccl, 'a', 'z' ) );
printf( "\\n is in? %s\n", BOOLEAN_STR( pccl_test( ccl, '\n' ) );

/* Generate string */
printf( "My ccl is: %s\n", pccl_to_str( ccl, TRUE ) );

/* Drop it! */
pccl_free( ccl );
</code></pre>

<p>
Useful, additional functions when working with <a href="#pccl">pccl</a> are:
</p>

<ul>
<li><a href="#fn_pccl_compare">pccl_compare()</a> - compare character-classes,
</li>
<li><a href="#fn_pccl_diff">pccl_diff()</a> - create differencing character-class of two classes,
</li>
<li><a href="#fn_pccl_erase">pccl_erase()</a> - clear character-class,
</li>
<li><a href="#fn_pccl_get">pccl_get()</a> - retrieve characters or ranges by offset,
</li>
<li><a href="#fn_pccl_instest">pccl_instest()</a> - like <a href="#fn_pccl_test">pccl_test()</a>, but with insensitve-character check,
</li>
<li><a href="#fn_pccl_intersect">pccl_intersect()</a> - create intersection character-class of two classes,
</li>
<li><a href="#fn_pccl_print">pccl_print()</a> - print character-class (for debug),
</li>
<li><a href="#fn_pccl_parsechar">pccl_parsechar()</a> - parse an escaped character sequence into a wide-character,
</li>
<li><a href="#fn_pccl_parseshorthand">pccl_parseshorthand()</a> - parse a typical shorthand (\d, \w) into a character-class.
</li>
</ul>

<h1 id="toc38">Regular expressions &amp; lexical analyzers (pregex, plex)</h1>

<h2 id="toc39">Overview</h2>

<p>
libphorward provides a powerful set of functions relating to general string pattern matching and lexical analysis using regular expressions.
</p>

<ul>
<li>The <a href="#pregex">pregex</a> object encapsulates several regular expression patterns into one data structure that is compiled into a reusable DFA (deterministic finite automata) for quick pattern processing. Strings can be matched, split or replaced on patterns.
  <ul>
  <li>Based on the <a href="#pregex">pregex</a> object, the functions <a href="#fn_pregex_qmatch">pregex_qmatch()</a>, <a href="#fn_pregex_qsplit">pregex_qsplit()</a> and <a href="#fn_pregex_qreplace">pregex_qreplace()</a> are provided, for one-line string processing.
  </li>
  </ul>
</li>
<li>The <a href="#plex">plex</a> object ecapsulates a regular expression-based scanner for lexical analysis into one object. It is used by libphorward's <a href="#pparse">build-in parser generator</a> for lexical analysis also.
</li>
<li>All functions are designed to work on wide-character alphabets to fully support Unicode. Therefore, the flags PREGEX_COMP_WCHAR and PREGEX_RUN_WCHAR are provided, to allow processing on patterns and input strings provided as wide-character strings. If not explicitly deactivated by build-flags (-DUTF8), UTF-8 input is generally supported on all functions.
</li>
<li>Supports anchoring and back-references.
</li>
<li>Patterns are internally encapsulated in structures of <a href="#pregex_ptn">pregex_ptn</a>, which are then used to generate the NFA (nondeterministic finite automata) from which a DFA is constructed (subset construction algorithm).
</li>
<li>Matches are described in a structure called <a href="#prange">prange</a>.
</li>
<li>DFAs can be deployed in form of a two dimensional array containing all information that is required to run the regex without the slower, object-oriented data structure layers.
</li>
</ul>

<h3 id="toc40">Meta constructs</h3>

<p>
In general, regular expressions are made-up of the following elements:
</p>

<table border="1">
<tr>
<th>Construct</th>
<th>Usage</th>
</tr>
<tr>
<td><code>[...]</code> or <code>[^...]</code></td>
<td>Specifies a character, character-class or negated character-class (^).</td>
</tr>
<tr>
<td><code>.</code></td>
<td>Specifies a character-class standing for "any character". Using this construct causes the terminal to be configured as "non-greedy".</td>
</tr>
<tr>
<td><code>(</code> and <code>)</code></td>
<td>Parantheses to build sub-expressions.</td>
</tr>
<tr>
<td><code>|</code></td>
<td>The alternative operator to define multiple expressions at one expression level.</td>
</tr>
<tr>
<td><code>*</code></td>
<td>Kleene closure (none or several of previous expression) modifier.</td>
</tr>
<tr>
<td><code>+</code></td>
<td>Positive closure (one or several of previous expression) modifier.</td>
</tr>
<tr>
<td><code>?</code></td>
<td>Optional closure (none or one of previous expression) modifier.</td>
</tr>
</table>

<p>
All meta-characters can be escaped by backslash, so they are interpretered as usual characters.
</p>
<p>
<div class="page-break"></div>
</p>

<h3 id="toc41">Characters and escape sequences</h3>

<p>
Any other character coming up is consumed as one expression to be matched in the input.
By default, all strings are interpretered in UTF-8 encoded unicode style, so unicode is fully supported.
</p>
<p>
Escape sequences (C-style) are supported according to the following table:
</p>

<table border="1">
<tr>
<th>Escape sequence</th>
<th>Description</th>
</tr>
<tr>
<td><code>\a</code></td>
<td>Bell (alert)</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>Backspace</td>
</tr>
<tr>
<td><code>\f</code></td>
<td>Formfeed</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>New line</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>Carriage return</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>Horizontal tab</td>
</tr>
<tr>
<td><code>\v</code></td>
<td>Vertical tab</td>
</tr>
<tr>
<td><code>\'</code></td>
<td>Single quotation mark</td>
</tr>
<tr>
<td><code>\"</code></td>
<td>Double quotation mark</td>
</tr>
<tr>
<td><code>\\</code></td>
<td>Backslash</td>
</tr>
<tr>
<td><code>\OOO</code></td>
<td>ASCII character in octal notation, (O = octal digit)</td>
</tr>
<tr>
<td><code>\xHH</code></td>
<td>ASCII character in hexadecimal notation (H = hexadecimal digit)</td>
</tr>
<tr>
<td><code>\uHHHH</code></td>
<td>32-Bit Unicode character in hexadecimal notation (H = hexadecimal digit)</td>
</tr>
<tr>
<td><code>\UHHHHHHHH</code></td>
<td>64-Bit Unicode character in hexadecimal notation (H = hexadecimal digit)</td>
</tr>
</table>

<p>
<u><b>Note:</b> When specifying escape-sequences in static strings within C-code, they must be double-escaped, because they are first analyzed by the C compiler and then by libphorward's regex-parser. Therefore, specifiying a backslash <code>\\</code> must become <code>\\\\</code> in the C-Code, which then yields in <code>\\</code> after compiling the C program.</u>
</p>

<h3 id="toc42">Shorthand character classes</h3>

<p>
Pre-defined shorthand character-classes are also supported by libphorward's <a href="#pregex">pregex</a> and <a href="#plex">plex</a> tools.
</p>

<table border="1">
<tr>
<th>Shorthand</th>
<th>Complains with</th>
<th>Explanation</th>
</tr>
<tr>
<td>\w</td>
<td>[A-Za-z0-9_]</td>
<td>All alphanumeric characters (ASCII only)</td>
</tr>
<tr>
<td>\W</td>
<td>[^A-Za-z0-9_]</td>
<td>Any other than (ASCII only) alphanumeric characters</td>
</tr>
<tr>
<td>\d</td>
<td>[0-9]</td>
<td>All digit characters (ASCII-only)</td>
</tr>
<tr>
<td>\D</td>
<td>[^0-9]</td>
<td>Any other than (ASCII only) digit characters</td>
</tr>
<tr>
<td>\s</td>
<td>[ \f\n\r\t\v]</td>
<td>All whitespace characters (ASCII-only)</td>
</tr>
<tr>
<td>\S</td>
<td>[^ \f\n\r\t\v]</td>
<td>Any other than (ASCII only) whitespace characters</td>
</tr>
</table>

<h3 id="toc43">Anchoring</h3>

<p>
The following anchors are supported, when specified at beginning or ending of an expression:
</p>

<table border="1">
<tr>
<th>Anchor</th>
<th>Usage</th>
</tr>
<tr>
<td><code>^</code></td>
<td>Anchor at begin of pattern, matching begin-of-line.</td>
</tr>
<tr>
<td><code>$</code></td>
<td>Anchor at end of pattern, matching end-of-line.</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>Anchor at begin of pattern, matching begin-of-word.</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>Anchor at end of pattern, matching end-of-word.</td>
</tr>
</table>

<p>
Anchors can be entirely switched off when setting the PREGEX_COMP_NOANCHORS on compile-time, respectively PREGEX_RUN_NOANCHORS on run-time.
</p>

<h3 id="toc44">Examples</h3>

<p>
Some examples:
</p>

<ul>
<li><code>Hello World</code> matches "Hello World",
</li>
<li><code>Hello? World</code> matches "Hello World" and "Hell World",
</li>
<li><code>Hello+ World</code> matches "Hello World" or "Hellooooooooo World",
</li>
<li><code>Hello* World</code> matches "Hello World", "Hellooooooooo World" or even "Hell World",
</li>
<li><code>(Hello)? World</code> matches "Hello World" and " World",
</li>
<li><code>(Hello)+ World</code> matches "Hello World" and "HelloHelloHello World",
</li>
<li><code>(Hello)* World</code> matches "Hello World", "HelloHelloHello World" or even " World",
</li>
<li><code>[any]+ World</code> matches "any World", "n World, "nyan World" or "nayayayaaa World",
</li>
<li><code>[^none]* World</code> matches "yuluthisisfun World", "xyz World" and " World",
</li>
<li><code>'([^']|\\')*'</code> matches "''", "'Hello World'" or even "'What\'s Up?'",
</li>
<li><code>Hello|World</code> matches "Hello" or "World",
</li>
<li><code>Hello (World|Universe)</code> matches both "Hello World" or "Hello Universe".
</li>
</ul>

<p>
(TODO: more examples)
</p>

<h2 id="pregex">Operating on regular expressions (pregex)</h2>

<p>
The <a href="#pregex">pregex</a> object is the object-oriented interface for string operations based on regular expressions.
</p>
<p>
Patterns are compiled into a DFA and associated with the <a href="#pregex">pregex</a> object as a reusable state machine that can be executed several times.
</p>
<p>
Generally, the actions
</p>

<ul>
<li>matching
</li>
<li>finding
</li>
<li>splitting
</li>
<li>replacing
</li>
</ul>

<p>
are supported by the compiled pattern.
</p>

<h3 id="toc46">Construction and destruction</h3>

<p>
pregex objects are constructed by <a href="#fn_pregex_create">pregex_create()</a>. First parameter is the regular expression pattern string that is compiled into a DFA. The second parameter allows to specify several flags for influencing the compile- and execution process. All flags can be combined using the bitwise or-operator (|).
</p>

<table border="1">
<tr>
<th>Flag</th>
<th>Usage</th>
</tr>
<tr>
<td>PREGEX_COMP_WCHAR</td>
<td>The regular expression provided to pregex_create() shall be casted to wchar_t.</td>
</tr>
<tr>
<td>PREGEX_COMP_NOANCHORS</td>
<td>Ignore anchor tokens, handle them as normal characters</td>
</tr>
<tr>
<td>PREGEX_COMP_NOREF</td>
<td>Don't compile references.</td>
</tr>
<tr>
<td>PREGEX_COMP_NONGREEDY</td>
<td>Compile regex to be forced nongreedy.</td>
</tr>
<tr>
<td>PREGEX_COMP_NOERRORS</td>
<td>Don't report errors, and try to compile as much as possible</td>
</tr>
<tr>
<td>PREGEX_COMP_INSENSITIVE</td>
<td>Parse regular expression as case insensitive.</td>
</tr>
<tr>
<td>PREGEX_COMP_STATIC</td>
<td>The regular expression passed should be converted 1:1 as it where a string-constant. Any regex-specific symbols will be ignored and taken as they where escaped.</td>
</tr>
<tr>
<td>PREGEX_RUN_WCHAR</td>
<td>Run regular expression with wchar_t as input.</td>
</tr>
<tr>
<td>PREGEX_RUN_NOANCHORS</td>
<td>Ignore anchors while processing the regex.</td>
</tr>
<tr>
<td>PREGEX_RUN_NOREF</td>
<td>Don't create references.</td>
</tr>
<tr>
<td>PREGEX_RUN_NONGREEDY</td>
<td>Force run regular expression nongreedy.</td>
</tr>
<tr>
<td>PREGEX_RUN_DEBUG</td>
<td>Debug mode; output some debug to stderr.</td>
</tr>
</table>

<p>
<a href="#fn_pregex_free">pregex_free()</a> destructs and releases a <a href="#pregex">pregex</a> object after its use.
</p>

<pre><code class="language-c">
pregex* r;

r = pregex_create( "[_A-Za-z]+", 0 );

/* do something with r */

pregex_free( r );
</code></pre>

<h3 id="toc47">Matching</h3>

<p>
To immediatelly test if a <a href="#pregex">pregex</a>-object matches on a string, the function <a href="#fn_pregex_match">pregex_match()</a> shall be invoked.
</p>

<pre><code class="language-c">
pregex* r;
char* s = "a1337b";
char* e;

r = pregex_create( "[0-9]+", 0 );
pregex_match( r, s, &amp;e ); /* returns FALSE */
pregex_match( r, s + 1, &amp;e ); /* returns TRUE, e receives s+5. */
</code></pre>

<p>
<a href="#fn_pregex_match">pregex_match()</a> only tests for a string that immediatelly matches the pattern. To find a matching pattern within a string, the function <a href="#fn_pregex_find">pregex_find()</a> shall be invoked, which is called with the same parameters, but returns the position of the match instead of a bool state.
</p>

<pre><code class="language-c">
pregex_find( r, s, &amp;e ); /* returns s + 1, e receives s+5. */
</code></pre>

<p>
To find all matching patterns, <a href="#fn_pregex_find">pregex_find()</a> must be called in a loop.
</p>

<pre><code class="language-c">
while( ( s = pregex_find( r, s, &amp;e ) ) )
{
	printf( "&gt;%.*s&lt;\n", e - s, s );
	s = e;
}
</code></pre>

<p>
The function <a href="#fn_pregex_findall">pregex_findall()</a> can do this with one call, and fills an <a href="#parray">parray</a> object with <a href="#prange">prange</a> structures.
</p>

<pre><code class="language-c">
parray* a;
prange* rg;

pregex_findall( r, s, &amp;a );

while( ( rg = (prange*)parray_shift( a ) ) )
	printf( "&gt;%.*s&lt;\n", rg-&gt;end - rg-&gt;start, rg-&gt;start );

parray_free( a );
</code></pre>

<h3 id="toc48">Splitting</h3>

<p>
Splitting a string by a regular expression can be done with <a href="#fn_pregex_split">pregex_split()</a>. This function takes several parameters, and is designed to be called in a loop.
</p>

<pre><code class="language-c">
pregex* r;
char* s = "5 and 6 are the cross sums of 23 and 42.";
char* e;
char* n;

r = pregex_create( "[0-9]+", 0 );

while( s )
{
	if( ( s = pregex_split( r, s, &amp;e, &amp;n ) ) )
			printf( "&gt;%.*s&lt;\n", e - s, s );

	s = n;
}
</code></pre>

<p>
There is also an one call shortcut <a href="#fn_pregex_splitall">pregex_splitall()</a>, filling an array:
</p>

<pre><code class="language-c">
parray* a;
prange* rg;

pregex_splitall( r, s, &amp;a );

while( ( rg = (prange*)parray_shift( a ) ) )
	printf( "&gt;%.*s&lt;\n", rg-&gt;end - rg-&gt;start, rg-&gt;start );

parray_free( a );
</code></pre>

<h3 id="toc49">Replacing</h3>

<p>
The function <a href="#fn_pregex_replace">pregex_replace()</a> allows for replacing parts of strings by regular expressions.
</p>

<pre><code class="language-c">
char* ns;

ns = pregex_replace( r, s, "int" );
</code></pre>

<p>
The result of this function is always an dynamically allocated string that contains the replaces version of the input string, even if there hadn't been any matches. The above example will return "int and int are the cross sums of int and int." when executed on the string of previous chapter. The returned string must always be released with <a href="#fn_pfree">pfree()</a> after its use.
</p>
<p>
The replacement may also allow backreference-placeholders defined as <code>$&lt;backreference&gt;</code>, to take parts of the matched regular expression into the replaces string. A back-reference is created for every opening that exists in the regular expression, and begins counting at 1.
</p>
<p>
This modified version
</p>

<pre><code class="language-c">
r = pregex_create( "([0-9]+)", 0 );
ns = pregex_replace( r, s, "int[$1]" );
</code></pre>

<p>
will return "int[5] and int[6] are the cross sums of int[23] and int[42]." when executed on the example string.
</p>
<p>
To disable the backreference replacement features, the regular expression flag PREGEX_RUN_NOREF must be switched.
</p>

<h3 id="toc50">Quick-access functions</h3>

<p>
Based on the <a href="#pregex">pregex</a>-object, libphorward provides the shortcut functons
</p>

<ul>
<li><a href="#fn_pregex_qmatch">pregex_qmatch()</a> - match strings by pattern,
</li>
<li><a href="#fn_pregex_qsplit">pregex_qsplit()</a> - split strings by pattern,
</li>
<li><a href="#fn_pregex_qreplace">pregex_qreplace()</a> - replace strings by pattern
</li>
</ul>

<p>
for immediate use, without creating and destroying a <a href="#pregex">pregex</a>-object. Because this is done within the function calls, multiple calls of these functions result in huger runtime latencies and produce more overhead.
</p>

<h2 id="plex">Lexical analysis using regular expressions (plex)</h2>

<p>
The second part of libphorwards regular expression tools is the <a href="#plex">plex</a>-object, which encapsulates all required features for creating lexical analyzers (in terms of compiler-writers also called "scanners" or "lexers") into one handy object.
</p>
<p>
A <a href="#plex">plex</a>-object can be seen as a container, which merges multiple regular expressions together into one state machine to recognize tokens. A token is then identified by an unique number that is associated with the matching regular expression.
</p>

<ul>
<li><a href="#fn_plex_create">plex_create()</a> - creates a new <a href="#plex">plex</a>-object,
</li>
<li><a href="#fn_plex_define">plex_define()</a> - adds a new token matcher,
</li>
<li><a href="#fn_plex_lex">plex_lex()</a> - immediatelly tests for a direct match on a string,
</li>
<li><a href="#fn_plex_next">plex_next()</a> - finds the next match within a string, where unrecognized characters are ignored,
</li>
<li><a href="#fn_plex_tokenize">plex_tokenize()</a> - generates an array of all tokens from a string,
</li>
<li><a href="#fn_plex_free">plex_free()</a> - destructs the <a href="#plex">plex</a>-object after its usage,
</li>
<li><a href="#fn_plex_dump_dot">plex_dump_dot()</a> - generates a dot-file Graphviz (<a href="http://www.graphviz.org/">http://www.graphviz.org/</a>) to visualize the constructed lexer.
</li>
</ul>

<p>
To tokenize a C-styled variable assignment, one could write a simple lexical analyzer, like this:
</p>

<pre><code class="language-c">
enum
{
	IDENT = 1, INTEGER, EQUALS, PLUS_OP, SEMICOLON
};

char* nid[] = { "ident", "integer", "equals", "plus_op", "semicolon" };

int m;
char* s = "sum = 5 + 23 + x;";
char* e;
plex* l;

l = plex_create( 0 );

plex_define( l, "[A-Za-z_][A-Za-z0-9_]*", IDENT, 0 );
plex_define( l, "[0-9]+", INTEGER, 0 );
plex_define( l, "=", EQUALS, 0 );
plex_define( l, "+", PLUS_OP, 0 );
plex_define( l, ";", SEMICOLON, 0 );

while( *s &amp;&amp; ( s = plex_next( l, s, &amp;m, &amp;e ) ) )
{
	printf( "%s &gt;%.*s&lt;\n", nid[m - 1], e - s, s );
	s = e;
}

plex_free( l );
</code></pre>

<p>
When running, this yields in the output:
</p>

<pre><code class="language-c">
ident &gt;sum&lt;
equals &gt;=&lt;
integer &gt;5&lt;
plus_op &gt;+&lt;
integer &gt;23&lt;
plus_op &gt;+&lt;
ident &gt;x&lt;
semicolon &gt;;&lt;
</code></pre>

<h2 id="toc52">Tools</h2>

<h3 id="prange">Ranges</h3>

<p>
Some functions of the regex library work with a structure of type <a href="#prange">prange</a>.
</p>

<pre><code class="language-c">
typedef struct prange
{
    unsigned int	id;			/* Match ID */
    char*			start;		/* Begin pointer */
    char*			end;		/* End pointer */
};
</code></pre>

<p>
This structure is used by the functions <a href="#fn_plex_tokenize">plex_tokenize()</a>, <a href="#fn_pregex_findall">pregex_findall()</a>, <a href="#fn_pregex_qmatch">pregex_qmatch()</a>, <a href="#fn_pregex_qsplit">pregex_qsplit()</a> and <a href="#fn_pregex_splitall">pregex_splitall()</a> to generate arrays holding multiple operation ranges on the given function and regex.
In case PREGEX_RUN_WCHAR is set, <i>start</i> and <i>end</i> members must be casted to wchar_t.
</p>

<h3 id="pregex_ptn">Regular Expression Patterns</h3>

<p>
Objects of the kind <a href="#pregex_ptn">pregex_ptn</a> can be seen as nodes of the abstract syntax tree representing regular expressions. This representation is used to convert regular expressions into from strings into data structures, to do revisions on them or to convert them back into strings expressed by a regex.
</p>
<p>
They are managed by the functions <a href="#fn_pregex_ptn_create">pregex_ptn_create()</a>, <a href="#fn_pregex_ptn_create_alt">pregex_ptn_create_alt()</a>, <a href="#fn_pregex_ptn_create_char">pregex_ptn_create_char()</a>, <a href="#fn_pregex_ptn_create_kle">pregex_ptn_create_kle()</a>, <a href="#fn_pregex_ptn_create_opt">pregex_ptn_create_opt()</a>, <a href="#fn_pregex_ptn_create_pos">pregex_ptn_create_pos()</a>, <a href="#fn_pregex_ptn_create_refsub">pregex_ptn_create_refsub()</a>, <a href="#fn_pregex_ptn_create_seq">pregex_ptn_create_seq()</a>, <a href="#fn_pregex_ptn_create_string">pregex_ptn_create_string()</a>, <a href="#fn_pregex_ptn_create_sub">pregex_ptn_create_sub()</a>, <a href="#fn_pregex_ptn_dup">pregex_ptn_dup()</a>, <a href="#fn_pregex_ptn_free">pregex_ptn_free()</a>, <a href="#fn_pregex_ptn_parse">pregex_ptn_parse()</a>, <a href="#fn_pregex_ptn_print">pregex_ptn_print()</a>, <a href="#fn_pregex_ptn_to_dfa">pregex_ptn_to_dfa()</a>, <a href="#fn_pregex_ptn_to_dfatab">pregex_ptn_to_dfatab()</a>, <a href="#fn_pregex_ptn_to_nfa">pregex_ptn_to_nfa()</a> and pregex_ptn_to_regex().
</p>

<h1 id="pstr">String helper functions (pstr*, pwcs*)</h1>

<p>
libphorward provides a set of functions for extended, dynamic string memory handling. These functions are named according to their standard C library counterparts with an added prefix ("p"), or introduce entirely new features.
</p>
<p>
String functions overview:
</p>

<ul>
<li><a href="#fn_pstrcasecmp">pstrcasecmp()</a> - case-insensitive string comparison,
</li>
<li><a href="#fn_pstrcatchar">pstrcatchar()</a> - append character to string with dynamic allocation,
</li>
<li><a href="#fn_pstrcatstr">pstrcatstr()</a> - append string to string with dynamic allocation,
</li>
<li><a href="#fn_pstrdup">pstrdup()</a> - duplicate string, also accepts NULL-pointers,
</li>
<li><a href="#fn_pstrget">pstrget()</a> - securely get string from a pointer,
</li>
<li><a href="#fn_pstrlen">pstrlen()</a> - return length of string, also accepts NULL-pointers,
</li>
<li><a href="#fn_pstrltrim">pstrltrim()</a> - remove prefixing whitespace,
</li>
<li><a href="#fn_pstrlwr">pstrlwr()</a> - convert string to lower-case-order,
</li>
<li><a href="#fn_pstrncasecmp">pstrncasecmp()</a> - case-insensitive string comparison over maximum length,
</li>
<li><a href="#fn_pstrncatstr">pstrncatstr()</a> - append string to string with dynamic allocation and maximum length,
</li>
<li><a href="#fn_pstrndup">pstrndup()</a> - duplicate a string with maximum length,
</li>
<li><a href="#fn_pstrput">pstrput()</a> - securely set an allocated string into a pointer,
</li>
<li><a href="#fn_pstrrender">pstrrender()</a> - dynamically render a string with placeholder substitution,
</li>
<li><a href="#fn_pstrreplace">pstrreplace()</a> - dynamically replace substrings within string,
</li>
<li><a href="#fn_pstrrtrim">pstrrtrim()</a> - remove trailing whitespace,
</li>
<li><a href="#fn_pstrsplit">pstrsplit()</a> - dynamic tokenizer,
</li>
<li><a href="#fn_pstrtrim">pstrtrim()</a> - remove prefixing and trailing whitespace,
</li>
<li><a href="#fn_pstrupr">pstrupr()</a> - convert string to lower-case-order.
</li>
</ul>

<p>
Additionally, the following pendants for wide-character strings (wchar_t) exist and are available, when libphorward is compiled with the UNICODE flag enabled.
</p>

<ul>
<li><a href="#fn_pwcscatchar">pwcscatchar()</a> - append character to wide-character string with dynamic allocation,
</li>
<li><a href="#fn_pwcscatstr">pwcscatstr()</a> - append wide-character string to wide-character string with dynamic allocation,
</li>
<li><a href="#fn_pwcsdup">pwcsdup()</a> - duplicate wide-character string, also accepts NULL-pointers,
</li>
<li><a href="#fn_pwcsget">pwcsget()</a> - securely get wide-character string from a pointer,
</li>
<li><a href="#fn_pwcslen">pwcslen()</a> - return length ot wide-character string, also accepts NULL-pointers,
</li>
<li><a href="#fn_pwcsncatstr">pwcsncatstr()</a> - append wide-character string to wide-character string with dynamic allocation and maximum length,
</li>
<li><a href="#fn_pwcsndup">pwcsndup()</a> - duplicate a wide-character string with maximum length,
</li>
<li><a href="#fn_pwcsput">pwcsput()</a> - securely set an allocated wide-character string into a pointer.
</li>
</ul>

<p>
Although the wide-character pendants to the standard extended string functions are not consistent right now, they may be extended in the future, when the existence of such functions is needed, or another, brave programmer is having the fun to implement them.
</p>

<h1 id="toc56">Function reference</h1>

<h2 id="toc57">Macros</h2>

<!-- NEED 11 -->
<div class='function'>

<h3 id="fn_BOOLEAN_STR">BOOLEAN_STR</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
BOOLEAN_STR( b ) - <i>Macro</i>
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Returns the string represenation of the value or expression in <i>b</i>.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_CORE">CORE</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
CORE  - <i>Macro</i>
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Enforces a SIGSEGV by writing to invalid memory.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_FALSE">FALSE</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
FALSE  - <i>Macro</i>
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Value 0 for FALSE.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_LOG">LOG</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
LOG( char* format, ... ) - <i>Macro</i>
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Write any logging output to trace.
</p>
<p>
This function is newer than the previous ones, and allows for a printf-like
format string with variable amount of parameters.
</p>
<p>
<i>format</i> is a <a href="#fn_printf">printf()</a>-like format-string.
<i>...</i> parameters in the way they occur in the format-string.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_MAKE_BOOLEAN">MAKE_BOOLEAN</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
MAKE_BOOLEAN( b ) - <i>Macro</i>
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Turns the value or expression <i>b</i> into a <a href="#pboolean">pboolean</a> value TRUE or FALSE.
</div>
<!-- NEED 12 -->
<div class='function'>
</p>

<h3 id="fn_MISSINGCASE">MISSINGCASE</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
MISSINGCASE  - <i>Macro</i>
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Prints "missing case engaged" into stderr, to indicate switch-case
constructs running into default-branch because any other branch is not engaged.
</div>
<!-- NEED 13 -->
<div class='function'>
</p>

<h3 id="fn_MSG">MSG</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
MSG( char* message ) - <i>Macro</i>
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Write a message to trace.
</p>
<p>
<i>message</i> is your message!
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_OUTOFMEM">OUTOFMEM</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
OUTOFMEM  - <i>Macro</i>
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Prints "ran out of memory" into stderr and exits with status 1.
</div>
<!-- NEED 20 -->
<div class='function'>
</p>

<h3 id="fn_PARMS">PARMS</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
PARMS( char* param_name, char* format, param_type parameter ) - <i>Macro</i>
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Write parameter content to trace.
</p>
<p>
The PARMS-macro is used to write parameter names and values to the program
trace. <a href="#fn_PARMS">PARMS()</a> should - by definition - only be used right behind <a href="#fn_PROC">PROC()</a>.
If the logging of variable values is wanted during a function execution to
trace, the <a href="#fn_VARS">VARS()</a>-macro shall be used.
</p>
<p>
<i>param_name</i> is the name of the parameter
<i>format</i> is a printf-styled format placeholder.
<i>parameter</i> is the parameter itself.
</div>
<!-- NEED 22 -->
<div class='function'>
</p>

<h3 id="fn_PROC">PROC</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
PROC( char* func_name ) - <i>Macro</i>
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Write function entry to trace.
</p>
<p>
The PROC-macro introduces a new function level, if compiled with trace.
</p>
<p>
The PROC-macro must be put behind the last local variable declaration and the
first code line, else it won't compile. A PROC-macro must exists within a
function to allow for other trace-macro usages. If <a href="#fn_PROC">PROC()</a> is used within a
function, the macros <a href="#fn_RETURN">RETURN()</a> or VOIDRET, according to the function return
value, must be used. If PROC is used without RETURN, the trace output will
output a wrong call level depth.
</p>
<p>
The parameter <i>func_name</i> is a static string for the function name.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_RETURN">RETURN</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
RETURN( function_type return_value ) - <i>Macro</i>
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Write function return to trace.
 <a href="#fn_RETURN">RETURN()</a> can only be used if <a href="#fn_PROC">PROC()</a> is used at the beginning of the function.
For void-functions, use the macro VOIDRET.
</p>
<p>
<i>return_value</i> is return-value of the function.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_TODO">TODO</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
TODO  - <i>Macro</i>
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Prints "TODO alert!" into stderr, to inform about incomplete branches.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_TRUE">TRUE</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
TRUE  - <i>Macro</i>
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Value 1 for TRUE.
</div>
<!-- NEED 18 -->
<div class='function'>
</p>

<h3 id="fn_VARS">VARS</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
VARS( char* var_name, char* format, var_type variable ) - <i>Macro</i>
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Write variable content to trace.
</p>
<p>
The VARS-macro is used to write variable names and values to the program trace.
For parameters taken to functions, the <a href="#fn_PARMS">PARMS()</a>-macro shall be used.
</p>
<p>
<i>var_name</i> is the name of the variable
<i>format</i> is a printf-styled format placeholder.
<i>variable</i> is the parameter itself.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_VOIDRET">VOIDRET</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
VOIDRET - <i>Macro</i>
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Write void function return to trace.
</p>
<p>
VOIDRET can only be used if <a href="#fn_PROC">PROC()</a> is used at the beginning of the function.
For typed functions, use the macro <a href="#fn_RETURN">RETURN()</a>.
</div>
<!-- NEED 12 -->
<div class='function'>
</p>

<h3 id="fn_WRONGPARAM">WRONGPARAM</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
WRONGPARAM  - <i>Macro</i>
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Prints "function called with wrong or incomplete parameters" into stderr,
to indicate invalid function calls.
</div>
<!-- NEED 32 -->
<div class='function'>
</p>

<h3 id="fn_parray_for">parray_for</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
parray_for( <a href="#parray">parray</a>* array, usertype* ptr ) - <i>Macro</i>
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Macro that expands into a for-loop iterating a <a href="#parray">parray</a>-object <i>array</i> using
and pointer variable <i>ptr</i> as walker.
</p>
<p>
This macro expands into a for-loop in the format
</p>

<pre><code class="language-c">
for( ptr = parray_first( array ); ptr; ptr = parray_next( array, ptr ) )
</code></pre>

<p>
where <i>ptr</i> is a walker variable of the same type size of the array's size
for each element.
</p>
<p>
<b>Example:</b>
</p>

<pre><code class="language-c">
usertype* 	t;
parray		a;

parray_init( &amp;a, sizeof( usertype ), 0 );

parray_for( a, t )
{
	/* Do something with t *}
</code></pre>

</div>
<!-- NEED 31 -->
<div class='function'>

<h3 id="fn_plist_for">plist_for</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plist_for( <a href="#plist">plist</a>* l, <a href="#plistel">plistel</a>* e ) - <i>Macro</i>
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Macro that expands into a for-loop iterating a <a href="#plist">plist</a>-object <i>l</i> using
the element variable <i>e</i> as walker.
</p>
<p>
This macro expands into a for-loop of the format
</p>

<pre><code class="language-c">
for( e = plist_first( l ); e; e = plist_next( e ) )
</code></pre>

<p>
where <i>e</i> is a walker variable for each element.
</p>
<p>
<b>Example:</b>
</p>

<pre><code class="language-c">
plist*		my_list;
plistel*	e;

plist_for( my_list, e )
{
	/* Access current element data part *	ptr = (cast*)plist_access( e );
	...
}
</code></pre>

</div>

<h2 id="toc76">Functions</h2>

<!-- NEED 15 -->
<div class='function'>

<h3 id="fn_parray_concat">parray_concat</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
size_t parray_concat( <a href="#parray">parray</a>* dest, <a href="#parray">parray</a>* src )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Concats the elements of array <i>src</i> to the elements of array <i>dest</i>.
</p>
<p>
The function will not run if both arrays have different element size settings.
</p>
<p>
The function returns the number of elements added to <i>dest</i>.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_parray_count">parray_count</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
size_t parray_count( <a href="#parray">parray</a>* array )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Returns the number of elements in a array.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_parray_create">parray_create</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
parray* parray_create( size_t size, size_t chunk )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Create a new <a href="#parray">parray</a> as an object with an element allocation size <i>size</i>,
a reallocation-chunk-size of <i>chunk</i>.
</p>
<p>
The returned memory must be released with <a href="#fn_parray_free">parray_free()</a>.
</div>
<!-- NEED 16 -->
<div class='function'>
</p>

<h3 id="fn_parray_diff">parray_diff</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int parray_diff( <a href="#parray">parray</a>* left, <a href="#parray">parray</a>* right )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Tests the contents (data parts) of the array <i>left</i> and the array <i>right</i>
for equal elements.
</p>
<p>
The function returns a value &lt; 0 if <i>left</i> is lower <i>right</i>, a value &gt; 0
if <i>left</i> is greater <i>right</i> and a value == 0 if <i>left</i> is equal to
<i>right</i>.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_parray_erase">parray_erase</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void parray_erase( <a href="#parray">parray</a>* array )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Erase a dynamic array.
</p>
<p>
The array must not be reinitialized after destruction, using <a href="#fn_parray_init">parray_init()</a>.
</p>
<p>
<i>array</i> is the pointer to the array to be erased.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_parray_first">parray_first</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* parray_first( <a href="#parray">parray</a>* array )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Access first element of the array.
</p>
<p>
Returns the address of the accessed item, and NULL if nothing is in
the array.
</div>
<!-- NEED 13 -->
<div class='function'>
</p>

<h3 id="fn_parray_free">parray_free</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
parray* parray_free( <a href="#parray">parray</a>* array )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Releases all the memory <i>array</i> uses and destroys the array object.
</p>
<p>
The function always returns (<a href="#parray">parray</a>*)NULL.
</div>
<!-- NEED 20 -->
<div class='function'>
</p>

<h3 id="fn_parray_get">parray_get</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* parray_get( <a href="#parray">parray</a>* array, size_t offset )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Access an element from the array by its offset position from the left.
</p>
<p>
<i>array</i> is the pointer to array where to access the element from.
<i>offset</i> is the offset of the element to be accessed from the array's
base address.
</p>
<p>
Returns the address of the accessed item, and NULL if the item could not
be accessed (e.g. if the array is empty or offset is beyond the top of array).
</p>
<p>
Use <a href="#fn_parray_rget">parray_rget()</a> for access items from the end.
</div>
<!-- NEED 22 -->
<div class='function'>
</p>

<h3 id="fn_parray_init">parray_init</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void parray_init( <a href="#parray">parray</a>* array, size_t size, size_t chunk )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Performs an array initialization.
</p>
<p>
<i>array</i> is the pointer to the array to be initialized.
</p>
<p>
<i>size</i> defines the size of one array element, in bytes.
This should be evaluated using the <a href="#fn_sizeof">sizeof()</a>-macro.
</p>
<p>
<i>chunk</i> defines the chunk size, when an array-(re)allocation will be
performed. If, e.g. this is set to 128, then, if the 128th item is created
within the array, a realloction is done. Once allocated memory remains until
the array is freed again. The array's elements may change their heap address
when a chunk reallocation is required.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_parray_insert">parray_insert</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* parray_insert( <a href="#parray">parray</a>* array, size_t offset, void* item )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Insert item <i>item</i> at <i>offset</i> into array <i>array</i>.
Items right to <i>offset</i> will move up.
</p>
<p>
Gap space between the offset is filled with zero elements;
Handle with care!
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_parray_iter">parray_iter</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void parray_iter( <a href="#parray">parray</a>* array, parrayfn callback )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Iterates over <i>array</i>.
</p>
<p>
Iterates over all items of <i>array</i> and calls the function <i>callback</i> on
every item.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_parray_last">parray_last</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* parray_last( <a href="#parray">parray</a>* array )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Access last element of the array.
</p>
<p>
Returns the address of the accessed item, and NULL if nothing is in
the array.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_parray_malloc">parray_malloc</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* parray_malloc( <a href="#parray">parray</a>* array )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Pushes and "allocates" an empty element on the array.
</p>
<p>
This function is just a shortcut to <code>`parray_push( array, NULL )`</code>,
and the memory of the pushed element is initialized to zero.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_parray_next">parray_next</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* parray_next( <a href="#parray">parray</a>* array, void* ptr )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Access next element from <i>ptr</i> in <i>array</i>.
</p>
<p>
Returns the address of the next element, and NULL if the access gets
out of bounds.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_parray_offset">parray_offset</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
size_t parray_offset( <a href="#parray">parray</a>* array, void* ptr )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Return offset of element <i>ptr</i> in array <i>array</i>.
</p>
<p>
Returns the offset of <i>ptr</i> in <i>array</i>.
The function returns the size of the array (which is an invalid offset)
if <i>ptr</i> is not part of <i>array</i>.
</p>
<p>
To check if a pointer belongs to an array, call <a href="#fn_parray_partof">parray_partof()</a>.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_parray_partof">parray_partof</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* parray_partof( <a href="#parray">parray</a>* array, void* ptr )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Returns TRUE, if <i>ptr</i> is an element of array <i>array</i>.
</div>
<!-- NEED 20 -->
<div class='function'>
</p>

<h3 id="fn_parray_pop">parray_pop</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* parray_pop( <a href="#parray">parray</a>* array )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Removes an element from the end of an array.
</p>
<p>
The function returns the pointer of the popped item. Because dynamic arrays only
grow and no memory is freed, the returned data pointer is still valid, and will
only be overridden with the next push operation.
</p>
<p>
<i>array</i> is the pointer to array where to pop an item off.
</p>
<p>
The function returns the address of the popped item, and NULL if the
item could not be popped (e.g. array is empty).
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_parray_prev">parray_prev</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* parray_prev( <a href="#parray">parray</a>* array, void* ptr )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Access previous element from <i>ptr</i> in <i>array</i>.
</p>
<p>
Returns the address of the previous element, and NULL if the access gets
out of bounds.
</div>
<!-- NEED 23 -->
<div class='function'>
</p>

<h3 id="fn_parray_push">parray_push</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* parray_push( <a href="#parray">parray</a>* array, void* item )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Appends an element to the end of the array.
</p>
<p>
The element's memory is copied during the push. The item must be of the same
memory size as used at array initialization.
</p>
<p>
<i>array</i> is the pointer to array where to push an item on.
</p>
<p>
<i>item</i> is the pointer to the memory of the item that should be pushed onto the
array. The caller should cast his type into void, or wrap the push-operation
with a macro. It can be left NULL, so no memory will be copied.
</p>
<p>
The function returns the address of the newly pushed item, and NULL if
the item could not be pushed.
</div>
<!-- NEED 20 -->
<div class='function'>
</p>

<h3 id="fn_parray_put">parray_put</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* parray_put( <a href="#parray">parray</a>* array, size_t offset, void* item )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Put an element <i>item</i> at position <i>offset</i> of array <i>array</i>.
</p>
<p>
<i>array</i> is the pointer to array where to put the element to.
<i>offset</i> is the offset of the element to be set.
<i>item</i> is a pointer to the memory that will be copied into the
position at <i>offset</i>. If this is NULL, the position at <i>offset</i> will be
set to zero.
</p>
<p>
Returns the address of the item in the array, or NULL if the desired offset
is out of the array bounds.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_parray_remove">parray_remove</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* parray_remove( <a href="#parray">parray</a>* array, size_t offset, void** item )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Remove item on <i>offset</i> from array <i>array</i>.
</p>
<p>
The removed item will be copied into <i>item</i>, if <i>item</i> is not NULL.
The function returns the memory of the removed item (it will contain the
moved up data part or invalid memory, if on the end).
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_parray_reserve">parray_reserve</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* parray_reserve( <a href="#parray">parray</a>* array, size_t n )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Reserves memory for <i>n</i> items in <i>array</i>.
</p>
<p>
This function is only used to assume that no memory reallocation is done when
the next <i>n</i> items are inserted/malloced.
</div>
<!-- NEED 21 -->
<div class='function'>
</p>

<h3 id="fn_parray_rget">parray_rget</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* parray_rget( <a href="#parray">parray</a>* array, size_t offset )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Access an element from the array by its offset position from the right.
</p>
<p>
<i>array</i> is the pointer to array where to access the element from.
<i>offset</i> is the offset of the element to be accessed from the array's
base address.
</p>
<p>
Returns the address of the accessed item, and NULL if the item could not
be accessed (e.g. if the array is empty or offset is beyond the bottom of
the array).
</p>
<p>
Use <a href="#fn_parray_get">parray_get()</a> to access items from the begin.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_parray_riter">parray_riter</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void parray_riter( <a href="#parray">parray</a>* array, parrayfn callback )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Iterates backwards over <i>array</i>.
</p>
<p>
Backwardly iterates over all items of <i>array</i> and calls the function
<i>callback</i> on every item.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_parray_rmalloc">parray_rmalloc</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* parray_rmalloc( <a href="#parray">parray</a>* array )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Unshifts and "allocates" an empty element on the array.
</p>
<p>
This function is just a shortcut to <code>`parray_unshift( array, NULL )`</code>,
and the memory of the unshifted element is initialized to zero.
</div>
<!-- NEED 21 -->
<div class='function'>
</p>

<h3 id="fn_parray_rput">parray_rput</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* parray_rput( <a href="#parray">parray</a>* array, size_t offset, void* item )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Put an element <i>item</i> at position <i>offset</i> from the right of
array <i>array</i>.
</p>
<p>
<i>array</i> is the pointer to array where to put the element to.
<i>offset</i> is the offset of the element to be set.
<i>item</i> is a pointer to the memory that will be copied into the
position at <i>offset</i>. If this is NULL, the position at <i>offset</i> will be
set to zero.
</p>
<p>
Returns the address of the item in the array, or NULL if the desired offset
is out of the array bounds.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_parray_set_comparefn">parray_set_comparefn</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void parray_set_comparefn( <a href="#parray">parray</a>* array, int (*comparefn)( <a href="#parray">parray</a>*, void*, void* ) )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Sets array compare function.
</p>
<p>
If no compare function is set or NULL is provided, <a href="#fn_memcmp">memcmp()</a> will be used
as default fallback.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_parray_set_sortfn">parray_set_sortfn</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void parray_set_sortfn( <a href="#parray">parray</a>* array, int (*sortfn)( <a href="#parray">parray</a>*, void*, void* ) )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Sets array sort function.
</p>
<p>
If no sort function is given, the compare function set by <a href="#fn_parray_set_comparefn">parray_set_comparefn()</a>
is used. If even unset, <a href="#fn_memcmp">memcmp()</a> will be used.
</div>
<!-- NEED 21 -->
<div class='function'>
</p>

<h3 id="fn_parray_shift">parray_shift</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* parray_shift( <a href="#parray">parray</a>* array )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Removes an element from the begin of an array.
</p>
<p>
The function returns the pointer of the shifted item.
Because dynamic arrays only grow and no memory is freed, the returned data
pointer is still valid, and will only be overridden with the next unshift
operation.
</p>
<p>
<i>array</i> is the pointer to array where to pop an item off.
</p>
<p>
The function returns the address of the shifted item, and NULL if the
item could not be popped (e.g. array is empty).
</div>
<!-- NEED 18 -->
<div class='function'>
</p>

<h3 id="fn_parray_sort">parray_sort</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void parray_sort( <a href="#parray">parray</a>* array )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Sorts <i>list</i> according to the sort-function that was set for the list.
</p>
<p>
To sort only parts of a list, use <a href="#fn_plist_subsort">plist_subsort()</a>.
</p>
<p>
The sort-function can be modified by using <a href="#fn_plist_set_sortfn">plist_set_sortfn()</a>.
</p>
<p>
The default sort function sorts the list by content using the <a href="#fn_memcmp">memcmp()</a>
standard function.
</div>
<!-- NEED 19 -->
<div class='function'>
</p>

<h3 id="fn_parray_subsort">parray_subsort</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void parray_subsort( <a href="#parray">parray</a>* array, size_t from, size_t to )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Sorts <i>array</i> between the elements <i>from</i> and <i>to</i> according to the
sort-function that was set for the array.
</p>
<p>
To sort the entire array, use <a href="#fn_parray_sort">parray_sort()</a>.
</p>
<p>
The sort-function can be modified by using <a href="#fn_parray_set_sortfn">parray_set_sortfn()</a>.
</p>
<p>
The default sort function sorts the list by content using the <a href="#fn_memcmp">memcmp()</a>
standard function.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_parray_swap">parray_swap</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* parray_swap( <a href="#parray">parray</a>* array, size_t pos1, size_t pos2 )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Swap two elements of an array.
</div>
<!-- NEED 18 -->
<div class='function'>
</p>

<h3 id="fn_parray_union">parray_union</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
size_t parray_union( <a href="#parray">parray</a>* all, <a href="#parray">parray</a>* from )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Unions elements from array <i>from</i> into array <i>all</i>.
</p>
<p>
An element is only added to <i>all</i>, if there exists no equal element with the
same size and content.
</p>
<p>
The function will not run if both arrays have different element size settings.
</p>
<p>
The function returns the number of elements added to <i>from</i>.
</div>
<!-- NEED 23 -->
<div class='function'>
</p>

<h3 id="fn_parray_unshift">parray_unshift</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* parray_unshift( <a href="#parray">parray</a>* array, void* item )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Appends an element to the begin of the array.
</p>
<p>
The elements memory is copied during the unshift. The item must be of the same
memory size as used at array initialization.
</p>
<p>
<i>array</i> is the pointer to array where to push an item to the beginning.
</p>
<p>
<i>item</i> is the pointer to the memory of the item that should be pushed onto the
array. The caller should cast his type into void, or wrap the push-operation
with a macro. It can be left NULL, so no memory will be copied.
</p>
<p>
The function returns the address of the newly unshifted item, and NULL
if the item could not be unshifted.
</div>
<!-- NEED 19 -->
<div class='function'>
</p>

<h3 id="fn_pasprintf">pasprintf</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pasprintf( char* fmt, ... )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Implementation and replacement for asprintf. <a href="#fn_pasprintf">pasprintf()</a> takes only the
format-string and various arguments. It outputs an allocated string to be freed
later on.
</p>
<p>
<i>fmt</i> is the format string.
<i>...</i> are the parameters according to the placeholders set in <i>fmt</i>.
</p>
<p>
Returns a char* Returns the allocated string which contains the format string
with inserted values.
</div>
<!-- NEED 21 -->
<div class='function'>
</p>

<h3 id="fn_pawcsprintf">pawcsprintf</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
wchar_t* pawcsprintf( wchar_t* fmt, ... )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
An implementation of <a href="#fn_pasprintf">pasprintf()</a> for wide-character wchar_t. <a href="#fn_pasprintf">pasprintf()</a>
takes only the format-string and various arguments. It outputs an allocated
string to be released with <a href="#fn_pfree">pfree()</a> later on.
</p>
<p>
<i>fmt</i> is the format string.
<i>...</i> are the parameters according to the placeholders set in <i>fmt</i>.
</p>
<p>
Returns a wchar_t* Returns the allocated string which cointains the format
string with inserted values.
</p>
<p>
<i>This function is only available when compiled with -DUNICODE.</i>
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_pbasename">pbasename</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pbasename( char* path )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Returns the basename of a file.
</p>
<p>
<i>path</i> is the file path pointer.
</p>
<p>
Returns a pointer to the basename, which is a part of <i>path</i>.
</div>
<!-- NEED 16 -->
<div class='function'>
</p>

<h3 id="fn_pccl_add">pccl_add</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean pccl_add( <a href="#pccl">pccl</a>* ccl, wchar_t ch )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Integrates a single character into a character-class.
</p>
<p>
<i>ccl</i> is the pointer to the character-class to be affected.
<i>ch</i> is the character to be integrated.
</p>
<p>
The function is a shortcut for <a href="#fn_pccl_addrange">pccl_addrange()</a>.
</div>
<!-- NEED 19 -->
<div class='function'>
</p>

<h3 id="fn_pccl_addrange">pccl_addrange</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean pccl_addrange( <a href="#pccl">pccl</a>* ccl, wchar_t begin, wchar_t end )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Integrates a character range into a character-class.
</p>
<p>
<i>ccl</i> is the pointer to the character-class to be affected. If <i>ccl</i> is
provided as (<a href="#pccl">pccl</a>*)NULL, it will be created by the function.
</p>
<p>
<i>begin</i> is the begin of character range to be integrated.
<i>end</i> is the end of character range to be integrated.
</p>
<p>
If <i>begin</i> is greater than <i>end</i>, the values will be swapped.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_pccl_compare">pccl_compare</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int pccl_compare( <a href="#pccl">pccl</a>* left, <a href="#pccl">pccl</a>* right )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Checks for differences in two character-classes.
</p>
<p>
<i>left</i> is the pointer to the first character-class.
<i>right</i> is the pointer to the second character-class.
</p>
<p>
Returns a value &lt; 0 if <i>left</i> is lower than <i>right</i>, 0 if <i>left</i> is
equal to <i>right</i> or a value &gt; 0 if <i>left</i> is greater than <i>right</i>.
</div>
<!-- NEED 12 -->
<div class='function'>
</p>

<h3 id="fn_pccl_compat">pccl_compat</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean pccl_compat( <a href="#pccl">pccl</a>* l, <a href="#pccl">pccl</a>* r )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Checks if the character-classes <i>l</i> and <i>r</i> are configured
to be in the same character universe and compatible for operations.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_pccl_count">pccl_count</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
size_t pccl_count( <a href="#pccl">pccl</a>* ccl )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Returns the number of characters within a character-class.
</p>
<p>
<i>ccl</i> is a pointer to the character-class to be processed.
</p>
<p>
Returns the total number of characters the class is holding.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_pccl_create">pccl_create</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pccl* pccl_create( int min, int max, char* ccldef )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Constructor function to create a new character-class.
</p>
<p>
<i>min</i> and <i>max</i> can either be specified as -1, so the configured default
constants PCCL_MIN and PCCL_MAX will be used. The values can also be inverted.
</p>
<p>
Returns a pointer to the newly created character-class. This pointer should be
released with <a href="#fn_pccl_free">pccl_free()</a> when its existence is no longer required.
</div>
<!-- NEED 16 -->
<div class='function'>
</p>

<h3 id="fn_pccl_del">pccl_del</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean pccl_del( <a href="#pccl">pccl</a>* ccl, wchar_t ch )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Removes a character from a character-class.
</p>
<p>
<i>ccl</i> is the pointer to the character-class to be affected.
<i>ch</i> is the character to be removed from <i>ccl</i>.
</p>
<p>
The function is a shortcut for <a href="#fn_pccl_delrange">pccl_delrange()</a>.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_pccl_delrange">pccl_delrange</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean pccl_delrange( <a href="#pccl">pccl</a>* ccl, wchar_t begin, wchar_t end )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Removes a character range from a character-class.
</p>
<p>
<i>ccl</i> is the pointer to the character-class to be affected.
<i>begin</i> is the begin of character range to be removed.
<i>end</i> is the end of character range to be removed.
</div>
<!-- NEED 20 -->
<div class='function'>
</p>

<h3 id="fn_pccl_diff">pccl_diff</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pccl* pccl_diff( <a href="#pccl">pccl</a>* ccl, <a href="#pccl">pccl</a>* rem )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Returns the difference quantity of two character-classes.
All elements from <i>rem</i> will be removed from <i>ccl</i>, and put into a
new character-class.
</p>
<p>
<i>ccl</i> is the pointer to the first character-class.
<i>rem</i> is the pointer to the second character-class.
</p>
<p>
Returns a new pointer to a copy of <i>ccl</i>, without the ranges contained in
<i>rem</i>. Returns (<a href="#pccl">pccl</a>*)NULL in case of memory allocation or parameter
error.
</div>
<!-- NEED 16 -->
<div class='function'>
</p>

<h3 id="fn_pccl_dup">pccl_dup</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pccl* pccl_dup( <a href="#pccl">pccl</a>* ccl )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Duplicates a character-class into a new one.
</p>
<p>
<i>ccl</i> is the pointer to the character-class to be duplicated.
</p>
<p>
Returns a pointer to the duplicate of <i>ccl</i>, or (pcrange)NULL
in error case.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_pccl_erase">pccl_erase</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void pccl_erase( <a href="#pccl">pccl</a>* ccl )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Erases a character-class <i>ccl</i>.
</p>
<p>
The function sets a character-class to zero, as it contains no character range
definitions. The object <i>ccl</i> will be still alive. To delete the entire
object, use <a href="#fn_pccl_free">pccl_free()</a>.
</div>
<!-- NEED 13 -->
<div class='function'>
</p>

<h3 id="fn_pccl_free">pccl_free</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pccl* pccl_free( <a href="#pccl">pccl</a>* ccl )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Frees a character-class <i>ccl</i> and all its used memory.
</p>
<p>
The function always returns (<a href="#pccl">pccl</a>*)NULL.
</div>
<!-- NEED 23 -->
<div class='function'>
</p>

<h3 id="fn_pccl_get">pccl_get</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean pccl_get( wchar_t* from, wchar_t* to, <a href="#pccl">pccl</a>* ccl, size_t offset )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Return a character or a character-range by its offset.
</p>
<p>
If the function is called only with pointer <i>from</i> provided, and <i>to</i> as
(wchar_t*)NULL, it writes the character in <i>offset</i>th position of the
character-class into from.
</p>
<p>
If the function is called both with pointer <i>from</i> and <i>to</i> provided,
it writes the <i>begin</i> and <i>end</i> character of the character-range in the
<i>offset</i>th position of the character-class into <i>from</i> and <i>to</i>.
</p>
<p>
If no character or range with the given offset was found, the function
returns FALSE, meaning that the end of the characters is reached.
On success, the function will always return TRUE.
</div>
<!-- NEED 19 -->
<div class='function'>
</p>

<h3 id="fn_pccl_instest">pccl_instest</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean pccl_instest( <a href="#pccl">pccl</a>* ccl, wchar_t ch )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Tests for a character in case-insensitive-mode if it matches
a character-class.
</p>
<p>
<i>ccl</i> is the pointer to character-class to be tested.
<i>ch</i> is the character to be tested.
</p>
<p>
The function is a shortcut for <a href="#fn_pccl_testrange">pccl_testrange()</a>.
</p>
<p>
It returns TRUE, if the character matches the class, and FALSE if not.
</div>
<!-- NEED 19 -->
<div class='function'>
</p>

<h3 id="fn_pccl_intersect">pccl_intersect</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pccl* pccl_intersect( <a href="#pccl">pccl</a>* ccl, <a href="#pccl">pccl</a>* within )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Returns a new character-class with all characters that exist in both
provided character-classes.
</p>
<p>
<i>ccl</i> is the pointer to the first character-class.
<i>within</i> is the pointer to the second character-class.
</p>
<p>
Returns a new character-class containing the intersection of <i>ccl</i>
and <i>within</i>. If there is no intersection between both character-classes,
the function returns (<a href="#pccl">pccl</a>*)NULL.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_pccl_negate">pccl_negate</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pccl* pccl_negate( <a href="#pccl">pccl</a>* ccl )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Negates all ranges in a character-class.
</p>
<p>
<i>ccl</i> is the pointer to the character-class to be negated.
</p>
<p>
Returns a pointer to <i>ccl</i>.
</div>
<!-- NEED 29 -->
<div class='function'>
</p>

<h3 id="fn_pccl_parse">pccl_parse</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pccl* pccl_parse( <a href="#pccl">pccl</a>* ccl, char* ccldef, <a href="#pboolean">pboolean</a> extend )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Parses the character-class definition provided in <i>ccldef</i> and assigns
this definition to the character-class <i>ccl</i>.
</p>
<p>
If <i>ccl</i> is NULL, a new character-class with the PCCL_MIN/PCCL_MAX
configuration will be created.
</p>
<p>
<i>ccldef</i> may contain UTF-8 formatted input. Escape-sequences will be
interpreted to their correct character representations.
</p>
<p>
A typical character-class definition simply exists of single characters and
range definitions. For example, "$A-Z#0-9" defines a character-class that
consists of the characters "$#0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ".
</p>
<p>
The parameter <i>extend</i> specifies, if the provided character-class overwrites
(<i>extend</i> = FALSE) or extends (<i>extend</i> = TRUE) the provided
character-class. This means that definitions that already exist in the
character-class, should be erased first or not.
</p>
<p>
The function returns TRUE on success, and FALSE on an error.
</div>
<!-- NEED 20 -->
<div class='function'>
</p>

<h3 id="fn_pccl_parsechar">pccl_parsechar</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
size_t pccl_parsechar( wchar_t* retc, char *str, <a href="#pboolean">pboolean</a> escapeseq )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Reads a character from a string. The character may consist of one single
character or it may be made up of an escape sequence or UTF-8 character.
The function returns the number of bytes read.
</p>
<p>
<i>retc</i> is the return pointer for the character code of the escaped string.
<i>str</i> is the begin pointer of the string at which character parsing begins.
If <i>escapeseq</i> is TRUE, the function regards escape sequences, else it ignores
them.
</p>
<p>
Returns the number of bytes that had been read for the character.
</div>
<!-- NEED 19 -->
<div class='function'>
</p>

<h3 id="fn_pccl_parseshorthand">pccl_parseshorthand</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean pccl_parseshorthand( <a href="#pccl">pccl</a>* ccl, char** str )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Tries to parse a shorthand sequence from a string. This matches the
shorthands \w, \W, \d, \D, \s and \S. If it matches, all characters are
added to <i>ccl</i>.
</p>
<p>
The function returns TRUE in case a shorthand has been parsed. If so,
the pointer <i>str</i> is moved the characters consumed.
</p>
<p>
If no shorthand sequence could be found, it returns FALSE, leaving <i>ccl</i>
untouched.
</div>
<!-- NEED 22 -->
<div class='function'>
</p>

<h3 id="fn_pccl_print">pccl_print</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void pccl_print( FILE* stream, <a href="#pccl">pccl</a>* ccl, int break_after )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Print character-class to output stream.
This function is provided for debug-purposes only.
</p>
<p>
<i>stream</i> is the output stream to dump the character-class to; This can be
left (FILE*)NULL, so <i>stderr</i> will be used.
<i>ccl</i> is the pointer to character-class
</p>
<p>
<i>break_after</i> defines:
</p>

<ul>
<li>if &lt; 0 print with pointer info
</li>
<li>if 0 print all into one line
</li>
<li>if &gt; 0 print linewise
</li>
</ul>

</div>
<!-- NEED 17 -->
<div class='function'>

<h3 id="fn_pccl_size">pccl_size</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
size_t pccl_size( <a href="#pccl">pccl</a>* ccl )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Returns the number of range pairs within a character-class.
</p>
<p>
<i>ccl</i> is a pointer to the character-class to be processed.
</p>
<p>
To retrieve the number of characters in a character-class, use <a href="#fn_pccl_count">pccl_count()</a> instead.
</p>
<p>
Returns the number of pairs the charclass holds.
</div>
<!-- NEED 18 -->
<div class='function'>
</p>

<h3 id="fn_pccl_test">pccl_test</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean pccl_test( <a href="#pccl">pccl</a>* ccl, wchar_t ch )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Tests a character-class if it contains a character.
</p>
<p>
<i>ccl</i> is the pointer to character-class to be tested.
<i>ch</i> is the character to be tested.
</p>
<p>
The function is a shortcut for <a href="#fn_pccl_testrange">pccl_testrange()</a>.
</p>
<p>
It returns TRUE, if the character matches the class, and FALSE if not.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_pccl_testrange">pccl_testrange</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean pccl_testrange( <a href="#pccl">pccl</a>* ccl, wchar_t begin, wchar_t end )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Tests a character-class to match a character range.
</p>
<p>
<i>ccl</i> is a pointer to the character-class to be tested.
<i>begin</i> is the begin of character-range to be tested.
<i>end</i> is the end of character-range to be tested.
</p>
<p>
Returns TRUE if the entire character range matches the class, and FALSE if not.
</div>
<!-- NEED 22 -->
<div class='function'>
</p>

<h3 id="fn_pccl_to_str">pccl_to_str</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pccl_to_str( <a href="#pccl">pccl</a>* ccl, <a href="#pboolean">pboolean</a> escape )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Converts a character-class back to a string representation of the
character-class definition, which in turn can be converted back into a
character-class using <a href="#fn_pccl_create">pccl_create()</a>.
</p>
<p>
<i>ccl</i> is the pointer to character-class to be converted.
<i>escape</i>, if TRUE, escapes "unprintable" characters in their hexadecimal
representation. If FALSE, it prints all characters, except the zero, which will
be returned as "\0"
</p>
<p>
Returns a pointer to the generated string that represents the charclass.
The returned pointer belongs to the <i>ccl</i> and is managed by the
character-class handling functions, so it should not be freed manually.
</div>
<!-- NEED 19 -->
<div class='function'>
</p>

<h3 id="fn_pccl_union">pccl_union</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pccl* pccl_union( <a href="#pccl">pccl</a>* ccl, <a href="#pccl">pccl</a>* add )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Creates the union of two character-classes and returns the newly created,
normalized character-class.
</p>
<p>
<i>ccl</i> is the pointer to the character-class that will be extended to all
ranges contained in <i>add</i>. <i>add</i> is the character-class that will be joined
with <i>ccl</i>.
</p>
<p>
The function creates and returns a new character-class that is the union
of <i>ccl</i> and <i>add</i>.
</div>
<!-- NEED 19 -->
<div class='function'>
</p>

<h3 id="fn_pdbl_to_str">pdbl_to_str</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pdbl_to_str( double d )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Converts a double-value into an allocated string buffer.
</p>
<p>
<i>d</i> is the double value to become converted. Zero-digits behind the decimal
dot will be removed after conversion, so 1.65000 will become "1.65" in its
string representation.
</p>
<p>
Returns a pointer to the newly allocated string, which contains the
string-representation of the double value. This pointer must be released
by the caller.
</div>
<!-- NEED 21 -->
<div class='function'>
</p>

<h3 id="fn_pdbl_to_wcs">pdbl_to_wcs</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
wchar_t* pdbl_to_wcs( double d )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Converts a double-value into an allocated wide-character string buffer.
</p>
<p>
<i>d</i> is the double value to become converted. Zero-digits behind the decimal
dot will be removed after conversion, so 1.65000 will become L"1.65" in its
wide-character string representation.
</p>
<p>
Returns a pointer to the newly allocated wide-character string, which contains
the string-representation of the double value. This pointer must be released
by the caller.
</p>
<p>
<i>This function is only available when compiled with -DUNICODE.</i>
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_pfileexists">pfileexists</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean pfileexists( char* filename )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Checks for file existence.
</p>
<p>
<i>filename</i> is the path to a file that will be checked.
</p>
<p>
Returns TRUE on success, FALSE if not.
</div>
<!-- NEED 16 -->
<div class='function'>
</p>

<h3 id="fn_pfiletostr">pfiletostr</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean pfiletostr( char** cont, char* filename )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Maps the content of an entire file into memory.
</p>
<p>
<i>cont</i> is the file content return pointer.
<i>filename</i> is the path to file to be mapped
</p>
<p>
The function returns TRUE on success.
</div>
<!-- NEED 22 -->
<div class='function'>
</p>

<h3 id="fn_pfree">pfree</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* pfree( void* ptr )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Free allocated memory.
</p>
<p>
The function is a wrapper for the system-function <a href="#fn_free">free()</a>, but accepts
NULL-pointers and returns a (void*)NULL pointer for direct pointer memory reset.
</p>
<p>
It could be used this way to immediately reset a pointer to NULL:
</p>

<pre><code class="language-c">
ptr = pfree( ptr );
</code></pre>

<p>
<i>ptr</i> is the pointer to be freed.
</p>
<p>
Always returns (void*)NULL.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_pgetline">pgetline</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
size_t pgetline( char** lineptr, size_t* n, FILE* stream )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Reads an entire line from <i>stream</i>, storing the address of the buffer
containing the text into <i>lineptr</i>. The buffer is zero-terminated and
includes the newline character, if one was found.
</p>
<p>
This function serves as a platform-independent implementation for POSIX <a href="#fn_getline">getline()</a>, which is wrapped in case of POSIX.
</div>
<!-- NEED 74 -->
<div class='function'>
</p>

<h3 id="fn_pgetopt">pgetopt</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int pgetopt( char* opt, char** param, int* next, int argc, char** argv, char* optstr, char* loptstr, int idx )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Command-line option interpreter.
</p>
<p>
This function works similar to the <a href="#fn_getopt">getopt()</a> functions of the GNU Standard
Library, but uses a different style of parameter submit.
</p>
<p>
It supports both short- and long- option-style parameters.
</p>

<ul>
<li><i>opt</i> is a pointer to a buffer with enough space to store the requested parameter to. For short parameters, this is only one char, for long-parameters the full name. The string will be zero-terminated.
</li>
<li><i>param</i> is a pointer to store a possible parameter value to, if the detected option allows for parameters.
</li>
<li><i>next</i> receives the index in argv of the next evaluated option. It can be left (int*)NULL. It points to the next valid index in argv[] after all parameters have been evaluated. Check it for &lt; argc, to point to valid data.
</li>
<li><i>argc</i> is the argument count as taken from the <a href="#fn_main">main()</a> function.
</li>
<li><i>argv</i> are the argument values as taken from the <a href="#fn_main">main()</a> function.
</li>
<li><i>optstr</i> contains the possible short-options. This is a string where each character defines an option. If an option takes a parameter, a colon (:) is submitted. E.g. "abc:def:g". The Options "-c" and "-f" will take a parameter that is
returned to param. This parameter can be (char*)NULL.
</li>
<li><i>loptstr</i> contains the possible long-options. This is a string containing all long option names, each separated by a blank. Long options taking parameters have an attached colon (:) to the name.  E.g. "hello world: next" defines three long options, where option 'world' takes one parameter that is returned to param. This parameter can be (char*)NULL.
</li>
<li><i>idx</i> is the index of the requested option, 0 for the first option behind argv[0].
</li>
</ul>

<p>
The function must be called multiple times to read all command-line parameters
and to react on the parameters.
</p>
<p>
The function returns 0, if the parameter with the given index was
successfully evaluated. It returns 1, if there are still command-line
parameters, but not as part of options. The parameter <i>param</i> will receive
the given pointer. It returns -1 if no more options could be read, or if an
option could not be evaluated (unknown option). In such case, <i>param</i> will
hold a string to the option that is unknown to <a href="#fn_pgetopt">pgetopt()</a>.
</p>
<p>
<b>Example:</b>
</p>
<p>
This is a minimal example showing the usage of <a href="#fn_pgetopt">pgetopt()</a> in a real program:
</p>

<pre><code class="language-c">
#include &lt;phorward.h&gt;

int main( int argc, char** argv )
{
    int			i;
    int			rc;
    int			next;
    char		opt			[ 10 + 1 ];
    char*		param;

    for( i = 0; ( rc = pgetopt( opt, &amp;param, &amp;next, argc, argv,
                                "ho:", "help output:", i ) ) == 0; i++ )
    {
        if( !strcmp( opt, "help" ) || !strcmp( opt, "h" ) )
            printf( "Help\n" );
        else if( !strcmp( opt, "output" ) || !strcmp( opt, "o" ) )
            printf( "Output = &gt;%s&lt;\n", param );
    }

    if( rc &lt; 0 &amp;&amp; param )
    {
        fprintf( stderr, "Unknown option '%s'\n", param );
        return 1;
    }

    for( i = 0; next &lt; argc; next++, i++ )
        printf( "Parameter %d = &gt;%s&lt;\n", i, argv[ next ] );

    return 0;
}
</code></pre>

</div>
<!-- NEED 32 -->
<div class='function'>

<h3 id="fn_plex_create">plex_create</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plex* plex_create( int flags )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Constructor function to create a new <a href="#plex">plex</a> object.
</p>
<p>
<i>flags</i> can be a combination of compile- and runtime-flags and are merged
with special compile-time flags provided for each pattern.
</p>

<table border="1">
<tr>
<th>Flag</th>
<th>Usage</th>
</tr>
<tr>
<td>PREGEX_COMP_WCHAR</td>
<td>The regular expressions are provided as wchar_t.</td>
</tr>
<tr>
<td>PREGEX_COMP_NOANCHORS</td>
<td>Ignore anchor tokens, handle them as normal characters</td>
</tr>
<tr>
<td>PREGEX_COMP_NOREF</td>
<td>Don't compile references.</td>
</tr>
<tr>
<td>PREGEX_COMP_NONGREEDY</td>
<td>Compile all patterns to be forced nongreedy.</td>
</tr>
<tr>
<td>PREGEX_COMP_NOERRORS</td>
<td>Don't report errors, and try to compile as much as possible</td>
</tr>
<tr>
<td>PREGEX_COMP_INSENSITIVE</td>
<td>Parse regular expressions as case insensitive.</td>
</tr>
<tr>
<td>PREGEX_COMP_STATIC</td>
<td>The regular expressions passed should be converted 1:1 as if it were a string-constant. Any regex-specific symbols will be ignored and taken as if escaped.</td>
</tr>
<tr>
<td>PREGEX_RUN_WCHAR</td>
<td>Run regular expressions with wchar_t as input.</td>
</tr>
<tr>
<td>PREGEX_RUN_NOANCHORS</td>
<td>Ignore anchors while processing the lexer.</td>
</tr>
<tr>
<td>PREGEX_RUN_NOREF</td>
<td>Don't create references.</td>
</tr>
<tr>
<td>PREGEX_RUN_NONGREEDY</td>
<td>Force run lexer nongreedy.</td>
</tr>
<tr>
<td>PREGEX_RUN_DEBUG</td>
<td>Debug mode; output some debug info to stderr.</td>
</tr>
</table>

<p>
On success, the function returns the allocated pointer to a <a href="#plex">plex</a>-object.
This must be freed later using <a href="#fn_plex_free">plex_free()</a>.
</div>
<!-- NEED 36 -->
<div class='function'>
</p>

<h3 id="fn_plex_define">plex_define</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pregex_ptn* plex_define( <a href="#plex">plex</a>* lex, char* pat, int match_id, int flags )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Defines and parses a regular expression pattern into the <a href="#plex">plex</a>-object.
</p>
<p>
<i>pat</i> is the regular expression string, or a pointer to a <a href="#pregex_ptn">pregex_ptn</a>*
structure in case PREGEX_COMP_PTN is flagged.
</p>
<p>
<i>match_id</i> must be a token match ID, a value &gt; 0. The lower the match ID is,
the higher precedence takes the appended expression when there are multiple
matches.
</p>
<p>
<i>flags</i> may ONLY contain compile-time flags, and is combined with the
compile-time flags of the <a href="#plex">plex</a>-object provided at <a href="#fn_plex_create">plex_create()</a>.
</p>

<table border="1">
<tr>
<th>Flag</th>
<th>Usage</th>
</tr>
<tr>
<td>PREGEX_COMP_WCHAR</td>
<td>The regular expressions are provided as wchar_t.</td>
</tr>
<tr>
<td>PREGEX_COMP_NOANCHORS</td>
<td>Ignore anchor tokens, handle them as normal characters</td>
</tr>
<tr>
<td>PREGEX_COMP_NOREF</td>
<td>Don't compile references.</td>
</tr>
<tr>
<td>PREGEX_COMP_NONGREEDY</td>
<td>Compile all patterns to be forced nongreedy.</td>
</tr>
<tr>
<td>PREGEX_COMP_NOERRORS</td>
<td>Don't report errors, and try to compile as much as possible</td>
</tr>
<tr>
<td>PREGEX_COMP_INSENSITIVE</td>
<td>Parse regular expressions as case insensitive.</td>
</tr>
<tr>
<td>PREGEX_COMP_STATIC</td>
<td>The regular expressions passed should be converted 1:1 as if it were a string-constant. Any regex-specific symbols will be ignored and taken as if escaped.</td>
</tr>
<tr>
<td>PREGEX_COMP_PTN</td>
<td>The regular expression passed already is a pattern, and shall be integrated.</td>
</tr>
</table>

<p>
Returns a pointer to the pattern object that just has been added. This allows
for changing e.g. the accept flag later on. In case of an error, the value
returned is NULL.
</div>
<!-- NEED 19 -->
<div class='function'>
</p>

<h3 id="fn_plex_dump_dot">plex_dump_dot</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void plex_dump_dot( FILE* stream, <a href="#plex">plex</a>* lex )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Dumps the DFA of a <i>lex</i> lexer object into a DOT-formatted graph output.
</p>
<p>
The graph can be made visible with tools like Graphviz
(<a href="http://www.graphviz.org/">http://www.graphviz.org/</a>) and similar.
</p>
<p>
<i>stream</i> is the output stream to be used. This is stdout when NULL is
provided.
</p>
<p>
<i>lex</i> is the <a href="#plex">plex</a> object, which DFA shall be dumped.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_plex_free">plex_free</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plex* plex_free( <a href="#plex">plex</a>* lex )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Destructor function for a <a href="#plex">plex</a>-object.
</p>
<p>
<i>lex</i> is the pointer to a <a href="#plex">plex</a>-structure that will be released.
</p>
<p>
Always returns (<a href="#plex">plex</a>*)NULL.
</div>
<!-- NEED 18 -->
<div class='function'>
</p>

<h3 id="fn_plex_lex">plex_lex</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int plex_lex( <a href="#plex">plex</a>* lex, char* start, char** end )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Performs a lexical analysis using the object <i>lex</i> on pointer <i>start</i>.
</p>
<p>
If a token can be matched, the function returns the related id of the matching
pattern, and <i>end</i> receives the pointer to the last matched character.
</p>
<p>
The function returns 0 in case that there was no direct match.
The function <a href="#fn_plex_next">plex_next()</a> ignores unrecognized symbols and directly moves to the
next matching pattern.
</div>
<!-- NEED 22 -->
<div class='function'>
</p>

<h3 id="fn_plex_next">plex_next</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* plex_next( <a href="#plex">plex</a>* lex, char* start, unsigned int* id, char** end )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Performs lexical analysis using <i>lex</i> from begin of pointer <i>start</i>, to
the next matching token.
</p>
<p>
<i>start</i> has to be a zero-terminated string or wide-character string (according
to the configuration of the <a href="#plex">plex</a>-object).
</p>
<p>
If a token can be matched, the function returns the pointer to the position
where the match starts at. <i>id</i> receives the id of the matching pattern,
<i>end</i> receives the end pointer of the match, when provided. <i>id</i> and <i>end</i>
can be omitted by providing NULL-pointers.
</p>
<p>
The function returns (char*)NULL in case that there is no match.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_plex_prepare">plex_prepare</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean plex_prepare( <a href="#plex">plex</a>* lex )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Prepares the DFA state machine of a <a href="#plex">plex</a>-object <i>lex</i> for execution.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_plex_reset">plex_reset</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean plex_reset( <a href="#plex">plex</a>* lex )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Resets the DFA state machine of a <a href="#plex">plex</a>-object <i>lex</i>.
</div>
<!-- NEED 18 -->
<div class='function'>
</p>

<h3 id="fn_plex_tokenize">plex_tokenize</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
size_t plex_tokenize( <a href="#plex">plex</a>* lex, char* start, <a href="#parray">parray</a>** matches )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Tokenizes the string beginning at <i>start</i> using the lexical analyzer
<i>lex</i>.
</p>
<p>
<i>start</i> has to be a zero-terminated string or wide-character string (according
to the configuration of the <a href="#plex">plex</a>-object).
</p>
<p>
The function initializes and fills the array <i>matches</i>, if provided, with
items of size <a href="#prange">prange</a>. It returns the total number of matches.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_plexctx_create">plexctx_create</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plexctx* plexctx_create( <a href="#plex">plex</a>* lex )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Creates a new lexer context for lexer <i>par</i>.
</p>
<p>
lexer contexts are objects holding state and semantics information on a
current parsing process.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_plexctx_free">plexctx_free</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plexctx* plexctx_free( plexctx* ctx )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Frees the lexer context object <i>ctx</i>.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_plexctx_init">plexctx_init</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plexctx* plexctx_init( plexctx* ctx, <a href="#plex">plex</a>* lex )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Initializes a lexer context <i>ctx</i> for lexer <i>lex</i>.
</p>
<p>
Lexer contexts are objects holding state and semantics information on a current
lexing process.
</div>
<!-- NEED 12 -->
<div class='function'>
</p>

<h3 id="fn_plexctx_lex">plexctx_lex</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean plexctx_lex( plexctx* ctx, wchar_t ch )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Performs a lexical analysis using the object <i>lex</i> using context <i>ctx</i>
and character <i>ch</i>.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_plexctx_reset">plexctx_reset</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plexctx* plexctx_reset( plexctx* ctx )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Resets the lexer context object <i>ctx</i>.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_plist_access">plist_access</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* plist_access( <a href="#plistel">plistel</a>* e )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Access data-content of the current element <i>e</i>.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_plist_clear">plist_clear</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void plist_clear( <a href="#plist">plist</a>* list )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Clear content of the list <i>list</i>.
</p>
<p>
The function has nearly the same purpose as <a href="#fn_plist_erase">plist_erase()</a>, except that
the entire list is only cleared, but if the list was initialized with
PLIST_MOD_RECYCLE, existing pointers are held for later usage.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_plist_concat">plist_concat</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
size_t plist_concat( <a href="#plist">plist</a>* dest, <a href="#plist">plist</a>* src )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Concats the elements of list <i>src</i> to the elements of list <i>dest</i>.
</p>
<p>
The function will not run if both lists have different element size settings.
</p>
<p>
The function returns the number of elements added to <i>dest</i>.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_plist_count">plist_count</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int plist_count( <a href="#plist">plist</a>* l )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Return element count of list <i>l</i>.
</div>
<!-- NEED 30 -->
<div class='function'>
</p>

<h3 id="fn_plist_create">plist_create</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plist* plist_create( size_t size, short flags )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Create a new <a href="#plist">plist</a> as an object with an element allocation size <i>size</i>.
Providing a <i>size</i> of 0 causes automatic configuration of PLIST_MOD_PTR.
</p>
<p>
<i>flags</i> defines an optional flag configuration that modifies the behavior
of the linked list and hash table usage. The flags can be merged together using
bitwise or (|).
</p>
<p>
Possible flags are:
</p>

<ul>
<li><b>PLIST_MOD_NONE</b> for no special flagging.
</li>
<li><b>PLIST_MOD_PTR</b> to use the <a href="#plist">plist</a>-object in pointer-mode: Each <a href="#plistel">plistel</a>-element cointains only a pointer to an object in the memory and returns this, instead of copying from or into pointers.
</li>
<li><b>PLIST_MOD_RECYCLE</b> to configure that elements that are removed during list usage will be reused later.
</li>
<li><b>PLIST_MOD_AUTOSORT</b> to automatically sort elements on insert operations.
</li>
<li><b>PLIST_MOD_EXTKEYS</b> to configure that string pointers to hash-table keyvalues are stored elsewhere, so the <a href="#plist">plist</a>-module only uses the original pointers instead of copying them.
</li>
<li><b>PLIST_MOD_PTRKEYS</b> disables string keys and uses the pointer/value provided as key directly.
</li>
<li><b>PLIST_MOD_KEEPKEYS</b> holds the correct element insertation sequence. In case of a key collision, the inserted element is inserted <u>behind</u> the colliding element rather than <u>before</u>.
</li>
<li><b>PLIST_MOD_UNIQUE</b> to disallow hash-table-key collisions, so elements with a key that already exist in the object will be rejected.
</li>
<li><b>PLIST_MOD_WCHAR</b> to handle all key values as wide-character strings.
</li>
</ul>

<p>
Use <a href="#fn_plist_free">plist_free()</a> to erase and release the returned list object.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_plist_dbgstats">plist_dbgstats</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void plist_dbgstats( FILE* stream, <a href="#plist">plist</a>* list )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Prints some statistics for the hashmap in <i>list</i> on stderr.
</div>
<!-- NEED 16 -->
<div class='function'>
</p>

<h3 id="fn_plist_diff">plist_diff</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int plist_diff( <a href="#plist">plist</a>* left, <a href="#plist">plist</a>* right )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Tests the contents (data parts) of the list <i>left</i> and the list <i>right</i>
for equal elements.
</p>
<p>
The function returns a value &lt; 0 if <i>left</i> is lower <i>right</i>, a value &gt; 0
if <i>left</i> is greater <i>right</i> and a value == 0 if <i>left</i> is equal to
<i>right</i>.
</div>
<!-- NEED 13 -->
<div class='function'>
</p>

<h3 id="fn_plist_dup">plist_dup</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plist* plist_dup( <a href="#plist">plist</a>* list )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Creates an independent copy of <i>list</i> and returns it.
</p>
<p>
All elements of <i>list</i> are duplicated and stand-alone.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_plist_erase">plist_erase</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void plist_erase( <a href="#plist">plist</a>* list )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Erase all allocated content of the list <i>list</i>.
</p>
<p>
The object <i>list</i> will be still alive, but must be re-configured
using <a href="#fn_plist_init">plist_init()</a>.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_plist_first">plist_first</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plistel* plist_first( <a href="#plist">plist</a>* l )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Return first element of list <i>l</i>.
</div>
<!-- NEED 13 -->
<div class='function'>
</p>

<h3 id="fn_plist_free">plist_free</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plist* plist_free( <a href="#plist">plist</a>* list )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Releases all the memory <i>list</i> uses and destroys the list object.
</p>
<p>
The function always returns (<a href="#plist">plist</a>*)NULL.
</div>
<!-- NEED 13 -->
<div class='function'>
</p>

<h3 id="fn_plist_get">plist_get</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plistel* plist_get( <a href="#plist">plist</a>* list, size_t n )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Retrieve list element by its index from the begin.
</p>
<p>
The function returns the <i>n</i>th element of the list <i>list</i>.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_plist_get_by_key">plist_get_by_key</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plistel* plist_get_by_key( <a href="#plist">plist</a>* list, char* key )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Retrieve list element by hash-table <i>key</i>.
</p>
<p>
This function tries to fetch a list entry <a href="#plistel">plistel</a> from list <i>list</i>
with the key <i>key</i>.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_plist_get_by_nkey">plist_get_by_nkey</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plistel* plist_get_by_nkey( <a href="#plist">plist</a>* list, char* key, size_t n )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Retrieve list element by hash-table <i>key</i>,
where key is limited by <i>n</i> bytes.
</p>
<p>
This function tries to fetch a list entry <a href="#plistel">plistel</a> from list <i>list</i>
with the key <i>key</i> over a size of <i>n</i> bytes.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_plist_get_by_ptr">plist_get_by_ptr</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plistel* plist_get_by_ptr( <a href="#plist">plist</a>* list, void* ptr )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Retrieve list element by pointer.
</p>
<p>
This function returns the list element of the unit within the list <i>list</i>
that is the pointer <i>ptr</i>.
</div>
<!-- NEED 13 -->
<div class='function'>
</p>

<h3 id="fn_plist_getkey">plist_getkey</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plistel* plist_getkey( <a href="#plist">plist</a>* list, size_t n )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Retrieve list keys by their index from the begin.
</p>
<p>
The function returns the <i>n</i>th key within the list <i>list</i>.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_plist_hashnext">plist_hashnext</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plistel* plist_hashnext( <a href="#plistel">plistel</a>* u )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Access next element with same hash value of current unit <i>u</i>.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_plist_hashprev">plist_hashprev</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plistel* plist_hashprev( <a href="#plistel">plistel</a>* u )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Access previous element with same hash value of a current unit <i>u</i>.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_plist_init">plist_init</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void plist_init( <a href="#plist">plist</a>* list, size_t size, short flags )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Initialize the list <i>list</i> with an element allocation size <i>size</i>.
</p>
<p>
<i>flags</i> defines an optional flag configuration that modifies the behavior
of the linked list and hash table usage.
</div>
<!-- NEED 19 -->
<div class='function'>
</p>

<h3 id="fn_plist_insert">plist_insert</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plistel* plist_insert( <a href="#plist">plist</a>* list, <a href="#plistel">plistel</a>* pos, char* key, void* src )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Insert <i>src</i> as element to the list <i>list</i> <u>before</u> position <i>pos</i>.
</p>
<p>
If <i>pos</i> is NULL, the new element will be attached to the end of the
list.
</p>
<p>
If <i>key</i> is not NULL, the element will also be added to the lists hash table.
</p>
<p>
If <i>src</i> is NULL, a zero-initialized element is inserted into the list for
further processing.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_plist_iter">plist_iter</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void plist_iter( <a href="#plist">plist</a>* list, plistelfn callback )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Iterates over <i>list</i>.
</p>
<p>
Iterates over all items of <i>list</i> and calls the function <i>callback</i> on
every item. The callback function receives the <a href="#plistel">plistel</a>-element pointer of
the list element.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_plist_iter_access">plist_iter_access</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void plist_iter_access( <a href="#plist">plist</a>* list, plistfn callback )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Iterates over <i>list</i> and accesses every item.
</p>
<p>
Iterates over all items of <i>list</i> and calls the function <i>callback</i> on
every item's access. The callback function receives a pointer to the accessed
element.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_plist_key">plist_key</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* plist_key( <a href="#plistel">plistel</a>* e )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Access key-content of the current element <i>e</i>.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_plist_last">plist_last</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plistel* plist_last( <a href="#plist">plist</a>* l )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Return last element of list <i>l</i>.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_plist_malloc">plist_malloc</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* plist_malloc( <a href="#plist">plist</a>* list )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Allocates memory for a new element in list <i>list</i>, push it to the end and
return the pointer to this.
</p>
<p>
The function works as a shortcut for <a href="#fn_plist_access">plist_access()</a> in combination with <a href="#fn_plist_push">plist_push()</a>.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_plist_next">plist_next</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plistel* plist_next( <a href="#plistel">plistel</a>* u )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Access next element of current unit <i>u</i>.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_plist_offset">plist_offset</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int plist_offset( <a href="#plistel">plistel</a>* u )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Return the offset of the unit <i>u</i> within the list it belongs to.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_plist_pop">plist_pop</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean plist_pop( <a href="#plist">plist</a>* list, void* dest )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Pop last element to <i>dest</i> off the list <i>list</i>.
</p>
<p>
Like <i>list</i> would be a stack, the last element of the list is popped and
its content is written to <i>dest</i>, if provided at the end of the list.
</p>
<p>
<i>dest</i> can be omitted and given as (void*)NULL, so the last element will
be popped off the list and discards.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_plist_prev">plist_prev</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plistel* plist_prev( <a href="#plistel">plistel</a>* u )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Access previous element of current unit <i>u</i>.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_plist_push">plist_push</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plistel* plist_push( <a href="#plist">plist</a>* list, void* src )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Push <i>src</i> to end of <i>list</i>.
</p>
<p>
Like <i>list</i> would be a stack, <i>src</i> is pushed at the end of the list.
This function can only be used for linked lists without the hash-table feature
in use.
</div>
<!-- NEED 12 -->
<div class='function'>
</p>

<h3 id="fn_plist_remove">plist_remove</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void plist_remove( <a href="#plist">plist</a>* list, <a href="#plistel">plistel</a>* e )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Removes the element <i>e</i> from the <i>list</i> and frees it or puts
it into the unused element chain if PLIST_MOD_RECYCLE is flagged.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_plist_rget">plist_rget</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plistel* plist_rget( <a href="#plist">plist</a>* list, size_t n )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Retrieve list element by its index from the end.
</p>
<p>
The function returns the <i>n</i>th element of the list <i>list</i>
from the right.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_plist_riter">plist_riter</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void plist_riter( <a href="#plist">plist</a>* list, plistelfn callback )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Iterates backwards over <i>list</i>.
</p>
<p>
Backwardly iterates over all items of <i>list</i> and calls the function
<i>callback</i> on every item. The callback function receives the <a href="#plistel">plistel</a>-element
pointer of the list element.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_plist_riter_access">plist_riter_access</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void plist_riter_access( <a href="#plist">plist</a>* list, plistfn callback )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Iterates backwards over <i>list</i>.
</p>
<p>
Backwardly iterates over all items of <i>list</i> and calls the function
<i>callback</i> on every  item's access. The callback function receives a pointer
to the accessed element.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_plist_rmalloc">plist_rmalloc</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* plist_rmalloc( <a href="#plist">plist</a>* list )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Allocates memory for a new element in list <i>list</i>, shift it at the begin
and return the pointer to this.
</p>
<p>
The function works as a shortcut for <a href="#fn_plist_access">plist_access()</a> in combination with <a href="#fn_plist_shift">plist_shift()</a>.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_plist_set_comparefn">plist_set_comparefn</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void plist_set_comparefn( <a href="#plist">plist</a>* list, int (*comparefn)( <a href="#plist">plist</a>*, <a href="#plistel">plistel</a>*, <a href="#plistel">plistel</a>* ) )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Set compare function.
</p>
<p>
If no compare function is set or NULL is provided, <a href="#fn_memcmp">memcmp()</a> will be used
as default fallback.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_plist_set_printfn">plist_set_printfn</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void plist_set_printfn( <a href="#plist">plist</a>* list, void (*printfn)( <a href="#plist">plist</a>* ) )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Set an element dump function.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_plist_set_sortfn">plist_set_sortfn</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void plist_set_sortfn( <a href="#plist">plist</a>* list, int (*sortfn)( <a href="#plist">plist</a>*, <a href="#plistel">plistel</a>*, <a href="#plistel">plistel</a>* ) )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Set sort function.
</p>
<p>
If no sort function is given, the compare function set by <a href="#fn_plist_set_comparefn">plist_set_comparefn()</a>
is used. If even unset, <a href="#fn_memcmp">memcmp()</a> will be used.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_plist_shift">plist_shift</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
plistel* plist_shift( <a href="#plist">plist</a>* list, void* src )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Shift <i>src</i> at begin of <i>list</i>.
</p>
<p>
Like <i>list</i> would be a queue, <i>src</i> is shifted at the beginning of the list.
This function can only be used for linked lists without the hash-table feature
in use.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_plist_size">plist_size</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int plist_size( <a href="#plist">plist</a>* l )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Return element size of list <i>l</i>.
</div>
<!-- NEED 18 -->
<div class='function'>
</p>

<h3 id="fn_plist_sort">plist_sort</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void plist_sort( <a href="#plist">plist</a>* list )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Sorts <i>list</i> according to the sort-function that was set for the list.
</p>
<p>
To sort only parts of a list, use <a href="#fn_plist_subsort">plist_subsort()</a>.
</p>
<p>
The sort-function can be modified by using <a href="#fn_plist_set_sortfn">plist_set_sortfn()</a>.
</p>
<p>
The default sort function sorts the list by content using the <a href="#fn_memcmp">memcmp()</a>
standard function.
</div>
<!-- NEED 19 -->
<div class='function'>
</p>

<h3 id="fn_plist_subsort">plist_subsort</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void plist_subsort( <a href="#plist">plist</a>* list, <a href="#plistel">plistel</a>* from, <a href="#plistel">plistel</a>* to )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Sorts <i>list</i> between the elements <i>from</i> and <i>to</i> according to the
sort-function that was set for the list.
</p>
<p>
To sort the entire list, use <a href="#fn_plist_sort">plist_sort()</a>.
</p>
<p>
The sort-function can be modified by using <a href="#fn_plist_set_sortfn">plist_set_sortfn()</a>.
</p>
<p>
The default sort function sorts the list by content using the <a href="#fn_memcmp">memcmp()</a>
standard function.
</div>
<!-- NEED 13 -->
<div class='function'>
</p>

<h3 id="fn_plist_swap">plist_swap</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void plist_swap( <a href="#plist">plist</a>* l, <a href="#plistel">plistel</a>* a, <a href="#plistel">plistel</a>* b )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Swaps the positions of the list elements <i>a</i> and <i>b</i> with each
other. The elements must be in the same <a href="#plist">plist</a> object, else the function
returns FALSE.
</div>
<!-- NEED 18 -->
<div class='function'>
</p>

<h3 id="fn_plist_union">plist_union</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
size_t plist_union( <a href="#plist">plist</a>* all, <a href="#plist">plist</a>* from )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Unions elements from list <i>from</i> into list <i>all</i>.
</p>
<p>
An element is only added to <i>all</i>, if there exists no equal element with the
same size and content.
</p>
<p>
The function will not run if both lists have different element size settings.
</p>
<p>
The function returns the number of elements added to <i>from</i>.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_plist_unshift">plist_unshift</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean plist_unshift( <a href="#plist">plist</a>* list, void* dest )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Take first element of <i>list</i> and write it to <i>dest</i>.
</p>
<p>
Like <i>list</i> would be a queue, the first element of the list is taken and
its content is written to <i>dest</i>.
</p>
<p>
<i>dest</i> can be omitted and given as (void*)NULL, so the first element from
<i>list</i> will be taken and discarded.
</div>
<!-- NEED 20 -->
<div class='function'>
</p>

<h3 id="fn_pmalloc">pmalloc</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* pmalloc( size_t size )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Dynamically allocate heap memory.
</p>
<p>
The function is a wrapper for the system function <a href="#fn_malloc">malloc()</a>, but with memory
initialization to zero, and immediately stops the program if no more memory
can be allocated.
</p>
<p>
<i>size</i> is the size of memory to be allocated, in bytes.
</p>
<p>
The function returns the allocated heap memory pointer. The returned memory
address should be freed using <a href="#fn_pfree">pfree()</a> after it is not required anymore.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_pmemdup">pmemdup</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* pmemdup( void* ptr, size_t size )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Duplicates a memory entry onto the heap.
</p>
<p>
<i>ptr</i> is the pointer to the memory to be duplicated.
<i>size</i> is the size of pointer's data storage.
</p>
<p>
Returns the new pointer to the memory copy. This should be cast back to the
type of <i>ptr</i> again.
</div>
<!-- NEED 22 -->
<div class='function'>
</p>

<h3 id="fn_prealloc">prealloc</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void* prealloc( void* oldptr, size_t size )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Dynamically (re)allocate memory on the heap.
</p>
<p>
The function wraps the system-function <a href="#fn_realloc">realloc()</a>, but always accepts a
NULL-pointer and immediately stops the program if no more memory can be
allocated.
</p>
<p>
<i>oldptr</i> is the pointer to be reallocated. If this is (void*)NULL, <a href="#fn_prealloc">prealloc()</a> works like a normal call to <a href="#fn_pmalloc">pmalloc()</a>.
</p>
<p>
<i>size</i> is the size of memory to be reallocated, in bytes.
</p>
<p>
The function returns the allocated heap memory pointer. The returned memory
address should be freed using <a href="#fn_pfree">pfree()</a> after it is not required any more.
</div>
<!-- NEED 32 -->
<div class='function'>
</p>

<h3 id="fn_pregex_create">pregex_create</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pregex* pregex_create( char* pat, int flags )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Constructor function to create a new <a href="#pregex">pregex</a> object.
</p>
<p>
<i>pat</i> is a string providing a regular expression pattern.
<i>flags</i> can be a combination of compile- and runtime-flags.
</p>

<table border="1">
<tr>
<th>Flag</th>
<th>Usage</th>
</tr>
<tr>
<td>PREGEX_COMP_WCHAR</td>
<td>The regular expression <i>pat</i> is provided as wchar_t.</td>
</tr>
<tr>
<td>PREGEX_COMP_NOANCHORS</td>
<td>Ignore anchor tokens, handle them as normal characters</td>
</tr>
<tr>
<td>PREGEX_COMP_NOREF</td>
<td>Don't compile references.</td>
</tr>
<tr>
<td>PREGEX_COMP_NONGREEDY</td>
<td>Compile regex to be forced non-greedy.</td>
</tr>
<tr>
<td>PREGEX_COMP_NOERRORS</td>
<td>Don't report errors, and try to compile as much as possible</td>
</tr>
<tr>
<td>PREGEX_COMP_INSENSITIVE</td>
<td>Parse regular expression as case insensitive.</td>
</tr>
<tr>
<td>PREGEX_COMP_STATIC</td>
<td>The regular expression passed should be converted 1:1 as it where a string-constant. Any regex-specific symbols will be ignored and taken as they where escaped.</td>
</tr>
<tr>
<td>PREGEX_RUN_WCHAR</td>
<td>Run regular expression with wchar_t as input.</td>
</tr>
<tr>
<td>PREGEX_RUN_NOANCHORS</td>
<td>Ignore anchors while processing the regex.</td>
</tr>
<tr>
<td>PREGEX_RUN_NOREF</td>
<td>Don't create references.</td>
</tr>
<tr>
<td>PREGEX_RUN_NONGREEDY</td>
<td>Force run regular expression non-greedy.</td>
</tr>
<tr>
<td>PREGEX_RUN_DEBUG</td>
<td>Debug mode; output some debug to stderr.</td>
</tr>
</table>

<p>
On success, the function returns the allocated pointer to a <a href="#pregex">pregex</a>-object.
This must be freed later using <a href="#fn_pregex_free">pregex_free()</a>.
</div>
<!-- NEED 21 -->
<div class='function'>
</p>

<h3 id="fn_pregex_find">pregex_find</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pregex_find( <a href="#pregex">pregex</a>* regex, char* start, char** end )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Find a match for the regular expression <i>regex</i> from begin of pointer
<i>start</i>.
</p>
<p>
<i>start</i> has to be a zero-terminated string or wide-character string (according
to the configuration of the <a href="#pregex">pregex</a>-object).
</p>
<p>
If the expression can be matched, the function returns the pointer to the
position where the match begins. <i>end</i> receives the end pointer of the match,
when provided.
</p>
<p>
The function returns (char*)NULL in case that there is no match.
</div>
<!-- NEED 18 -->
<div class='function'>
</p>

<h3 id="fn_pregex_findall">pregex_findall</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int pregex_findall( <a href="#pregex">pregex</a>* regex, char* start, <a href="#parray">parray</a>** matches )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Find all matches for the regular expression <i>regex</i> from begin of pointer
<i>start</i>, and optionally return matches as an array.
</p>
<p>
<i>start</i> has to be a zero-terminated string or wide-character string (according
to the configuration of the <a href="#pregex">pregex</a>-object).
</p>
<p>
The function fills the array <i>matches</i>, if provided, with items of size
prange. It returns the total number of matches.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_pregex_free">pregex_free</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pregex* pregex_free( <a href="#pregex">pregex</a>* regex )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Destructor function for a <a href="#pregex">pregex</a>-object.
</p>
<p>
<i>regex</i> is the pointer to a <a href="#pregex">pregex</a>-structure that will be released.
</p>
<p>
Returns always (<a href="#pregex">pregex</a>*)NULL.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_pregex_match">pregex_match</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean pregex_match( <a href="#pregex">pregex</a>* regex, char* start, char** end )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Tries to match the regular expression <i>regex</i> at pointer <i>start</i>.
</p>
<p>
If the expression can be matched, the function returns TRUE and <i>end</i> receives
the pointer to the last matched character.
</div>
<!-- NEED 22 -->
<div class='function'>
</p>

<h3 id="fn_pregex_ptn_create">pregex_ptn_create</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pregex_ptn* pregex_ptn_create( char* pat, int flags )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Constructs and parses a new <a href="#pregex_ptn">pregex_ptn</a>-structure from <i>pat</i>.
</p>
<p>
This function is a shortcut for a call to <a href="#fn_pregex_ptn_parse">pregex_ptn_parse()</a>. <a href="#fn_pregex_ptn_create">pregex_ptn_create()</a> directly takes <i>pat</i> as its input and returns the parsed
pregex_ptn structure which represents the internal representation of the
regular expression <i>pat</i>.
</p>
<p>
<i>flags</i> provides a combination of compile-time modifier flags
(PREGEX_COMP_...) if wanted, or 0 (PREGEX_FLAG_NONE) if no flags should be
used.
</p>
<p>
Returns an allocated <a href="#pregex_ptn">pregex_ptn</a>-node which must be freed using <a href="#fn_pregex_ptn_free">pregex_ptn_free()</a>
when it is not used anymore.
</div>
<!-- NEED 19 -->
<div class='function'>
</p>

<h3 id="fn_pregex_ptn_create_alt">pregex_ptn_create_alt</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pregex_ptn* pregex_ptn_create_alt( <a href="#pregex_ptn">pregex_ptn</a>* left, ... )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Constructs alternations of multiple patterns.
</p>
<p>
<i>left</i> is the first pattern of the alternation.
<i>...</i> are multiple <a href="#pregex_ptn">pregex_ptn</a>-pointers follow which become part of the
alternation. The last node must be specified as (<a href="#pregex_ptn">pregex_ptn</a>*)NULL.
</p>
<p>
Returns a <a href="#pregex_ptn">pregex_ptn</a>-node which can be child of another pattern construct or
part of a sequence. If there is only <i>left</i> assigned without other alternation
patterns, <i>left</i> will be returned back.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_pregex_ptn_create_char">pregex_ptn_create_char</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pregex_ptn* pregex_ptn_create_char( <a href="#pccl">pccl</a>* ccl )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Constructs a character-class pattern.
</p>
<p>
<i>ccl</i> is the pointer to a character class. This pointer is not duplicated,
and will be directly assigned to the object.
</p>
<p>
Returns a <a href="#pregex_ptn">pregex_ptn</a>-node which can be child of another pattern construct or
part of a sequence.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_pregex_ptn_create_kle">pregex_ptn_create_kle</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pregex_ptn* pregex_ptn_create_kle( <a href="#pregex_ptn">pregex_ptn</a>* ptn )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Constructs a kleene-closure repetition, allowing for multiple or none
repetitions of the specified pattern.
</p>
<p>
<i>ptn</i> is the pattern that will be configured for kleene-closure.
</p>
<p>
Returns a <a href="#pregex_ptn">pregex_ptn</a>-node which can be child of another pattern construct or
part of a sequence.
</div>
<!-- NEED 16 -->
<div class='function'>
</p>

<h3 id="fn_pregex_ptn_create_opt">pregex_ptn_create_opt</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pregex_ptn* pregex_ptn_create_opt( <a href="#pregex_ptn">pregex_ptn</a>* ptn )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Constructs an optional-closure, allowing for one or none specified pattern.
</p>
<p>
<i>ptn</i> is the pattern to be configured for optional closure.
</p>
<p>
Returns a <a href="#pregex_ptn">pregex_ptn</a>-node which can be child of another pattern construct or
part of a sequence.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_pregex_ptn_create_pos">pregex_ptn_create_pos</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pregex_ptn* pregex_ptn_create_pos( <a href="#pregex_ptn">pregex_ptn</a>* ptn )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Constructs an positive-closure, allowing for one or multiple specified
pattern.
</p>
<p>
<i>ptn</i> is the pattern to be configured for positive closure.
</p>
<p>
Returns a <a href="#pregex_ptn">pregex_ptn</a>-node which can be child of another pattern construct or
part of a sequence.
</div>
<!-- NEED 16 -->
<div class='function'>
</p>

<h3 id="fn_pregex_ptn_create_refsub">pregex_ptn_create_refsub</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pregex_ptn* pregex_ptn_create_refsub( <a href="#pregex_ptn">pregex_ptn</a>* ptn )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Constructs a sub-pattern as backreference (like with parantheses).
</p>
<p>
<i>ptn</i> is the pattern that becomes the sub-ordered pattern.
</p>
<p>
Returns a <a href="#pregex_ptn">pregex_ptn</a>-node which can be child of another pattern construct
or part of a sequence.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_pregex_ptn_create_seq">pregex_ptn_create_seq</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pregex_ptn* pregex_ptn_create_seq( <a href="#pregex_ptn">pregex_ptn</a>* first, ... )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Constructs a sequence of multiple patterns.
</p>
<p>
<i>first</i> is the beginning pattern of the sequence. <i>...</i> follows as parameter
list of multiple patterns that become part of the sequence. The last pointer
must be specified as (<a href="#pregex_ptn">pregex_ptn</a>*)NULL to mark the end of the list.
</p>
<p>
Always returns the pointer to <i>first</i>.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_pregex_ptn_create_string">pregex_ptn_create_string</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pregex_ptn* pregex_ptn_create_string( char* str, int flags )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Constructs a pattern for a static string.
</p>
<p>
<i>str</i> is the input string to be converted.
<i>flags</i> are optional flags for wide-character support.
</p>
<p>
Returns a <a href="#pregex_ptn">pregex_ptn</a>-node which can be child of another pattern construct or
part of a sequence.
</div>
<!-- NEED 16 -->
<div class='function'>
</p>

<h3 id="fn_pregex_ptn_create_sub">pregex_ptn_create_sub</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pregex_ptn* pregex_ptn_create_sub( <a href="#pregex_ptn">pregex_ptn</a>* ptn )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Constructs a sub-pattern (like with parantheses).
</p>
<p>
<i>ptn</i> is the pattern that becomes the sub-ordered pattern.
</p>
<p>
Returns a <a href="#pregex_ptn">pregex_ptn</a>-node which can be child of another pattern construct
or part of a sequence.
</div>
<!-- NEED 11 -->
<div class='function'>
</p>

<h3 id="fn_pregex_ptn_dup">pregex_ptn_dup</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pregex_ptn* pregex_ptn_dup( <a href="#pregex_ptn">pregex_ptn</a>* ptn )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Duplicate <i>ptn</i> into a stand-alone 1:1 copy.
</div>
<!-- NEED 16 -->
<div class='function'>
</p>

<h3 id="fn_pregex_ptn_free">pregex_ptn_free</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pregex_ptn* pregex_ptn_free( <a href="#pregex_ptn">pregex_ptn</a>* ptn )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Releases memory of a pattern including all its subsequent and following
patterns.
</p>
<p>
<i>ptn</i> is the pattern object to be released.
</p>
<p>
Always returns (<a href="#pregex_ptn">pregex_ptn</a>*)NULL.
</div>
<!-- NEED 21 -->
<div class='function'>
</p>

<h3 id="fn_pregex_ptn_parse">pregex_ptn_parse</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean pregex_ptn_parse( <a href="#pregex_ptn">pregex_ptn</a>** ptn, char* str, int flags )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Parse a regular expression pattern string into a <a href="#pregex_ptn">pregex_ptn</a> structure.
</p>
<p>
<i>ptn</i> is the return pointer receiving the root node of the generated pattern.
</p>
<p>
<i>str</i> is the pointer to the string which contains the pattern to be parsed. If
PREGEX_COMP_WCHAR is assigned in <i>flags</i>, this pointer must be set to a
wchar_t-array holding a wide-character string.
</p>
<p>
<i>flags</i> provides compile-time modifier flags (PREGEX_COMP_...).
</p>
<p>
Returns TRUE on success.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_pregex_ptn_print">pregex_ptn_print</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
void pregex_ptn_print( <a href="#pregex_ptn">pregex_ptn</a>* ptn, int rec )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
A debug function to print a pattern's hierarchical structure to stderr.
</p>
<p>
<i>ptn</i> is the pattern object to be printed.
<i>rec</i> is the recursion depth, set this to 0 at initial call.
</div>
<!-- NEED 18 -->
<div class='function'>
</p>

<h3 id="fn_pregex_ptn_to_dfa">pregex_ptn_to_dfa</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean pregex_ptn_to_dfa( pregex_dfa* dfa, <a href="#pregex_ptn">pregex_ptn</a>* ptn )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Converts a pattern-structure into a DFA state machine.
</p>
<p>
<i>dfa</i> is the DFA state machine structure that receives the compiled result of
the pattern. <i>dfa</i> must be initialized!
<i>ptn</i> is the pattern structure that will be converted and extended into
the DFA state machine.
</p>
<p>
Returns TRUE on success.
</div>
<!-- NEED 60 -->
<div class='function'>
</p>

<h3 id="fn_pregex_ptn_to_dfatab">pregex_ptn_to_dfatab</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int pregex_ptn_to_dfatab( wchar_t*** dfatab, <a href="#pregex_ptn">pregex_ptn</a>* ptn )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Converts a pattern-structure into a DFA state machine <i>dfatab</i>.
</p>
<p>
<i>ptn</i> is the pattern structure that will be converted into a DFA state
machine.
</p>
<p>
<i>dfatab</i> is a pointer to a variable that receives the allocated DFA state machine, where
each row forms a state that is made up of columns described in the table below.
</p>

<table border="1">
<tr>
<th>Column / Index</th>
<th>Content</th>
</tr>
<tr>
<td>0</td>
<td>Total number of columns in the current row</td>
</tr>
<tr>
<td>1</td>
<td>Match ID if &gt; 0, or 0 if the state is not an accepting state</td>
</tr>
<tr>
<td>2</td>
<td>Match flags (anchors, greedyness, (PREGEX_FLAG_*))</td>
</tr>
<tr>
<td>3</td>
<td>Reference flags; The index of the flagged bits defines the number of reference</td>
</tr>
<tr>
<td>4</td>
<td>Default transition from the current state. If there is no transition, its value is set to the number of all states.</td>
</tr>
<tr>
<td>5</td>
<td>Transition: from-character</td>
</tr>
<tr>
<td>6</td>
<td>Transition: to-character</td>
</tr>
<tr>
<td>7</td>
<td>Transition: Goto-state</td>
</tr>
<tr>
<td>...</td>
<td>more triples follow for each transition</td>
</tr>
</table>

<p>
Example for a state machine that matches the regular expression <code>@[a-z0-9]+</code>
that has match 1 and no references:
</p>

<pre><code class="language-c">
8 0 0 0 3 64 64 2
11 1 0 0 3 48 57 1 97 122 1
11 0 0 0 3 48 57 1 97 122 1
</code></pre>

<p>
Interpretation:
</p>

<pre><code class="language-c">
00: col= 8 acc= 0 flg= 0 ref= 0 def= 3 tra=064(@);064(@):02
01: col=11 acc= 1 flg= 0 ref= 0 def= 3 tra=048(0);057(9):01 tra=097(a);122(z):01
02: col=11 acc= 0 flg= 0 ref= 0 def= 3 tra=048(0);057(9):01 tra=097(a);122(z):01
</code></pre>

<p>
A similar dump like this interpretation above will be printed to stderr by the
function when <i>dfatab</i> is provided as (long***)NULL.
</p>
<p>
The pointer assigned to <i>dfatab</i> must be freed after usage using a for-loop:
</p>

<pre><code class="language-c">
for( i = 0; i &lt; dfatab_cnt; i++ )
	pfree( dfatab[i] );

pfree( dfatab );
</code></pre>

<p>
Returns the number of rows in <i>dfatab</i>, or a negative value in error case.
</div>
<!-- NEED 22 -->
<div class='function'>
</p>

<h3 id="fn_pregex_ptn_to_nfa">pregex_ptn_to_nfa</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean pregex_ptn_to_nfa( pregex_nfa* nfa, <a href="#pregex_ptn">pregex_ptn</a>* ptn )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Converts a pattern-structure into a NFA state machine.
</p>
<p>
<i>nfa</i> is the NFA state machine structure that receives the compiled result of
the pattern. This machine will be extended to the pattern if it already contains
states. <i>nfa</i> must be previously initialized!
</p>
<p>
<i>ptn</i> is the pattern structure that will be converted and extended into
the NFA state machine.
</p>
<p>
<i>flags</i> are compile-time flags.
</p>
<p>
Returns TRUE on success.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_pregex_ptn_to_regex">pregex_ptn_to_regex</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pregex_ptn_to_regex( <a href="#pregex_ptn">pregex_ptn</a>* ptn )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Turns a regular expression pattern back into a regular expression string.
</p>
<p>
<i>ptn</i> is the pattern object to be converted into a regex.
</p>
<p>
The returned pointer is dynamically allocated but part of <i>ptn</i>, so it should
not be freed by the caller. It is automatically freed when the pattern object
is released.
</div>
<!-- NEED 27 -->
<div class='function'>
</p>

<h3 id="fn_pregex_qmatch">pregex_qmatch</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int pregex_qmatch( char* regex, char* str, int flags, <a href="#parray">parray</a>** matches )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Performs a regular expression match on a string, and returns an array of
matches via <a href="#prange">prange</a>-structures, which hold pointers to the begin- and
end-addresses of all matches.
</p>
<p>
<i>regex</i> is the regular expression pattern to be processed.
</p>
<p>
<i>str</i> is the string on which the pattern will be executed.
</p>
<p>
<i>flags</i> are for regular expression compile- and runtime-mode switching.
Several of them can be used with the bitwise or-operator (|).
</p>
<p>
<i>matches</i> is the array of results to the matched substrings within <i>str</i>,
provided as <a href="#parray">parray</a>-object existing of one <a href="#prange">prange</a>-object for every match.
It is optional. <i>matches</i> must be released with <a href="#fn_parray_free">parray_free()</a> after its usage.
</p>
<p>
Returns the number of matches, which is the number of result entries in the
returned array <i>matches</i>. If the value is negative, an error occurred.
</div>
<!-- NEED 27 -->
<div class='function'>
</p>

<h3 id="fn_pregex_qreplace">pregex_qreplace</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pregex_qreplace( char* regex, char* str, char* replace, int flags )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Replaces all matches of a regular expression pattern within a string with
the replacement. Backreferences can be used with <code>$x</code> for each opening bracket
within the regular expression.
</p>
<p>
<i>regex</i> is the regular expression pattern to be processed.
</p>
<p>
<i>str</i> is the string on which the pattern will be executed.
</p>
<p>
<i>replace</i> is the string that will be inserted as replacement for each pattern
match. <code>$x</code> back-references can be used.
</p>
<p>
<i>flags</i> are for regular expression compile- and runtime-mode switching.
Several of them can be used with the bitwise or-operator (|).
</p>
<p>
Returns an allocated pointer to the generated string with the replacements.
This string must be released after its existence is no longer required by the
caller using <a href="#fn_pfree">pfree()</a>.
</div>
<!-- NEED 26 -->
<div class='function'>
</p>

<h3 id="fn_pregex_qsplit">pregex_qsplit</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int pregex_qsplit( char* regex, char* str, int flags, <a href="#parray">parray</a>** matches )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Performs a regular expression search on a string and uses the expression as
separator; All strings that where split are returned as <i>matches</i>-array.
</p>
<p>
<i>regex</i> is the regular expression pattern to be processed.
</p>
<p>
<i>str</i> is the string on which the pattern will be executed.
</p>
<p>
<i>flags</i> are for regular expression compile- and runtime-mode switching.
Several of them can be used with the bitwise or-operator (|).
</p>
<p>
<i>matches</i> is the array of results to the matched substrings within <i>str</i>,
provided as <a href="#parray">parray</a>-object existing of one <a href="#prange">prange</a>-object for every match.
It is optional. <i>matches</i> must be released with <a href="#fn_parray_free">parray_free()</a> after its usage.
</p>
<p>
Returns the number of split substrings, which is the number of result entries in
the returned array <i>matches</i>. If the value is negative, an error occured.
</div>
<!-- NEED 23 -->
<div class='function'>
</p>

<h3 id="fn_pregex_replace">pregex_replace</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pregex_replace( <a href="#pregex">pregex</a>* regex, char* str, char* replacement )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Replaces all matches of a regular expression object within a string <i>str</i>
with <i>replacement</i>. Backreferences in <i>replacement</i> can be used with <i>$x</i>
for each opening bracket within the regular expression.
</p>
<p>
<i>regex</i> is the <a href="#pregex">pregex</a>-object used for pattern matching.
<i>str</i> is the string on which <i>regex</i> will be executed.
<i>replacement</i> is the string that will be inserted as the replacement for each
match of a pattern described in <i>regex</i>. The notation <i>$x</i> can be used for
backreferences, where x is the offset of opening brackets in the pattern,
beginning at 1.
</p>
<p>
The function returns the string with the replaced elements, or (char*)NULL
in case of an error.
</div>
<!-- NEED 24 -->
<div class='function'>
</p>

<h3 id="fn_pregex_split">pregex_split</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pregex_split( <a href="#pregex">pregex</a>* regex, char* start, char** end, char** next )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Returns the range between string <i>start</i> and the next match of <i>regex</i>.
</p>
<p>
This function can be seen as a "negative match", so the substrings that are
not part of the match will be returned.
</p>
<p>
<i>start</i> has to be a zero-terminated string or wide-character string (according
to the configuration of the <a href="#pregex">pregex</a>-object).
<i>end</i> receives the last position of the string before the regex.
<i>next</i> receives the pointer of the next split element behind the matched
substring, so <i>next</i> should become the next <i>start</i> when <a href="#fn_pregex_split">pregex_split()</a> is
called in a loop.
</p>
<p>
The function returns (char*)NULL in case there is no more string to split, else
it returns <i>start</i>.
</div>
<!-- NEED 19 -->
<div class='function'>
</p>

<h3 id="fn_pregex_splitall">pregex_splitall</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int pregex_splitall( <a href="#pregex">pregex</a>* regex, char* start, <a href="#parray">parray</a>** matches )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Split a string at all matches of the regular expression <i>regex</i> from
begin of pointer <i>start</i>, and optionally returns the substrings found as an
array.
</p>
<p>
<i>start</i> has to be a zero-terminated string or wide-character string (according
to the configuration of the <a href="#pregex">pregex</a>-object).
</p>
<p>
The function fills the array <i>matches</i>, if provided, with items of size
prange. It returns the total number of matches.
</div>
<!-- NEED 23 -->
<div class='function'>
</p>

<h3 id="fn_pstr_to_wcs">pstr_to_wcs</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
wchar_t* pstr_to_wcs( char* str, <a href="#pboolean">pboolean</a> freestr )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
This functions converts an UTF-8-multi-byte string into a Unicode
wide-character string.
</p>
<p>
The function wraps <a href="#fn_mbstowcs">mbstowcs()</a>, so <a href="#fn_set_locale">set_locale()</a> must be done before this
function works properly.
</p>
<p>
<i>str</i> is the zero-terminated multi-byte-character string to be converted
into a wide-character string.
<i>freestr</i> if value equals TRUE then <i>str</i> will be freed after successfull
conversion.
</p>
<p>
Returns the wide-character pendant of <i>str</i> as pointer to dynamically
allocated memory.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_pstrcasecmp">pstrcasecmp</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int pstrcasecmp( char* s1, char* s2 )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Compare a string ignoring case-order.
</p>
<p>
<i>s1</i> is the string to compare with <i>s2</i>.
<i>s2</i> is the string to compare with <i>s1</i>.
</p>
<p>
Returns 0 if both strings are equal. Returns a value &lt;0 if <i>s1</i> is lower than
<i>s2</i> or a value &gt;0 if <i>s1</i> is greater than <i>s2</i>.
</div>
<!-- NEED 19 -->
<div class='function'>
</p>

<h3 id="fn_pstrcatchar">pstrcatchar</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pstrcatchar( char* str, char chr )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Dynamically appends a character to a string.
</p>
<p>
<i>str</i> is the pointer to a string to be appended. If this is (char*)NULL,
the string will be newly allocated. <i>chr</i> is the character to be appended
to str.
</p>
<p>
Returns a char*-pointer to the (possibly re-)allocated and appended string.
(char*)NULL is returned if no memory could be (re)allocated. This pointer must
be released with <a href="#fn_pfree">pfree()</a> when its existence is no longer required.
</div>
<!-- NEED 24 -->
<div class='function'>
</p>

<h3 id="fn_pstrcatstr">pstrcatstr</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pstrcatstr( char* dest, char* src, <a href="#pboolean">pboolean</a> freesrc )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Dynamically appends a zero-terminated string to a dynamic string.
</p>
<p>
<i>str</i> is the pointer to a zero-terminated string to be appended.
If this is (char*)NULL, the string is newly allocated.
</p>
<p>
<i>append</i> is the string to be appended at the end of <i>str</i>.
</p>
<p>
<i>freesrc</i> frees the pointer provided as <i>append</i> automatically by
this function, if set to TRUE.
</p>
<p>
Returns a char*-pointer to (possibly re-)allocated and appended string.
(char*)NULL is returned if no memory could be (re)allocated, or both strings
were NULL. If <i>dest</i> is NULL and <i>freesrc</i> is FALSE, the function
automatically returns the pointer <i>src</i>. This pointer must be released with <a href="#fn_pfree">pfree()</a> when its existence is no longer required.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_pstrdup">pstrdup</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pstrdup( char* str )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Duplicate a string in memory.
</p>
<p>
<i>str</i> is the string to be copied in memory. If <i>str</i> is provided as NULL,
the function will also return NULL.
</p>
<p>
Returns a char*-pointer to the newly allocated copy of <i>str</i>. This pointer
must be released with <a href="#fn_pfree">pfree()</a> when its existence is no longer required.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_pstrget">pstrget</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pstrget( char* str )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Safely reads a string.
</p>
<p>
<i>str</i> is the string pointer to be safely read. If <i>str</i> is NULL, the
function returns a pointer to a static address holding an empty string.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_pstrlen">pstrlen</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
size_t pstrlen( char* str )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Return length of a string.
</p>
<p>
<i>str</i> is the parameter string to be evaluated. If (char*)NULL, the function
returns 0. <a href="#fn_pstrlen">pstrlen()</a> is much safer than <a href="#fn_strlen">strlen()</a> because it returns 0 when
a NULL-pointer is provided.
</p>
<p>
Returns the length of the string <i>str</i>.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_pstrltrim">pstrltrim</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pstrltrim( char* s )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Removes whitespace on the left of a string.
</p>
<p>
<i>s</i> is the string to be left-trimmed.
</p>
<p>
Returns <i>s</i>.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_pstrlwr">pstrlwr</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pstrlwr( char* s )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Convert a string to lower-case.
</p>
<p>
<i>s</i> is the acts both as input and output-string.
</p>
<p>
Returns <i>s</i>.
</div>
<!-- NEED 18 -->
<div class='function'>
</p>

<h3 id="fn_pstrncasecmp">pstrncasecmp</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int pstrncasecmp( char* s1, char* s2, size_t n )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Compare two strings ignoring case-order up to a maximum of <i>n</i> bytes.
</p>
<p>
<i>s1</i> is the string to compare with <i>s2</i>.
<i>s2</i> is the string to compare with <i>s1</i>.
<i>n</i> is the number of bytes to compare.
</p>
<p>
Returns 0 if both strings are equal. Returns a value &lt;0 if <i>s1</i> is less than
<i>s2</i> or a value &gt;0 if <i>s1</i> is greater than <i>s2</i>.
</div>
<!-- NEED 23 -->
<div class='function'>
</p>

<h3 id="fn_pstrncatstr">pstrncatstr</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pstrncatstr( char* str, char* append, size_t n )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Dynamically appends n-characters from one string to another string.
</p>
<p>
The function works similar to <a href="#fn_pstrcatstr">pstrcatstr()</a>, but allows to copy only a maximum
of <i>n</i> characters from <i>append</i>.
</p>
<p>
<i>str</i> is the pointer to a string to be appended. If this is (char*)NULL,
the string is newly allocated. <i>append</i> is the begin of character sequence to
be appended. <i>n</i> is the number of characters to be appended to <i>str</i>.
</p>
<p>
Returns a char*-pointer to (possibly re-)allocated and appended string.
(char*)NULL is returned if no memory could be (re)allocated, or both strings
were NULL. This pointer must be released with <a href="#fn_pfree">pfree()</a> when its existence
is no longer required.
</div>
<!-- NEED 24 -->
<div class='function'>
</p>

<h3 id="fn_pstrndup">pstrndup</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pstrndup( char* str, size_t len )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Duplicate <i>n</i> characters from a string in memory.
</p>
<p>
The function mixes the functionalities of <a href="#fn_strdup">strdup()</a> and <a href="#fn_strncpy">strncpy()</a>.
The resulting string will be zero-terminated.
</p>
<p>
<i>str</i> is the parameter string to be duplicated. If this is provided as
(char*)NULL, the function will also return (char*)NULL.
<i>n</i> is the number of characters to be copied and duplicated from <i>str</i>.
If <i>n</i> is greater than the length of <i>str</i>, copying will stop at the zero
terminator.
</p>
<p>
Returns a char*-pointer to the allocated memory holding the zero-terminated
string duplicate. This pointer must be released with <a href="#fn_pfree">pfree()</a> when its existence
is no longer required.
</div>
<!-- NEED 23 -->
<div class='function'>
</p>

<h3 id="fn_pstrput">pstrput</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pstrput( char** str, char* val )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Assign a string to a dynamically allocated pointer.
 <a href="#fn_pstrput">pstrput()</a> manages the assignment of a dynamically allocated string.
</p>
<p>
<i>str</i> is a pointer receiving the target pointer to be (re)allocated. If
<i>str</i> already references a string, this pointer will be freed and reassigned
to a copy of <i>val</i>.
</p>
<p>
<i>val</i> is the string to be assigned to <i>str</i> (as a independent copy).
</p>
<p>
Returns a pointer to the allocated heap memory on success, (char*)NULL else.
This is the same pointer as returned when calling <code>*str</code>. The returned pointer
must be released with <a href="#fn_pfree">pfree()</a> or another call of <a href="#fn_pstrput">pstrput()</a>. Calling <a href="#fn_pstrput">pstrput()</a>
as <code>pstrput( &amp;p, (char*)NULL );</code> is equivalent to <code>p = pfree( &amp;p )</code>.
</div>
<!-- NEED 29 -->
<div class='function'>
</p>

<h3 id="fn_pstrrender">pstrrender</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pstrrender( char* tpl, ... )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
String rendering function.
</p>
<p>
Inserts multiple values dynamically into the according wildcards positions of
a template string. The function can be compared to the function of <a href="#fn_pstrreplace">pstrreplace()</a>, but allows to replace multiple substrings by multiple replacement
strings.
</p>
<p>
<i>tpl</i> is the template string to be rendered with values.
<i>...</i> are the set of values to be inserted into the desired position;
</p>
<p>
These consist of three values each:
</p>

<ul>
<li><i>char* name</i> as a wildcard-name
</li>
<li><i>char* value</i> as the replacement value for the wildcard
</li>
<li><i><a href="#pboolean">pboolean</a> freeflag</i> defines if <i>value</i> shall be freed after processing
</li>
</ul>

<p>
Returns an allocated string which is the result of rendering. This string must
be released by <a href="#fn_pfree">pfree()</a> or another function releasing heap memory when its
existence is no longer required.
</div>
<!-- NEED 21 -->
<div class='function'>
</p>

<h3 id="fn_pstrreplace">pstrreplace</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pstrreplace( char* str, char* find, char* replace )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Replace a substring sequence within a string.
</p>
<p>
<i>str</i> is the string to be replaced in. <i>find</i> is the substring to be
matched. <i>replace</i> is the string to be inserted for each match of the
substring <i>find</i>.
</p>
<p>
Returns a char* containing the allocated string which is the result of replacing
all occurences of <i>find</i> with <i>replace</i> in <i>str</i>.
</p>
<p>
This pointer must be released with <a href="#fn_pfree">pfree()</a> when its existence is no longer
required.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_pstrrtrim">pstrrtrim</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pstrrtrim( char* s )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Removes trailing whitespace on the right of a string.
</p>
<p>
<i>s</i> is the string to be right-trimmed.
</p>
<p>
Returns <i>s</i>.
</div>
<!-- NEED 21 -->
<div class='function'>
</p>

<h3 id="fn_pstrsplit">pstrsplit</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int pstrsplit( char*** tokens, char* str, char* sep, int limit )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Splits a string at a delimiting token and returns an allocated array of
token reference pointers.
</p>
<p>
<i>tokens</i> is an allocated array of tokenized array values.
Requires a pointer to char**.
<i>str</i> is the input string to be tokenized.
<i>sep</i> is the token separation substring.
<i>limit</i> is the token limit; If set to 0, there is no token limit available,
in which case as many as possible tokens are read.
</p>
<p>
Returns the number of separated tokens, or -1 on error.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_pstrtrim">pstrtrim</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pstrtrim( char* s )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Removes beginning and trailing whitespace from a string.
</p>
<p>
<i>s</i> is the string to be trimmed.
</p>
<p>
Returns <i>s</i>.
</div>
<!-- NEED 40 -->
<div class='function'>
</p>

<h3 id="fn_pstrunescape">pstrunescape</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pstrunescape( char* str )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Converts a string with included escape-sequences back into its natural form.
</p>
<p>
The following table shows escape sequences which are converted.
</p>

<table border="1">
<tr>
<th>Sequence</th>
<th>is replaced by</th>
</tr>
<tr>
<td>\n</td>
<td>newline</td>
</tr>
<tr>
<td>\t</td>
<td>tabulator</td>
</tr>
<tr>
<td>\r</td>
<td>carriage-return</td>
</tr>
<tr>
<td>\b</td>
<td>backspace</td>
</tr>
<tr>
<td>\f</td>
<td>form feed</td>
</tr>
<tr>
<td>\a</td>
<td>bell / alert</td>
</tr>
<tr>
<td>\'</td>
<td>single-quote</td>
</tr>
<tr>
<td>\"</td>
<td>double-quote</td>
</tr>
</table>

<p>
The replacement is done within the memory bounds of <i>str</i> itself, because the
unescaped version of the character requires less space than its previous escape
sequence.
</p>
<p>
The function always returns its input pointer.
</p>
<p>
<b>Example:</b>
</p>

<pre><code class="language-c">
char* s = (char*)NULL;

psetstr( &amp;s, "\\tHello\\nWorld!" );
printf( "&gt;%s&lt;\n", pstrunescape( s ) );

s = pfree( s );
</code></pre>

</div>
<!-- NEED 15 -->
<div class='function'>

<h3 id="fn_pstrupr">pstrupr</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pstrupr( char* s )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Convert a string to upper-case.
</p>
<p>
<i>s</i> acts both as input- and output string.
</p>
<p>
Returns <i>s</i>.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_putf8_char">putf8_char</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
wchar_t putf8_char( char* str )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Return single character (as wide-character value) from UTF-8 multi-byte
character string.
</p>
<p>
<i>str</i> is the pointer to character sequence begin.
</div>
<!-- NEED 14 -->
<div class='function'>
</p>

<h3 id="fn_putf8_isutf">putf8_isutf</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
pboolean putf8_isutf( unsigned char c )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Check for UTF-8 character sequence signature.
</p>
<p>
The function returns TRUE, if the character <i>c</i> is the beginning of a UTF-8
character signature, else FALSE.
</div>
<!-- NEED 18 -->
<div class='function'>
</p>

<h3 id="fn_putf8_move">putf8_move</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* putf8_move( char* str, int count )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Moves <i>count</i> characters ahead in an UTF-8 multi-byte character sequence.
</p>
<p>
<i>str</i> is the pointer to UTF-8 string to begin moving.
<i>count</i> is the number of characters to move left.
</p>
<p>
The function returns the address of the next UTF-8 character sequence after
<i>count</i> characters. If the string's end is reached, it will return a
pointer to the zero-terminator.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_putf8_parse_char">putf8_parse_char</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
wchar_t putf8_parse_char( char** ch )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Read one character from an UTF-8 input sequence.
This character can be escaped, an UTF-8 character or an ordinary ASCII-char.
</p>
<p>
<i>chr</i> is the input- and output-pointer (the pointer is replaced by the pointer
to the next character or escape-sequence within the string).
</p>
<p>
The function returns the character code of the parsed character.
</div>
<!-- NEED 15 -->
<div class='function'>
</p>

<h3 id="fn_putf8_seqlen">putf8_seqlen</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int putf8_seqlen(char *s)
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Returns length of next UTF-8 sequence in a multi-byte character string.
</p>
<p>
<i>s</i> is the pointer to begin of UTF-8 sequence.
</p>
<p>
Returns the number of bytes used for the next character.
</div>
<!-- NEED 17 -->
<div class='function'>
</p>

<h3 id="fn_pvasprintf">pvasprintf</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int pvasprintf( char** str, char* fmt, va_list ap )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Implementation and replacement for vasprintf.
</p>
<p>
<i>str</i> is the pointer receiving the result, allocated string pointer.
<i>fmt</i> is the format string.
<i>...</i> are the parameters according to the placeholders set in <i>fmt</i>.
</p>
<p>
Returns the number of characters written, or -1 in case of an error.
</div>
<!-- NEED 19 -->
<div class='function'>
</p>

<h3 id="fn_pvawcsprintf">pvawcsprintf</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
int pvawcsprintf( wchar_t** str, wchar_t* fmt, va_list ap )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Wide-character implementation of <a href="#fn_pasprintf">pasprintf()</a>.
</p>
<p>
<i>str</i> is the a pointer receiving the resultung, allocated string pointer.
<i>fmt</i> is the the format string.
<i>...</i> is the parameters according to the placeholders set in <i>fmt</i>.
</p>
<p>
Returns the number of characters written.
</p>
<p>
<i>This function is only available when compiled with -DUNICODE.</i>
</div>
<!-- NEED 22 -->
<div class='function'>
</p>

<h3 id="fn_pwcs_to_str">pwcs_to_str</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pwcs_to_str( wchar_t* str, <a href="#pboolean">pboolean</a> freestr )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
This functions converts a wide-character string into an UTF-8 string.
</p>
<p>
The string conversion is performed into dynamically allocated memory.
The function wraps the system function <a href="#fn_wcstombs">wcstombs()</a>, so <a href="#fn_set_locale">set_locale()</a> must be
called before this function works properly.
</p>
<p>
<i>str</i> is the zero-terminated string to be converted to UTF-8.
<i>freestr</i> defines if the input-string shall be freed after successful
conversion, if set to TRUE.
</p>
<p>
Returns the UTF-8 character pendant of <i>str</i> as pointer to dynamically
allocated memory.
</div>
<!-- NEED 20 -->
<div class='function'>
</p>

<h3 id="fn_pwcscatchar">pwcscatchar</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
wchar_t* pwcscatchar( wchar_t* str, wchar_t chr )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Appends a character to a dynamic wide-character string.
</p>
<p>
<i>str</i> is the pointer to a wchar_t-string to be appended. If this is
(wchar_t*)NULL, the string is newly allocated. <i>chr</i> is the the character
to be appended to str.
</p>
<p>
Returns a wchar_t* Pointer to (possibly re-)allo- cated and appended string.
(wchar_t*)NULL is returned if no memory could be (re)allocated.
</p>
<p>
<i>This function is only available when compiled with -DUNICODE.</i>
</div>
<!-- NEED 23 -->
<div class='function'>
</p>

<h3 id="fn_pwcscatstr">pwcscatstr</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
wchar_t* pwcscatstr( wchar_t* dest, wchar_t* src, <a href="#pboolean">pboolean</a> freesrc )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Appends a (possibly dynamic) wide-character string to a dynamic
wide-character string.
</p>
<p>
<i>str</i> is the pointer to a wchar_t-string to be appended. If this is
(wchar_t*)NULL, the string is newly allocated.
<i>append</i> is the string to be appended.
<i>freesrc</i> if true, <i>append</i> is free'd automatically by this function.
</p>
<p>
Returns a wchar_t* Pointer to (possibly re-)allo- cated and appended string.
(wchar_t*)NULL is returned if no memory could be (re)allocated, or both strings
were NULL.
</p>
<p>
<i>This function is only available when compiled with -DUNICODE.</i>
</div>
<!-- NEED 19 -->
<div class='function'>
</p>

<h3 id="fn_pwcsdup">pwcsdup</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
wchar_t* pwcsdup( wchar_t* str )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Duplicate a wide-character string in memory.
</p>
<p>
<i>str</i> is the string to be copied in memory. If <i>str</i> is provided as NULL,
the function will also return NULL.
</p>
<p>
Returns a wchar_t*-pointer to the newly allocated copy of <i>str</i>. This pointer
must be released with <a href="#fn_pfree">pfree()</a> when its existence is no longer required.
</p>
<p>
<i>This function is only available when compiled with -DUNICODE.</i>
</div>
<!-- NEED 16 -->
<div class='function'>
</p>

<h3 id="fn_pwcsget">pwcsget</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
wchar_t* pwcsget( wchar_t* str )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Safely reads a wide-character string.
</p>
<p>
<i>str</i> is the string pointer to be safely read. If <i>str</i> is NULL, the
function returns a pointer to a static address holding an empty string.
</p>
<p>
<i>This function is only available when compiled with -DUNICODE.</i>
</div>
<!-- NEED 16 -->
<div class='function'>
</p>

<h3 id="fn_pwcslen">pwcslen</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
size_t pwcslen( wchar_t* str )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Safe strlen replacement for wide-character.
</p>
<p>
<i>str</i> is the parameter string to be evaluated. If (wchar_t*)NULL,
the function returns 0.
</p>
<p>
<i>This function is only available when compiled with -DUNICODE.</i>
</div>
<!-- NEED 22 -->
<div class='function'>
</p>

<h3 id="fn_pwcsncatstr">pwcsncatstr</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
wchar_t* pwcsncatstr( wchar_t* str, wchar_t* append, size_t n )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Appends <i>n</i> characters from one wide-character string to a dynamic string.
</p>
<p>
<i>str</i> is the pointer to a wchar_t-string to be appended. If this is
(wchar_t*)NULL, the string is newly allocated.
<i>append</i> is the begin of character sequence to be appended.
<i>n</i> is the number of characters to be appended to str.
</p>
<p>
Returns a wchar_t* Pointer to (possibly re-)allo- cated and appended string.
(wchar_t*)NULL is returned if no memory could be (re)allocated, or both strings
were NULL.
</p>
<p>
<i>This function is only available when compiled with -DUNICODE.</i>
</div>
<!-- NEED 28 -->
<div class='function'>
</p>

<h3 id="fn_pwcsndup">pwcsndup</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
wchar_t* pwcsndup( wchar_t* str, size_t len )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Duplicate <i>n</i> characters from a wide-character string in memory.
</p>
<p>
The function mixes the functionalities of <a href="#fn_wcsdup">wcsdup()</a> and <a href="#fn_wcsncpy">wcsncpy()</a>.
The resulting wide-character string will be zero-terminated.
</p>
<p>
<i>str</i> is the parameter wide-character string to be duplicated.
If this is provided as (wchar_t*)NULL, the function will also return
(wchar_t*)NULL.
</p>
<p>
<i>n</i> is the the number of characters to be copied and duplicated from <i>str</i>.
If <i>n</i> is greater than the length of <i>str</i>, copying will stop at the zero
terminator.
</p>
<p>
Returns a wchar_t*-pointer to the allocated memory holding the zero-terminated
wide-character string duplicate. This pointer must be released with <a href="#fn_pfree">pfree()</a>
when its existence is no longer required.
</p>
<p>
<i>This function is only available when compiled with -DUNICODE.</i>
</div>
<!-- NEED 27 -->
<div class='function'>
</p>

<h3 id="fn_pwcsput">pwcsput</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
wchar_t* pwcsput( wchar_t** str, wchar_t* val )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Assign a wide-character string to a dynamically allocated pointer.
 <a href="#fn_pwcsput">pwcsput()</a> manages the assignment of an dynamically allocated  wide-chararacter
string.
</p>
<p>
<i>str</i> is a pointer receiving the target pointer to be (re)allocated. If
<i>str</i> already references a wide-character string, this pointer will be freed
and reassigned to a copy of <i>val</i>.
</p>
<p>
<i>val</i> is the the wide-character string to be assigned to <i>str</i>
(as an independent copy).
</p>
<p>
Returns a pointer to the allocated heap memory on success, (char_t*)NULL else.
This is the same pointer as returned when calling <code>*str</code>. The returned pointer
must be released with <a href="#fn_pfree">pfree()</a> or another call of <a href="#fn_pwcsput">pwcsput()</a>. Calling <a href="#fn_pwcsput">pwcsput()</a>
as <code>pwcsput( &amp;p, (char*)NULL );</code> is equivalent to <code>p = pfree( &amp;p )</code>.
</p>
<p>
<i>This function is only available when compiled with -DUNICODE.</i>
</div>
<!-- NEED 22 -->
<div class='function'>
</p>

<h3 id="fn_pwhich">pwhich</h3>

<p>
<b>Definition:</b>
</p>
<div class='definition'>
<p>
char* pwhich( char* filename, char* directories )
</div>
</p>
<p>
<b>Usage:</b>
</p>
<p>
Figures out a filepath by searching in a PATH definition.
</p>
<p>
<i>filename</i> is the filename to be searched for.
</p>
<p>
<i>directories</i> is a string specifying the directories to search in.
If this is (char*)NULL, the environment variable PATH will be used and
evaluated by using  <a href="#fn_getenv">getenv()</a> #fn_getenv]. The path can be split with multiple
paths by a character that depends on the current platform
(Unix: ":", Windows: ";").
</p>
<p>
Returns a static pointer to the absolute path that contains the file specified
as filename, else it will return (char*)NULL.
</div>
</p>
</div>

<!-- xhtml code generated by txt2tags 2.6. (http://txt2tags.org) -->
<!-- cmdline: txt2tags -o phorward.html -t xhtml -\-toc -\-css-sugar -\-style=phorward.css phorward.t2t -->
</body></html>
