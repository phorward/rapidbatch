<html>
	<head>
		<title>Writing and reading files</title>
		<link rel="stylesheet" href="jmksf.css" type="text/css"></link>
	</head>

	<body>
		<div id="top">
			<img src="rb5.png" alt="RapidBATCH Logo" />
			Writing and reading files
		</div>
		
		<div class="line">&nbsp;</div>
		
		To read and write files, RapidBATCH provides you four versatile, easy to use instructions and functions which can be used for text- as well as binary-oriented file operations.<br /><br />To write and save data to text files, RapidBATCH provides the WRITEFILE-instruction. WRITEFILE expects as parameters a filename and the value that should be written, where each operation that is done using WRITEFILE is one line in a text file.<br /><br />A simple case study is the following line of code:<br /><br /><!-- code BEGIN --><div class="code">writefile <font color="#0000ff">'hello.txt'</font>, <font color="#0000ff">'This is a text we write into a text file.'</font></div><!-- code END-->WRITEFILE appends the content of the file each time it is called automatically, that means the value that is written to the file is automatically appended to the file's end. A line break is automatically done behind the value that is written each time WRITEFILE is called. If the file WRITEFILE should write is not existing, it is automatically created, and the value will be written to the first line of the file, at the beginning.<br /><br />When we run the following code...<br /><br /><!-- code BEGIN --><div class="code">writefile <font color="#0000ff">'test.txt'</font>, <font color="#0000ff">'The quick brown fox'</font><br />writefile <font color="#0000ff">'test.txt'</font>, <font color="#0000ff">'jumps over'</font><br />writefile <font color="#0000ff">'test.txt'</font>, <font color="#0000ff">'the lazy dog.'</font></div><!-- code END-->...TEST.TXT will get the content:<br /><br /><!-- code BEGIN --><div class="code"><b><font color="#000000">The quick brown fox<br />jumps over<br />the lazy dog.<br /></font></b></div><!-- code END-->To read out the file again, RapidBATCH is providing the function READFILE, that you surely already learned to know in the previous chapters shortly. READFILE is likewise used to read text files, because it reads a file line by line. Parameters are the filename of the file that should be opened and read, and the line-number that should be read and returned.<br />The following script tells us the first line of the evenly created file TEST.TXT.<br /><br /><!-- code BEGIN --><div class="code">readfile <font color="#000080">[line]</font> = <font color="#0000ff">'test.txt'</font>, <font color="#0000ff">'1'</font><br />echo <font color="#0000ff">'The first line of TEST.TXT is: '</font> # <font color="#000080">[line]</font></div><!-- code END-->To read the whole file now line-by-line, READFILE has to be called in a loop, where a counting variable is incremented in each loop. Here, we use the variable [i] as line counter. If a line number is specified at READFILE that does not exist, the value &quot;EOF&quot; is returned as value, meaning &quot;End Of File&quot;. Additionally, [errorcode] (that always is set to '0' if the line was read successfully) is set to '-1' if the file's end is reached.<br /><br /><!-- code BEGIN --><div class="code"><font color="#000080">[i]</font> = <font color="#0000ff">'0'</font><br /><b>repeat</b><br /><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem increment [i] to 1</font><br />&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> + <font color="#0000ff">'1'</font><br /><br /><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem read line number [i]</font><br />&nbsp;&nbsp;&nbsp;&nbsp;readfile <font color="#000080">[line]</font> = <font color="#0000ff">'test.txt'</font>, <font color="#000080">[i]</font><br /><br /><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem display the read line</font><br />&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Content of line '</font> # <font color="#000080">[i]</font> # <font color="#0000ff">' is: '</font> # <font color="#000080">[line]</font><br /><b>until</b> <font color="#000080">[line]</font> = <font color="#0000ff">'EOF'</font> &amp; <font color="#000080">[errorcode]</font> = <font color="#0000ff">'-1'</font></div><!-- code END--><!--<div class="remark">If the script is executed on the file TEST.TXT we created with three lines, you will notice that a forth, empty line is read, before READFILE tells us that it reached the file's end at line five. The reason for this is that WRITEFILE has already appended a new line break behind our third line, so that TEST.TXT contains a number of four lines instead of the three written ones.</div>-->The READFILE-function is also able to read a file in one go, that means it can read a whole text file and returns it to a variable. This possibility is given when the value '0' (or a lower value than '0') is specified as the line number parameter to READFILE. In such a case, the whole file's content is returned.<br /><br /><!-- code BEGIN --><div class="code">readfile <font color="#000080">[file]</font> = <font color="#0000ff">'test.txt'</font>, <font color="#0000ff">'0'</font><br />echo <font color="#0000ff">'Content of TEST.TXT:'</font> # <font color="#000080">[new_line]</font> # <font color="#000080">[new_line]</font> # <font color="#000080">[file]</font></div><!-- code END-->The above script does also use the pre-declared variable [new_line] to insert two line breaks within the ECHO-message, before displaying the content of the file.<br /><br />Both READFILE and WRITEFILE assign values to the variable [errorcode]. [errorcode] gets '-1' if a file could not be created at WRITEFILE or if the disk is full. '-1' is assigned to [errorcode] at READFILE if the file could not be opend or EOF has been reached. If all is fine and no errors occured, [errorcode] gets '0'.<br /><br />RapidBATCH is also able to work on files using the binary method, since version 5.0. For such cases, the instruction PUTFILE and the function GETFILE is provided for writing and reading files in binary-method. As binary files, all files that are no plain text files, are defined. Even Office-Files like DOC or XLS are no plain text files, it are even binary files!<br />But however, in the next examples, we will write and read text files again, but now on a binary basis. As a matter of course, it is also possible to write and read any desired character, including control characters and characters from the extended ASCII-character table to or from a file.<br /><br />To write a file (which can also be a text file!) in binary mode, we use the already mentioned PUTFILE-instruction. PUTFILE can only write to existing files. If the file does not exist, it must be created explicitly using NEWFILE.<div class="remark">ASCII is an abbreviation for &quot;American Standard Code for Information Interchange&quot;. The standard ASCII code table exists of at least 128 so called &quot;ASCII characters&quot;. Not every of these characters is printable, so that only 96 of them can really be displayed. RapidBATCH does also support the extended ASCII-table character set, so that at least 256 characters can be displayed. These additional 128 characters contain special characters like umlauts, currency symbols, and more. Each of these character has a number from 0 to 256, the so called &quot;ASCII-code&quot;, which can be specified.</div>The following example saves the text &quot;Hello World&quot; in binary to the file BINARY.TXT. Next to the filename of the file PUTFILE should write to, it expects as second parameter the byte-offset (as offset, a position of bytes from the beginning of the file is meaned) where the writing operation should start within the file, and as third parameter a list of ASCII-character codes that should be written. This list contains only the numerical ASCII codes of each character that should be written, not the character itself. Each character has to be seperated from the others using the RapidBATCH default list separator defined in the pre-declared variable [std_sep]. By default, this is the pipe-character &quot;|&quot; as it is used in the example below.<br /><br /><!-- code BEGIN --><div class="code">newfile <font color="#0000ff">'binary.txt'</font><br />putfile <font color="#0000ff">'binary.txt'</font>, <font color="#0000ff">'1'</font>, <font color="#0000ff">'72|101|108|108|111|32|87|111|114|108|100'</font><br />open <font color="#0000ff">'binary.txt'</font></div><!-- code END-->In this case, we inserted 11 bytes to the file, where one byte (8 bits) is one ASCII-character.<div class="remark">Note: To convert plain text to a list of ASCII character codes, use the following script I also used for myself to create the examples in this manual:<br /><br /><!-- code BEGIN --><div class="code">inputbox <font color="#000080">[plain]</font> = <font color="#0000ff">'Plain text'</font>, <font color="#0000ff">'Please enter a value that should be converted'</font>, <font color="#0000ff">''</font><br /><b>if</b> <font color="#000080">[plain]</font> = <font color="#0000ff">''</font> <b>halt</b><br /><br /><font color="#000080">[i]</font> = <font color="#0000ff">'0'</font><br />getlen <font color="#000080">[len]</font> = <font color="#000080">[plain]</font><br /><font color="#000080">[list]</font> = <font color="#0000ff">''</font><br /><b>repeat</b><br />&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> + <font color="#0000ff">'1'</font><br />&nbsp;&nbsp;&nbsp;&nbsp;getcharat <font color="#000080">[char]</font> = <font color="#000080">[plain]</font>, <font color="#000080">[i]</font><br />&nbsp;&nbsp;&nbsp;&nbsp;getasc <font color="#000080">[char]</font> = <font color="#000080">[char]</font><br />&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[list]</font> ! <font color="#0000ff">''</font> <font color="#000080">[list]</font> # <font color="#000080">[std_sep]</font><br />&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[list]</font> # <font color="#000080">[char]</font><br /><b>until</b> <font color="#000080">[i]</font> = <font color="#000080">[len]</font><br /><br /><font color="#000080">[clipboard]</font> = <font color="#000080">[list]</font><br />echo <font color="#0000ff">'The text was converted to a list of ascii-codes and copied to the clipboard.'</font><br /><b>end</b></div><!-- code END--></div>Now, it is also possible to continue writing the file directly at another byte-offset, let's use offset 100:<br /><br /><!-- code BEGIN --><div class="code"><font color="#808080">rem text: "To be continued..."</font><br /><font color="#000080">[text]</font> = <font color="#0000ff">'84|111|32|98|101|32|99|111|110|116|105|110|117|101|100|46|46|46'</font><br /><br /><font color="#808080">rem saving the text to offset 100 in the file "binary.txt"</font><br />putfile <font color="#0000ff">'binary.txt'</font>, <font color="#0000ff">'100'</font>, <font color="#000080">[text]</font></div><!-- code END-->Sure, these lists of ASCII character code-values are not that easy to encode, but please remind that we're currently programming on the core RapidBATCH language without any customization. To use the binary operations more easier, it is recommended to write functions and procedures converting plain texts to ASCII lists, which can be adapted from the above converter script.<br /><br />When we run the above script next to the first one, the file BINARY.TXT looks like the following when it is viewed using a hex-editor:<br /><div class="image"><img src="img/hexview_binary.gif" title="Content of the file BINARY.TXT in a hex-editor."/><br />Content of BINARY.TXT using a hex-editor.</div>Obviously, the second writing operation, beginning at hex-offset 64 (which is offset 100 in decimal), can be recognized. The area between our first &quot;Hello World&quot; and our second text, &quot;To be continued...&quot;, is filled with ASCII-code 0.<div class="remark">WARNING: On Windows 95, 98 and Millenium Edition (= any FAT or FAT-derivative file systems formatted drives) it was noticed that the content of deleted or overwritten files on the hard disk can become visible when starting a binary write anywhere within a file. On NTFS formatted drives, this phenomen was not noticed yet. To avoid this problem, fill out every byte until the desired position with ASCII code '0' or any other, desired character.</div>Please note, that PUTFILE does not do an append to a file like WRITEFILE, it stores its value to the specified offset, and overwrites existing values without any warning.<br /><br /><br />Reading a file in binary-mode is nearly the same way like writing it, using the GETFILE-function. GETFILE expects the path of the file that should be read, the starting-offset where the reading operation in the file should begin and a number of bytes, that should be read. Return value is, equivalently to the third parameter of PUTFILE, a list of ASCII character-codes, where each ASCII-code is seperated by the RapidBATCH default separator.<brThis list can be converted again to plain text (if required) using the GETCHR-function to convert a numerical ASCII-code value into a plain text character, like in the example script below that reads the text &quot;continued&quot; from the file we wrote above.<br /><br /><!-- code BEGIN --><div class="code"><font color="#808080">rem read the data from the file</font><br />getfile <font color="#000080">[data]</font> = <font color="#0000ff">'binary.txt'</font>, <font color="#0000ff">'100'</font> + <font color="#0000ff">'6'</font>, <font color="#0000ff">'9'</font><br />echo <font color="#0000ff">'Read list of ascii-codes: '</font> # <font color="#000080">[data]</font><br /><br /><font color="#808080">rem convert ascii-codes to ascii-characters</font><br /><font color="#000080">[i]</font> = <font color="#0000ff">'0'</font><br /><b>repeat</b><br />&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> + <font color="#0000ff">'1'</font><br />&nbsp;&nbsp;&nbsp;&nbsp;gettok <font color="#000080">[char]</font> = <font color="#000080">[data]</font>, <font color="#000080">[std_sep]</font>, <font color="#000080">[i]</font><br />&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[char]</font> ! <font color="#0000ff">''</font><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getchr <font color="#000080">[char]</font> = <font color="#000080">[char]</font><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[plain]</font> # <font color="#000080">[char]</font><br />&nbsp;&nbsp;&nbsp;&nbsp;<b>endif</b><br /><b>until</b> <font color="#000080">[char]</font> = <font color="#0000ff">''</font><br /><br /><font color="#808080">rem show the plain text</font><br />echo <font color="#0000ff">'Plain text: '</font> # <font color="#000080">[plain]</font><br /><b>end</b></div><!-- code END-->Here, we read &quot;continued&quot; only by specifing the reading operation start offset to 106 because at offset 106, the word &quot;continued&quot; begins, and tell GETFILE, that 9 bytes from offset 106 should be read. The result is the string we wanted to get from the file!<br />If the offset values specified at GETFILE are huger that the file's size, an empty string or the characters until the file's end are returned by the function.<br /><br /><br /><u>Why only text files in these examples?</u><br />Surely you asked yourself why we only write text files in binary mode in the above examples. For sure, only writing text files is not the sense and purpose of binary file operations, but I think that writing text files is a great lesson to get a feeling for writing files on binary basis. It is easier to write plain texts binary than writing or reading any cryptic characters to or from a file. PUTFILE and GETFILE lets you fully control a file, every information can be written and read. I guarantee you that you will use WRITEFILE and READFILE for the most file access operations, not only because they are easier to handle, but if you reach their limits, you can continue by using PUTFILE and GETFILE.<br /><br />

		<div class="line">&nbsp;</div>

		<div id="copyright">
			Copyright &copy; 2000-2006 by J.M.K S.F. Software Technologies, Jan Max Meyer<br />
			All rights reserved.
		</div>
	</body>
</html>
