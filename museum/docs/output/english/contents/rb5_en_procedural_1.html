<html>
	<head>
		<title>Procedures and Functions</title>
		<link rel="stylesheet" href="jmksf.css" type="text/css"></link>
	</head>

	<body>
		<div id="top">
			<img src="rb5.png" alt="RapidBATCH Logo" />
			Procedures and Functions
		</div>
		
		<div class="line">&nbsp;</div>
		
		One of the most effective features that comes with RapidBATCH's new version 5.0 is the introduction of user-defineable procedures and functions, a feature, that is very essencial for writing structured programs.<br /><br />Procedures are making it possible to break larger computing tasks into much smaller ones, and allow the script-programmer the creation of re-useable program routines that are defined once and can be used then wherever they are needed.<br />Procedures are once defined within a script, then they can be used like any of the existing build-in instructions and functions RapidBATCH provides. Because of that it is suggestive to define all wanted procedures and functions at the beginning of each RapidBATCH-script. Are the same procedures used in different scripts, it is recommended to define them into a library that is imported to all scripts expecting them, using the INCLUDE-instruction.<br /><br />A simple procedure (without return value) is prefaced using the PROC-statement. Behind this statement, the name of the new procedure is specified. This name may not contain any blanks or special characters, but can be any desired name, except RapidBATCH build-in statements or function names. Behind this name, an optional parameter variable list can be defined, seperated by a colon (:) that is set directly behind the procedure name. Each parameter variable is seperated again by a comma, as it is known from the DEC-statement. If no parameter variable is specified, the procedure is parameterless. In this case, the colon behind the procedure name is not required.<br />The next line behind the PROC-statement does already belong to the new procedure. This is the code that will be executed when the procedure is called. To close the procedure's code, the ENDPROC-statement is used. ENDPROC closes the procedure, and ordinary script-code or the next procedure/function-definition can follow.<br /><br />A simple example for implementing a procedure is the following script. It defines the parameter-less procedure &quot;test&quot;, that simply outputs a messagebox. After its implementation, it is called.<br /><br /><!-- code BEGIN --><div class="code"><font color="#808080">rem demo script using a procedure</font><br /><b>proc</b> test<br />&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'This is the procedure TEST!'</font><br /><b>endproc</b><br /><br />echo <font color="#0000ff">'In front of the procedure call...'</font><br />test<br />echo <font color="#0000ff">'...behind the procedure call'</font><br />echo <font color="#0000ff">'And again...'</font><br />test<br /><b>end</b></div><!-- code END-->When a procedure using parameter variables should be defined, these parameters must be specified behind the PROC statement, as already mentioned above. All variables specified there are only declared at the procedure call, and will be removed from the memory when the procedure returns. This method is called &quot;local variable declaration&quot;, because these variables (and also all new variables declared within the procedure) are only existing at the time the procedure is executed. The difference between these &quot;local&quot; and the so called &quot;global&quot; variables we indirectly already learned to know will be discussed later in a more detailed way.<br /><br />A simple example for a procedure using parameters is the following script. It defines the procedure &quot;sum&quot; to sum up two values that are specified as parameters. The result of this addition will be displayed in a messagebox.<br /><br /><!-- code BEGIN --><div class="code"><font color="#808080">rem demo script using a procedure with parameters</font><br /><b>proc</b> sum: <font color="#000080">[value1]</font>, <font color="#000080">[value2]</font><br />&nbsp;&nbsp;&nbsp;&nbsp;<b>dec</b> <font color="#000080">[result]</font><br />&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[result]</font> = <font color="#000080">[value1]</font> + <font color="#000080">[value2]</font><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'The sum of '</font> # <font color="#000080">[value1]</font> # <font color="#0000ff">' and '</font> # <font color="#000080">[value2]</font> # <font color="#0000ff">' is '</font> # <font color="#000080">[result]</font><br /><b>endproc</b><br /><br /><font color="#808080">rem calling sum with constant parameter values</font><br />sum <font color="#0000ff">'7'</font>, <font color="#0000ff">'13'</font><br /><br /><font color="#808080">rem calling sum with variable parameter values</font><br />inputbox <font color="#000080">[a]</font> = <font color="#0000ff">'Value A:'</font>, <font color="#0000ff">'Please enter a number:'</font>, <font color="#0000ff">''</font><br /><b>if</b> <font color="#000080">[a]</font> = <font color="#0000ff">''</font> <b>halt</b><br />inputbox <font color="#000080">[b]</font> = <font color="#0000ff">'Value B:'</font>, <font color="#0000ff">'Please enter a number:'</font>, <font color="#0000ff">''</font><br /><b>if</b> <font color="#000080">[b]</font> = <font color="#0000ff">''</font> <b>halt</b><br /><br />sum <font color="#000080">[a]</font>, <font color="#000080">[b]</font><br /><b>end</b></div><!-- code END-->Now we're also able to define the above procedure as a function, that returns the sum of the two specified values to a return variable. Defining functions is not harder that defining procedures - it is nearly the same proceeding, but with the use of other statements. Equivalently to PROC and ENDPROC, a function is defined using the statements FUNC and ENDFUNC. All code between FUNC and ENDFUNC belongs to the new function. Whereas procedures, functions use one more statement that is used to return a value to the result variable that is specified at the function's call: The RET-statement. RET can also be used in procedures, but here without a parameter variable, to return to the calling point before the ENDPROC is finally reached. That means the procedure can be stopped and returned earlier, e.g. when an error occured or something succeeded, and the procedure did its job.<br />If RET is used in functions, it expects a value as parameter that is returned to the result variable. This value can be optional; If it is not specified, the result variable automatically gets and empty string.<br />The following script implements and uses the function &quot;sum&quot; that returns the sum of the two, as parameters specified values.<br /><br /><!-- code BEGIN --><div class="code"><font color="#808080">rem demo script using a function</font><br /><b>func</b> sum: <font color="#000080">[value1]</font>, <font color="#000080">[value2]</font><br />&nbsp;&nbsp;&nbsp;&nbsp;<b>dec</b> <font color="#000080">[result]</font><br />&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[result]</font> = <font color="#000080">[value1]</font> + <font color="#000080">[value2]</font><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;<b>ret</b> <font color="#000080">[result]</font><br /><b>endfunc</b><br /><br /><font color="#808080">rem calling sum using constant parameter values</font><br />sum <font color="#000080">[sum]</font> = <font color="#0000ff">'7'</font>, <font color="#0000ff">'13'</font><br />echo <font color="#0000ff">'The sum is: '</font> # <font color="#000080">[sum]</font><br /><br /><font color="#808080">rem calling sum using variable parameter values</font><br />inputbox <font color="#000080">[a]</font> = <font color="#0000ff">'Value A:'</font>, <font color="#0000ff">'Please enter a number:'</font>, <font color="#0000ff">''</font><br /><b>if</b> <font color="#000080">[a]</font> = <font color="#0000ff">''</font> <b>halt</b><br />inputbox <font color="#000080">[b]</font> = <font color="#0000ff">'Value B:'</font>, <font color="#0000ff">'Please enter a number:'</font>, <font color="#0000ff">''</font><br /><b>if</b> <font color="#000080">[b]</font> = <font color="#0000ff">''</font> <b>halt</b><br /><br />sum <font color="#000080">[sum]</font> = <font color="#000080">[a]</font>, <font color="#000080">[b]</font><br />echo <font color="#0000ff">'The sum is: '</font> # <font color="#000080">[erg]</font><br /><b>end</b></div><!-- code END-->I know that experienced programmers will smirk, because normally such a simple addition is done like this:<br /><br /><!-- code BEGIN --><div class="code">echo <font color="#0000ff">'The sum is: '</font> # <font color="#0000ff">'32'</font> + <font color="#0000ff">'5'</font><br /><b>end</b></div><!-- code END-->But I thought this was a nice and understandable example for writing a user-defined function in RapidBATCH.<br /><br />Let's move back to one important thing that I wanted to discuss before we continue with recoursive procedure calls and variable-pointers: The difference between the local and global variables! In RapidBATCH, every variable that is declared outside a procedure or function is automatically a global variable. All procedures can read and write data from and into globally declared variables, that means, if we e.g. declare a variable [test] and then call a procedure, [test] can also be accessed from this procedure. In case of locally declared variables, this is not possible. If we declare a variable [test] in a procedure, [test] can only be used from statements and functions that belong to this procedure. Also if another procedure is called from this procedure, [test] can not be accessed.<br />Sometimes, this major difference between the variable types is slightly difficultly to understand, but if this possibility would not given, the possibility of writing structured programs using procedure wouldn't be possible, especially when we program recoursive procedure calls as described in the next chapter.<br /><br />To be sure you're accessing a real local variable within your procedure it is recommended to declare each variable that you use in your procedure or function (except parameter variables) manually using the DEC-statement. When you have a global variable [i], and you want to use [i] as a local variable, you can declare and overwrite the global [i] variable with a local [i] variable, by using DEC.<br /><br />The following example demonstrates the problem and it's solution:<br /><br /><!-- code BEGIN --><div class="code"><font color="#000080">[i]</font> = <font color="#0000ff">'10'</font><br /><br /><b>proc</b> test<br />&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> = <font color="#0000ff">'1'</font><br />&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'i is here '</font> # <font color="#000080">[i]</font><br /><b>endproc</b><br /><br />echo <font color="#0000ff">'i is here '</font> # <font color="#000080">[i]</font><br />test<br />echo <font color="#0000ff">'i is here '</font> # <font color="#000080">[i]</font><br /><b>end</b></div><!-- code END-->What happens is quite simple: We want to use [i] in the procedure &quot;test&quot; locally, so we just assign a value to [i] in hope that it will be re-declared. But this is wrong! [i] was already declared globally, before the procedure call was done! So what we have to do, is just re-declaring [i] as a local variable again:<br /><br /><!-- code BEGIN --><div class="code"><font color="#000080">[i]</font> = <font color="#0000ff">'10'</font><br /><br /><b>proc</b> test<br />&nbsp;&nbsp;&nbsp;&nbsp;<b>dec</b> <font color="#000080">[i]</font><br />&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> = <font color="#0000ff">'1'</font><br />&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'i is here '</font> # <font color="#000080">[i]</font><br /><b>endproc</b><br /><br />echo <font color="#0000ff">'i is here '</font> # <font color="#000080">[i]</font><br />test<br />echo <font color="#0000ff">'i is here '</font> # <font color="#000080">[i]</font><br /><b>end</b></div><!-- code END-->In this case, the locally declared variable [i] is removed from the memory again, and it's &quot;global brother&quot;, the globally declared variable [i], will stay in memory until the script finally ends, and can be accessed again behin the procedure call.<br /><br />Maybe you have some problems on understanding the sense of local and global varibales, but I ensure that you will understand it after you wrote some scripts using procedures and handling with these types of variables.<br /><br />So let's move to the next chapters that show how procedural programming in RapidBATCH really can be exhausted!<br /><br />

		<div class="line">&nbsp;</div>

		<div id="copyright">
			Copyright &copy; 2000-2006 by J.M.K S.F. Software Technologies, Jan Max Meyer<br />
			All rights reserved.
		</div>
	</body>
</html>
