<html>
	<head>
		<title>An example source code</title>
		<link rel="stylesheet" href="jmksf.css" type="text/css"></link>
	</head>

	<body>
		<div id="top">
			<img src="rb5.png" alt="RapidBATCH Logo" />
			An example source code
		</div>
		
		<div class="line">&nbsp;</div>
		
		This is the full C source code of an example DLL that can be compiled for the use with RapidBATCH. You can find this file also in the DLL\DemoDLL-directory of your RapidBATCH 5 setup directory.<br /><br />Many thanks to Klaus Fischer (radix42) for writing this user documentation and the example DLLs.<br /><br /><pre style="border: 0px;" >// &lt;windows.h&gt; needed for all Windows API functions<br />#include &lt;windows.h&gt;<br /><br />// &lt;stdio.h&gt; needed for using the function "sprintf"<br />#include &lt;string.h&gt;<br />#include &lt;stdio.h&gt;<br /><br />//------------------------------------------------------------------------<br /><br />// This is the load and unload routine of the DLL.<br />// For this function, the WINAPI calling convention applies.<br /><br />BOOL WINAPI __declspec(dllexport) LibMain( HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved )<br />{<br />    switch( fdwReason )<br />    {<br />        case DLL_PROCESS_ATTACH:<br />			/*<br />			This part is executed when the DLL is loaded. Here you can insert<br />			general initializing routines, for example.<br />			In this example, a messagebox is displayed, that shows when the DLL<br />			is loaded from the script.<br />			*/<br />			MessageBox( NULL, "DemoDLL.dll has been loaded.", "RB5 DemoDLL", MB_ICONINFORMATION );<br />            break;<br />        case DLL_PROCESS_DETACH:<br />			/*<br />			This part is executed when the DLL is released again.<br />			It also displays us a messagebox.<br />			*/<br />			MessageBox( NULL, "DemoDLL.dll wird entladen.", "RB5 DemoDLL", MB_ICONINFORMATION );<br />            break;<br />    }<br />    return TRUE;<br />}<br /><br />//------------------------------------------------------------------------<br /><br />/* This is the first function: rbxGetTickCount()<br /><br />rbxGetTickCount() simply calls the Windows-function GetTickCount(). This<br />function returns the number of milliseconds from the last boot of Windows.<br />This function enables to measure the duration of a process: Simply call<br />rbxGetTickCount before and after the process and form the difference!<br /><br />Warning: GetTickCount() returns a 32-Bit value. This is enough for ca. 49.7<br />days of system stand by. Then the counter simply overflows. In a real<br />application, the return values should be compared if the second value is<br />lower than the first one.<br /><br />This function simply ignores maybe passed input parameters, and only returns<br />the number of milliseconds in a string via the Output return-pointer.<br /><br />*/<br />int __declspec(dllexport ) _cdecl rbxGetTickCount( char ** Output, char ** Input, int InputCount )<br />{<br />	/*<br />		First check if Output points to something.<br />		If not, terminate here.<br />		<br />		The value -1 means in RapidBATCH an error, but this case should normally not occur!<br />		But to play it save, we do this check here!<br />	*/<br />	if( Output == NULL )<br />		return( -1 );<br /><br />	/*<br />		Now, we request 16 bytes of memory. "LPTR" means, that the memory should<br />		be callable over the returned address (by the RapidBATCH interface). LPTR<br />		does also initialize the memory with 0 values.<br />		The second parameter defines the desired length of bytes to be allocated.<br />		Please note: In C, you must allocate one byte more for a string that you<br />		want to store to, because of the NULL-terminator that is postfixed at each<br />		end of a string, marking the string's end. We can store 15 characters into<br />		this memory. The 16th character is reserved for the \0 character.<br />		<br />		We store the pointer for this newly allocated memory into the pointer output<br />		points to, by dereferencing it once.<br />	*/<br />	*Output = LocalAlloc( LPTR, 16 );<br /><br />	/*<br />		Check if the memory could be allocated. If not, terminate the function and<br />		return -1 to RapidBATCH. In normal case, this case does also not happen, but<br />		we go sure with these two lines!<br />	*/<br />	if( *Output == NULL )<br />		return( -1 );<br /><br />	/*<br />		Now, the effective part of the function begins: The functionality!<br />		So here we simply write the return value of GetTickCount() to the<br />		newly allocated string using a classic call to the sprintf() function.<br />		Please read Kernighan&Ritche to get more information on what is possible<br />		with the sprintf() function.<br />	*/<br />	sprintf( *Output, "%d", GetTickCount( ) );<br /><br />	// That's it! Terminate the function with 0, everything succeeded!<br />	return( 0 );<br /><br />}<br /><br />//------------------------------------------------------------------------<br /><br />/* This is the second function: rbxCreateWindowList()<br /><br /><br />rbxCreateWindowList() creates a list the title lines of all visible windows in the<br />current Windows environment.<br />The list elements are delimited through the delimiter string that is passed as a<br />parameter to rbxCreateWindowList from the RapidBATCH script. To retrieve the list<br />of visible windows, the Windows-function EnumWindows() is used, which calls a so<br />called callback-function for each window. The definition of the return value and <br />the parameters of this callback-function is fixed.<br /><br />Note that the following function defines this callback-routine. It is not exported<br />as a DLL function because it is only used internally by the exported function<br />rbxCreateWindowList() that is then called by RapidBATCH.<br /><br />This example was simply adapted from the Micrsoft Windows API User documentation, so<br />the names of the parameters and the function itself are the same as from the example<br />there. You can freely rename the function and its parameters like you wish.<br /><br />The titles of the windows will be stored into a requested buffer. The size should be<br />enough (defined over the following #define's), but anyway we check that they do not<br />overrun and cause a segmenation fault here.<br />*/<br /><br />#define BUFFSIZE 10000  // 10000 bytes should be enuogh, change it if required!<br />#define TEXTSIZE   100  // 100 bytes per title should be enuogh, change it if<br />						// required!<br /><br />// here we do also define an error code<br />#define ERROR_BAD_INPUT 11<br /><br />// and we need two global variables<br />char*	gsSeparator		= (char*)NULL;<br />char*	gsBuffer		= (char*)NULL;<br /><br />//------------------------------------------------------------------------<br /><br />/* Here the callback-function is defined.<br /><br />In the variable hwnd, the window handle is stored. The parameter "lParam" is<br />not used (NULL will be passed).<br />*/<br /><br />BOOL CALLBACK EnumWindowsProc( HWND hwnd, LPARAM lParam )<br />{<br />	// first of all, a local variable<br />	char	Title[TEXTSIZE];<br />	<br />	// Initialize the buffer with null terminators<br />	memset( Title, '\0', TEXTSIZE );<br /><br />	// Retrieve the title of the passed window<br />	// als length, we assign TEXTSIZE-1, to make sure the last byte for<br />	// the \0 is not overwritten!<br />	GetWindowText( hwnd, Title, TEXTSIZE-1 );<br /><br />	// Check if the Title-variable is not (char*)NULL<br />	if( *Title != '\0' )<br />	{<br />		// Is the window visible? If not, request the next one!<br />		if( IsWindowVisible( hwnd ) )<br />		{<br />			// Append the window to the list of visible windows!<br />			<br />			// Separator required? Not if gfBuffer is empty.<br />			if( *gsBuffer != '\0' )<br />				strcat( gsBuffer, gsSeparator );<br />			// Then append the title to the buffer!<br />			strcat( gsBuffer, Title );<br /><br />			// Now check if there is enough space in the buffer to store<br />			// another title including its separator<br />			if( strlen( gsBuffer ) + strlen( gsSeparator ) + TEXTSIZE < BUFFSIZE )<br />				// Yes, there is enough space, request the next window<br />				return( TRUE );<br />			else<br />				// No, there is no more space. Stop requesting a new window.<br />				return( FALSE );<br />		}<br />	}<br />	<br />	// Request the next window<br />	return( TRUE );<br />}<br /><br />//------------------------------------------------------------------------<br /><br />/* Now, the proper function: rbxCreateWindowList()<br /><br />This function expects one parameter: The pointer to a separation character.<br />For this case, the RapidBATCH standard delimiters [std_sep] or [new_line]<br />should be used.<br /><br />The function then calls the EnumWindows() function, which then calls the<br />above callback-function which constructs the list of windows.<br />*/<br /><br />int __declspec(dllexport ) _cdecl rbxCreateWindowList( char ** Output, char ** Input, int InputCount )<br />{<br />	/*<br />		Again, first check if Output points to something.<br />		If not, terminate here.<br />		<br />		The value -1 means in RapidBATCH an error, but this case should normally not occur!<br />		But to play it save, we do this check here!<br />	*/<br />	if( Output == NULL )<br />		return( -1 );<br /><br />	/*<br />		Now, we request BUFFSIZE bytes of memory. "LPTR" means, that the memory<br />		should be callable over the returned address (by the RapidBATCH interface). <br />		LPTR does also initialize the memory with 0 values.<br />		The second parameter defines the desired length of bytes to be allocated.<br />		Please note: In C, you must allocate one byte more for a string that you<br />		want to store to, because of the NULL-terminator that is postfixed at each<br />		end of a string, marking the string's end. We can store 15 characters into<br />		this memory. The 16th character is reserved for the \0 character.<br />		<br />		We store the pointer for this newly allocated memory into the pointer output<br />		points to, by dereferencing it once.<br />	*/<br />	*Output = LocalAlloc( LPTR, BUFFSIZE );<br /><br />	/*<br />		Check if the memory could be allocated. If not, terminate the function and<br />		return -1 to RapidBATCH. In normal case, this case does also not happen, but<br />		we go sure with these two lines!<br />	*/<br />	if( *Output == NULL )<br />		return( -1 );<br /><br />	/*<br />		Now, the number of the parameters and even the passed value itself are checked if they<br />		are filled and useable with this function<br />	*/<br />	if( InputCount != 1 || Input == NULL || *Input == NULL || **Input == 0 || strlen( *Input ) > TEXTSIZE )<br />	{<br />		/*<br />			Return an error (in this case "11")<br />		*/<br />		return( ERROR_BAD_INPUT );<br />	}<br />	<br />	/*<br />		The parameters are fine, and the memory could be allocated, then set the<br />		global variables to the two different values to use them within the<br />		callback function from above.<br />	*/<br />	gsBuffer = *Output;<br />	gsSeparator = *Input;<br />	<br />	/*<br />		Fine, so let's create the list of window titles!<br />	*/<br />	EnumWindows( EnumWindowsProc,( LPARAM )NULL );<br />	<br />	/*<br />		All succeded! Return 0 to [errorcode] for success!<br />	*/	<br />	return( 0 );<br />	<br />}<br /><br />//------------------------------------------------------------------------<br /><br />// That's it! Have fun on coding your own DLL functions...</pre>Now a demonstration script that uses the functions from this DLL file.<br /><br /><!-- code BEGIN --><div class="code"><font color="#808080">rem This script demonstrates the usage of DLLs using the EXT-function.</font><br /><br /><font color="#808080">rem Get start time</font><br /><b>ext</b> <font color="#000080">[StartTime]</font> = <font color="#0000ff">'DemoDLL.dll'</font>, <font color="#0000ff">'rbxGetTickCount'</font><br /><b>if</b> <font color="#000080">[errorcode]</font> ! <font color="#0000ff">'0'</font><br />&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Error when trying to call &lt;rbxGetTickCount&gt; in DemoDLL.dll'</font><br />&nbsp;&nbsp;&nbsp;&nbsp;<b>halt</b><br /><b>endif</b><br /><br />msgbox <font color="#0000ff">'DemoDLL.rb'</font>, <font color="#0000ff">'Please decide about one of these options!'</font>, <font color="#0000ff">'262196'</font><br /><br /><font color="#808080">rem Stopzeit holen</font><br /><b>ext</b> <font color="#000080">[StopTime]</font> = <font color="#0000ff">'DemoDLL.dll'</font>, <font color="#0000ff">'rbxGetTickCount'</font><br /><br /><b>if</b> <font color="#000080">[errorcode]</font> ! <font color="#0000ff">'0'</font><br />&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Error when trying to call &lt;rbxGetTickCount&gt; in DemoDLL.dll'</font><br />&nbsp;&nbsp;&nbsp;&nbsp;<b>halt</b><br /><b>endif</b><br /><br /><font color="#808080">rem Calculate the time difference</font><br /><font color="#000080">[Difference]</font> = (<font color="#000080">[StopTime]</font> - <font color="#000080">[StartTime]</font>) / <font color="#0000ff">'1000'</font><br /><br /><font color="#808080">rem Show the result</font><br />msgbox <font color="#0000ff">'DemoDLL.rb'</font>, <font color="#0000ff">'You needed '</font> # <font color="#000080">[Difference]</font> # <font color="#0000ff">' seconds for your decision!'</font>, <font color="#0000ff">'64'</font><br /><br /><font color="#808080">rem Now create a list of all visible windows...</font><br /><b>ext</b> <font color="#000080">[WindowList]</font> = <font color="#0000ff">'DemoDLL.dll'</font>, <font color="#0000ff">'rbxCreateWindowList'</font>, <font color="#000080">[new_line]</font><br /><br /><b>if</b> <font color="#000080">[errorcode]</font> ! <font color="#0000ff">'0'</font><br />&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Error when trying to call &lt;rbxCreateWindowList&gt; in DemoDLL.dll'</font><br />&nbsp;&nbsp;&nbsp;&nbsp;<b>halt</b><br /><b>endif</b><br /><br /><font color="#808080">rem Show the list of windows in a messagebox</font><br />msgbox <font color="#0000ff">'DemoDLL.rb'</font>, <font color="#0000ff">'The following visible windows where found:'</font> # <font color="#000080">[new_line]</font> # <font color="#000080">[new_line]</font> # <font color="#000080">[WindowList]</font>, <font color="#0000ff">'64'</font><br /><br /><font color="#808080">rem Let's make a try if rbxCreateWindowList tells us an error if we miss the</font><br /><font color="#808080">rem expected parameter!</font><br /><b>ext</b> <font color="#000080">[WindowList]</font> = <font color="#0000ff">'DemoDLL.dll'</font>, <font color="#0000ff">'rbxCreateWindowList'</font><br /><b>if</b> <font color="#000080">[errorcode]</font> ! <font color="#0000ff">'11'</font><br />&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Unpredicted errorcode when trying to call &lt;rbxCreateWindowList&gt; in DemoDLL.dll'</font><br />&nbsp;&nbsp;&nbsp;&nbsp;<b>halt</b><br /><b>endif</b><br /><br /><font color="#808080">rem The error code was correct!</font><br />msgbox <font color="#0000ff">'DemoDLL.rb'</font>, <font color="#0000ff">'The parameter check of &lt;rbxCreateWindowList&gt; succeeded.'</font>, <font color="#0000ff">'64'</font><br /><br /><font color="#808080">rem That's it! :)</font><br /><br /><b>end</b></div><!-- code END--><br /><br />

		<div class="line">&nbsp;</div>

		<div id="copyright">
			Copyright &copy; 2000-2006 by J.M.K S.F. Software Technologies, Jan Max Meyer<br />
			All rights reserved.
		</div>
	</body>
</html>
