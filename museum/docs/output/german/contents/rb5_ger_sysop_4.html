<html>
	<head>
		<title>Dateien lesen und schreiben</title>
		<link rel="stylesheet" href="jmksf.css" type="text/css"></link>
	</head>

	<body>
		<div id="top">
			<img src="rb5.png" alt="RapidBATCH Logo" />
			Dateien lesen und schreiben
		</div>
		
		<div class="line">&nbsp;</div>
		
		Um Dateien in RapidBATCH zu verarbeiten, stellt Ihnen RapidBATCH vier vielseitig anwendbare Anweisungen und Funktionen zur Verf&uuml;gung. Mit Hilfe dieser Anweisungen und Funktionen k&ouml;nnen Sie sowohl Textdateien als auch bin&auml;re Dateien lesen und schreiben.<br /><br />Um Daten in eine Textdatei zu schreiben, bietet RapidBATCH die Anweisung WRITEFILE. WRITEFILE erwartet als Parameter einen Dateinamen sowie den zu schreibenden Text (also die zu schreibenden Daten).<br /><br />Einfachstes Fallbeispiel:<br /><br /><!-- code BEGIN --><div class="code">writefile <font color="#0000ff">'hello.txt'</font>, <font color="#0000ff">'Dies ist ein einfacher Text in einer Textdatei!'</font></div><!-- code END-->WRITEFILE erweitert bei jedem Aufruf den Inhalt einer Datei, falls diese schon existiert, d.h. der zu schreibende Wert wird an das Ende der Datei angeh&auml;ngt. Ein Zeilenumbruch je WRITEFILE-Aufruf geschieht in der Datei automatisch. Existiert die zu schreibende Datei noch nicht, wird sie neu erstellt und der entsprechende Wert in die erste Zeile geschrieben.<br /><br />F&uuml;hren wir also den folgenden Code aus:<br /><br /><!-- code BEGIN --><div class="code">writefile <font color="#0000ff">'test.txt'</font>, <font color="#0000ff">'Das ist ein Test!'</font><br />writefile <font color="#0000ff">'test.txt'</font>, <font color="#0000ff">'Und jetzt sind wir in der zweiten Zeile!'</font><br />writefile <font color="#0000ff">'test.txt'</font>, <font color="#0000ff">'So denn! Das ist das Ende der Datei.'</font></div><!-- code END-->so erh&auml;lt die resultierende Datei TEST.TXT folgenden Inhalt:<br /><br /><!-- code BEGIN --><div class="code"><b><font color="#000000">Das ist ein Test!<br />Und jetzt sind wir in der zweiten Zeile!<br />So denn! Das ist das Ende der Datei.</font></b></div><!-- code END-->Wollen wir nun die Datei wieder auslesen, verwenden wir die Funktion READFILE. READFILE ist ebenfalls nur zum Lesen von Textdateien geeignet, da sie eine Datei zeilenweise ausliest. Parameter sind der Dateiname der zu lesenden Datei sowie eine Zeilenangabe. R&uuml;ckgabewert ist der Inhalt der angeforderten Zeile.<br />Folgendes Script liest die erste Zeile unserer gerade erstellten TEST.TXT aus.<br /><br /><!-- code BEGIN --><div class="code">readfile <font color="#000080">[zeile]</font> = <font color="#0000ff">'test.txt'</font>, <font color="#0000ff">'1'</font><br />echo <font color="#0000ff">'Erste Zeile von TEST.TXT: '</font> # <font color="#000080">[zeile]</font></div><!-- code END-->Wollen wir die Datei nun komplett Zeile-f&uuml;r-Zeile lesen, ist ein so genannter Zeilen-Z&auml;hler notwendig. Wir verwenden hier die Variable [i]. Wird bei READFILE eine Zeile angefordert, die nicht mehr existiert, so ist der R&uuml;ckgabewert der Funktion der Wert &quot;EOF&quot;, was soviel bedeutet wie &quot;End Of File&quot;. Die Abbruchbedingung f&uuml;r unsere Ausleseschleife ist also der Vergleich, ob [zeile] den Wert 'EOF' erh&auml;lt, womit wir nun folgendes Script erhalten:<br /><br /><!-- code BEGIN --><div class="code"><font color="#000080">[i]</font> = <font color="#0000ff">'0'</font><br /><b>repeat</b><br /><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem [i] inkrementieren (erh&ouml;hen)</font><br />&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> + <font color="#0000ff">'1'</font><br /><br /><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem Zeile [i] lesen</font><br />&nbsp;&nbsp;&nbsp;&nbsp;readfile <font color="#000080">[zeile]</font> = <font color="#0000ff">'test.txt'</font>, <font color="#000080">[i]</font><br /><br /><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem Ausgabe der Zeile</font><br />&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Inhalt von Zeile '</font> # <font color="#000080">[i]</font> # <font color="#0000ff">': '</font> # <font color="#000080">[zeile]</font><br /><b>until</b> <font color="#000080">[zeile]</font> = <font color="#0000ff">'EOF'</font></div><!-- code END--><!--<div class="remark">Wenn Sie das Script ausf&uuml;hren, werden Sie feststellen, dass die Zeile Nr. 4 leer ist. Das hat den einfachen Grund, dass wenn die Datei mit der Anweisung WRITEFILE geschrieben wurde, beim Schreiben der letzten Zeile ein neuer Zeilenumbruch erfolgt. READFILE liest daher eine leere Zeile, da die Datei ja nicht aus 3 sondern aus 4 Zeilen besteht!</div>-->READFILE kann auch eine Datei &quot;in einem Rutsch&quot; einlesen, also die komplette Textdatei zur&uuml;ckgeben. Diesen Effekt erh&auml;lt man, wenn man als Zeilenindex eine Zahl kleiner oder gleich '0' angibt. Folgendes Script zeigt uns also direkt den Inhalt der Datei TEST.TXT an.<br /><br /><!-- code BEGIN --><div class="code">readfile <font color="#000080">[datei]</font> = <font color="#0000ff">'test.txt'</font>, <font color="#0000ff">'0'</font><br />echo <font color="#0000ff">'Inhalt von TEST.TXT:'</font> # <font color="#000080">[new_line]</font> # <font color="#000080">[new_line]</font> # <font color="#000080">[datei]</font></div><!-- code END-->Wir verwenden im obigen Script ausserdem die vordeklarierte Variable [new_line], um jeweils einen Zeilenumbruch im ECHO-Meldungsfenster zu erzeugen.<br /><br />Sowohl bei READFILE als auch bei WRITEFILE kann durch &Uuml;berpr&uuml;fung der Variablen [errorcode] gepr&uuml;ft werden, ob die jeweilige Aktion erfolgreich war oder nicht. Die Vorgehensweise ist dieselbe wie bei den bisher besprochenenen Anwendungsf&auml;llen f&uuml;r [errorcode], '-1' bei einem Fehler (z.B. bei READFILE, wenn EOF eintritt oder die Datei nicht existiert, '0' bei erfolgreicher Durchf&uuml;hrung.<br /><br />Neben dem Schreiben und Lesen von Textdateien ist es in RapidBATCH 5 auch erstmals m&ouml;glich, Bin&auml;rdateien zu bearbeiten. Als Bin&auml;rdateien definiert man alle Dateien, die keine direkten Textdateien sind. Selbst Office-Dateien wie .XLS oder .DOC sind KEINE Textdateien.<br />Wir werden in diesen Beispielen hier auch nur lesbare Texte in die Bin&auml;rdateien schreiben, es k&ouml;nnen aber auch beliebige Sonder- und Steuerzeichen in die Bin&auml;rdateien geschrieben werden.<br /><br />Um eine Datei (es kann auch eine Textdatei sein!) bin&auml;r zu schreiben, bietet RapidBATCH die Anweisung PUTFILE. Wenn man mit PUTFILE in eine nicht existierende Datei schreiben will, schl&auml;gt dies fehl, daher MUSS die Datei vorher mit NEWFILE explizit erzeugt werden. Folgendes Beispiel schreibt den Text &quot;Hello World&quot; bin&auml;r in eine Datei BINARY.TXT. Neben dem Dateinamen und dem zu schreibenden Wert muss bei PUTFILE als zweiter Parameter der Byte-Offset, wo der Text in die Datei eingef&uuml;gt werden soll, angegeben werden. Als Offset bezeichnet man die Position eines Zeichens ab dem Anfang der Datei. Da unsere Datei leer ist, beginnen wir also bei Offset 1. Es ist also das erste Byte der Datei. Die Zeichen, die bin&auml;r in die Datei geschrieben werden, werden nicht im Klartext angegeben, sondern als Liste von ASCII-Zeichencodes der zu schreibenden ASCII-Zeichen, in der jeder Wert durch das bereits bekannte Standard-Separatorzeichen, welches &uuml;ber die Variable [std_sep] definiert werden kann, getrennt ist. Wie bereits bekannt sein sollte ist dies im Normalfall das Pipe-Zeichen &quot;|&quot;.<br /><br /><!-- code BEGIN --><div class="code">newfile <font color="#0000ff">'binary.txt'</font><br />putfile <font color="#0000ff">'binary.txt'</font>, <font color="#0000ff">'1'</font>, <font color="#0000ff">'72|101|108|108|111|32|87|111|114|108|100'</font><br />open <font color="#0000ff">'binary.txt'</font></div><!-- code END-->In diesem Fall haben wir gerade 11 Byte in die Datei eingef&uuml;gt, also 11 ASCII-Zeichen.<div class="remark">Anmerkung: Um einen Klartext ganz einfach in eine Liste von ASCII-Zeichen zu konvertieren, verwenden Sie einfach folgendes Script, welches ich auch zum Erstellen der Beispiele in diesem Handbuch verwendet habe:<br /><br /><!-- code BEGIN --><div class="code">inputbox <font color="#000080">[eingabe]</font> = <font color="#0000ff">'Klartext'</font>, <font color="#0000ff">'Bitte geben Sie einen Text ein:'</font>, <font color="#0000ff">''</font><br /><b>if</b> <font color="#000080">[eingabe]</font> = <font color="#0000ff">''</font> <b>halt</b><br /><br /><font color="#000080">[i]</font> = <font color="#0000ff">'0'</font><br />getlen <font color="#000080">[len]</font> = <font color="#000080">[eingabe]</font><br /><font color="#000080">[ausgabe]</font> = <font color="#0000ff">''</font><br /><b>repeat</b><br />&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> + <font color="#0000ff">'1'</font><br />&nbsp;&nbsp;&nbsp;&nbsp;getcharat <font color="#000080">[ch]</font> = <font color="#000080">[eingabe]</font>, <font color="#000080">[i]</font><br />&nbsp;&nbsp;&nbsp;&nbsp;getasc <font color="#000080">[ch]</font> = <font color="#000080">[ch]</font><br />&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[ausgabe]</font> ! <font color="#0000ff">''</font> <font color="#000080">[ausgabe]</font> # <font color="#000080">[std_sep]</font><br />&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[ausgabe]</font> # <font color="#000080">[ch]</font><br /><b>until</b> <font color="#000080">[i]</font> = <font color="#000080">[len]</font><br /><br /><font color="#000080">[clipboard]</font> = <font color="#000080">[ausgabe]</font><br />echo <font color="#0000ff">'Der Text wurde als ASCII-Liste dekodiert und in die Zwischenablage kopiert.'</font><br /><b>end</b></div><!-- code END--></div>Wir k&ouml;nnten jetzt auch beispielsweise direkt an Byte-Position 100 mit dem Schreiben der Datei fortfahren:<br /><br /><!-- code BEGIN --><div class="code"><font color="#808080">rem Text: &quot;Und dies ist ein weiterer&quot;</font><br /><font color="#000080">[text]</font> = <font color="#0000ff">'85|110|100|32|100|97|115|32'</font><br /><font color="#000080">[text]</font> # <font color="#0000ff">'|105|115|116|32|101|105|110|32'</font><br /><font color="#000080">[text]</font> # <font color="#0000ff">'|119|101|105|116|101|114|101|114'</font><br />putfile <font color="#0000ff">'binary.txt'</font>, <font color="#0000ff">'100'</font>, <font color="#000080">[text]</font><br /><br /><font color="#808080">rem Text: &quot;Bin&auml;r-Schreibvorgang ;)&quot;</font><br /><font color="#000080">[text]</font> = <font color="#0000ff">'32|66|105|110|228|114|45|83|99'</font><br /><font color="#000080">[text]</font> # <font color="#0000ff">'|104|114|101|105|98|118|111'</font><br /><font color="#000080">[text]</font> # <font color="#0000ff">'|114|103|97|110|103|32|59|41'</font><br /><br /><font color="#808080">rem Da wir jetzt 24 Zeichen geschrieben haben,</font><br /><font color="#808080">rem m&uuml;ssen wir ab Pos 100 + 24 weiterschreiben</font><br />putfile <font color="#0000ff">'binary.txt'</font>, <font color="#0000ff">'100'</font> + <font color="#0000ff">'24'</font>, <font color="#000080">[text]</font></div><!-- code END-->Diese Zeilen und Mengen an ASCII-Codewerten m&ouml;gen vielleich im ersten Moment etwas chaotisch aussehen, da wir hier auf reiner RapidBATCH-Sprachbasis arbeiten. Wenn Sie sp&auml;ter die Bin&auml;rfunktionen produktiv einsetzen wollen ist es nat&uuml;rlich ratsam, sich entsprechende Hilfsfunktionen zu programmieren, die einem die Arbeit erheblich sparen k&ouml;nnen und sich v&ouml;llig individuell an die entsprechenden Einsatzumgebungen ab&auml;ndern lassen.<br /><br />Wenn wir nun zus&auml;tzlich auch obige Zeilen ausgef&uuml;hrt haben, sieht die Datei, wenn man sie in einem HEX-Editor betrachtet, so aus:<br /><div class="image"><img src="img/hexview_binary.gif" title="Inhalt der Datei BINARY.TXT in einem Hex-Editor"/><br />Inhalt der Datei BINARY.TXT in einem Hex-Editor</div>Deutlich zu sehen ist, dass unser zweiter, bin&auml;rer Schreibvorgang bei Hex-Offset 64 beginnt, also Dezimal der Offset 100. Der Bereich zwischen unserem &quot;Hello World&quot; und dem Text &quot;Und das ist ein weiterer Bin&auml;r-Schreibvorgang ;)&quot; wird mit dem ASCII-Zeichencode 0 aufgef&uuml;llt, was soviel heiﬂt wie &quot;nichts&quot; (NUL).<br /><div class="remark">ACHTUNG: Bei Windows 95, 98 und ME bzw. FAT und Derivate formatierten Speichermedien wurde beobachtet, dass anstatt ASCII-Zeichencode 0 der Inhalt von gel&ouml;schten Daten auf der Festplatte in der Datei auftauchen k&ouml;nnen, da PUTFILE die Daten ja bin&auml;r einfach irgendwo auf die Festplatte an die angegebene Position schreibt; Der Grund daf&uuml;r ist, dass einfach die neu hinzugekommenen Daten zur Datei selbst hinzugef&uuml;gt werden. Daher bitte, um diesen Effekt zu vermeinden, die entsprechenden Stellen vorher manuell mit NUL- oder einem anderem ASCII-Zeichen auff&uuml;llen.</div>Wenn Sie mit PUTFILE in eine bestehende Datei schreiben, werden alle Zeichen, die Sie an einer bestimmten Byteposition angeben, einfach in die Datei geschrieben, d.h. vorhandene Zeichen werden einfach &uuml;berschrieben. Es erfolgt also kein append (Anh&auml;ngen von Daten), denn dies w&auml;re ja f&uuml;r bin&auml;re Dateiverarbeitung nicht angebracht, bzw. ohne gr&ouml;ﬂeren Sinn (Dateien werden ja automatisch erweitert, wenn Daten &uuml;ber das Dateiende hinaus geschrieben wurden, wie wir es im obigen Beispiel gemacht haben).<br /><br /><br />Das Auslesen einer Bin&auml;rdatei funktioniert so &auml;hnlich wie das Schreiben - hierzu benutzen wir gegens&auml;tzlich zu PUTFILE die Funktion GETFILE. GETFILE erwartet als Funktionsparameter den Pfad der zu lesenden Datei, den Anfangs-Offset sowie die Anzahl der Bytes, die vom Anfangs-Offset aus gelesen werden. Wenden wir nun GETFILE auf unsere im obigen Beispiel erstellte Datei BINARY.TXT an. Zu beachten sei auch hier, dass die R&uuml;ckgabe von GETFILE eine Liste an ASCII-Codes ist, die wir zuerst wieder mit der Funktion GETCHR zu entsprechenden Zeichen umwandeln m&uuml;ssen, was aber kein gr&ouml;ﬂeres Problem darstellt.<br /><br /><!-- code BEGIN --><div class="code"><font color="#808080">rem Daten lesen</font><br />getfile <font color="#000080">[data]</font> = <font color="#0000ff">'binary.txt'</font>, <font color="#0000ff">'100'</font> + <font color="#0000ff">'25'</font>, <font color="#0000ff">'20'</font><br />echo <font color="#0000ff">'Gelesene ASCII-Liste: '</font> # <font color="#000080">[data]</font><br /><br /><font color="#808080">rem ASCII-Codes in ASCII-Zeichen umwandeln und an Ausgabestring h&auml;ngen</font><br /><font color="#000080">[i]</font> = <font color="#0000ff">'0'</font><br /><b>repeat</b><br />&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> + <font color="#0000ff">'1'</font><br />&nbsp;&nbsp;&nbsp;&nbsp;gettok <font color="#000080">[zeichen]</font> = <font color="#000080">[data]</font>, <font color="#000080">[std_sep]</font>, <font color="#000080">[i]</font><br />&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[zeichen]</font> ! <font color="#0000ff">''</font><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getchr <font color="#000080">[zeichen]</font> = <font color="#000080">[zeichen]</font><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[klartext]</font> # <font color="#000080">[zeichen]</font><br />&nbsp;&nbsp;&nbsp;&nbsp;<b>endif</b><br /><b>until</b> <font color="#000080">[zeichen]</font> = <font color="#0000ff">''</font><br /><br /><font color="#808080">rem Den Klartext ausgeben</font><br />echo <font color="#0000ff">'Klartext: '</font> # <font color="#000080">[klartext]</font><br /><b>end</b></div><!-- code END-->Wir lesen hier den Text &quot;Bin&auml;r-Schreibvorgang&quot; aus der oben erstellten und geschriebenen Datei. Wir setzen dabei den Start-Offset auf 125 (dort wo der Text anf&auml;ngt) und lesen von dort aus 20 Zeichen. Ergebnis ist der entsprechende String!<br />Wenn Sie mit GETFILE &uuml;ber das Dateiende hinaus lesen wollen, wird entweder ein Leerstring oder aber alle Bytes bis zum Dateiende zur&uuml;ckgegeben.<br /><br /><br /><u>Wozu das alles?</u><br />Sicherlich haben Sie sich gefragt, warum wir hier einfache Textdateien bin&auml;r schreiben. Das ist nat&uuml;rlich nicht der eigentliche Sinn und Zweck von Bin&auml;rdateien. Sie haben aber mit PUTFILE und GETFILE die volle Kontrolle &uuml;ber eine Datei; Bei READFILE und WRITEFILE werden reine text-basierende Dateien verwaltet, doch mit PUTFILE und GETFILE haben Sie einfach mehr M&ouml;glichkeiten, eine Datei zu verarbeiten. Sie stellen sozusagen die &quot;professionelle Alternative&quot; zu WRITEFILE und READFILE dar, welche Sie aber mit h&ouml;chster Warscheinlichkeit vermehrt bei der Programmierung von Scripts in RapidBATCH einsetzen werden, da WRITEFILE und READFILE f&uuml;r die meisten Anwendungsf&auml;lle mehr als ausreichend und nat&uuml;rlich viel einfacher zu handhaben sind.<br /><br />

		<div class="line">&nbsp;</div>

		<div id="copyright">
			Copyright &copy; 2000-2006 by J.M.K S.F. Software Technologies, Jan Max Meyer<br />
			All rights reserved.
		</div>
	</body>
</html>
