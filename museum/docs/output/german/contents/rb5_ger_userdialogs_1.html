<html>
	<head>
		<title>Erstellung von Dialogfenstern</title>
		<link rel="stylesheet" href="jmksf.css" type="text/css"></link>
	</head>

	<body>
		<div id="top">
			<img src="rb5.png" alt="RapidBATCH Logo" />
			Erstellung von Dialogfenstern
		</div>
		
		<div class="line">&nbsp;</div>
		
		Mit RapidBATCH 5 ist es auch erstmals m&ouml;glich, eigene Dialogfenster direkt in RapidBATCH zu implementieren. RapidBATCH verwendet dazu ein sehr einfaches, aber augekl&uuml;geltes System, welches es m&ouml;glich macht, Dialogfenster zu erstellen und Dialogfensterelemente zu ver&auml;ndern und auszulesen.<br /><br />Mit nur ingesamt f&uuml;nf verschiedenen Anweisungen bzw. Funktionen haben Sie somit die Entwicklung eigener Windows-Programme mit und in RapidBATCH voll im Griff, und k&ouml;nnen so gut wie jede Art von Dialog und damit echte Windows-Anwendungen in RapidBATCH selber implementieren.<br /><br />Im Grunde ist die Entwicklung von eigenen Dialogen in RapidBATCH eine simple und unkomplizierte Angelegenheit:<br /><ul>	<li>Dialogelemente erzeugen</li>	<li>Werte-/Eigenschaften der Dialogelemente setzen</li>	<li>Dialogfenster anzeigen</li>	<li>Dialog starten, auf Ereignisse reagieren und Werte-/Eigenschaften der Dialogelemente auswerten</li></ul>Folgend dargestelltes Beispielscript f&uuml;hrt genau diese Schritte durch; Es erstellt einen Dialog mit einem einzeiligen Eingabefenster und einem Button. Klickt der Benutzer den Button, so wird der im Textfeld eingegebene Text in einem Meldungsfenster ausgegeben.<br /><br /><!-- code BEGIN --><div class="code"><font color="#808080">rem Widgets erzeugen</font><br />newdialog <font color="#0000ff">'myDialog'</font>, <font color="#0000ff">'DIALOG'</font>, <font color="#0000ff">'1|1|300|80'</font><br />newdialog <font color="#0000ff">'myDialog:Eingabe'</font>, <font color="#0000ff">'INPUT'</font>, <font color="#0000ff">'10|1|273|25'</font><br />newdialog <font color="#0000ff">'myDialog:Los'</font>, <font color="#0000ff">'BUTTON'</font>, <font color="#0000ff">'80|27|140|25'</font><br /><br /><font color="#808080">rem Setzen der Werte/Eigenschaften</font><br />letdialog <font color="#0000ff">'myDialog'</font>, <font color="#0000ff">'CAPTION'</font>, <font color="#0000ff">'Hello World'</font><br />letdialog <font color="#0000ff">'myDialog:Eingabe'</font>, <font color="#0000ff">'TEXT'</font>, <font color="#0000ff">'Dies ist ein Text!'</font><br />letdialog <font color="#0000ff">'myDialog:Los'</font>, <font color="#0000ff">'CAPTION'</font>, <font color="#0000ff">'Und &los...'</font><br /><br /><font color="#808080">rem Dialog anzeigen</font><br />letdialog <font color="#0000ff">'myDialog'</font>, <font color="#0000ff">'VISIBLE'</font>, <font color="#000080">[true]</font><br /><br /><b>repeat</b><br /><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem Dialog starten</font><br />&nbsp;&nbsp;&nbsp;&nbsp;rundialog <font color="#000080">[event]</font> = <font color="#0000ff">'0'</font><br /><br /><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem Ereignis auswerten</font><br />&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[event]</font> = <font color="#0000ff">'click_myDialog:Los'</font><br /><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rem Textfeld auslesen</font><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getdialog <font color="#000080">[text]</font> = <font color="#0000ff">'myDialog:Eingabe'</font>, <font color="#0000ff">'TEXT'</font><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Der Wert im Textfeld lautet: '</font> # <font color="#000080">[text]</font><br />&nbsp;&nbsp;&nbsp;&nbsp;<b>endif</b><br /><b>until</b> <font color="#000080">[event]</font> = <font color="#0000ff">'close_myDialog'</font><br /><b>end</b></div><!-- code END--><div class="image"><img src="img/dlgapp_01.gif" alt="Benutzerdefiniertes Dialogfenster" title="Screenshot" /><br />Script mit individuell programmiertem Dialog</div>Ich werde Sie nun Schritt-f&uuml;r-Schritt in diese neue Welt der schier unbegrenzten M&ouml;glichkeiten einf&uuml;hren, denn dieses neue, sehr effektive Feature, eigene Dialoge und Fenster zu programmieren, macht RapidBATCH nicht nur zu einer starken Script- und Automatisierungssprache sondern auch zu einem schnellen und unkomplizierten Werkzeug zur Entwicklung von echten, individuellen Windows-Anwendungen aller Art.<br /><div class="remark">Anmerkung: Folgend werde ich des &ouml;fteren das Wort &quot;Widget&quot; verwenden. Als Widget (eine Abk&uuml;rzung f&uuml;r &quot;Window Gadget&quot;, zu deutsch &quot;Fenster Ding&quot;) bezeichne ich hier sowohl Dialogfenster als auch Dialogelemente wie z.B. Buttons, Eingabefelder usw.. Die Unterschiede zwischen Dialogfenstern und Dialogelementen werden sp&auml;ter genauer erl&auml;utert.</div><div class="remark">Hinweis: Mit der RapidBATCH Professional Edition haben Sie die M&ouml;glichkeit, Dialogfenster schnell &amp; unkompliziert mit dem mitgeliefertem Werkzeug &quot;RapidBATCH Visual Dialog Designer&quot; zu erstellen. Widgets k&ouml;nnen hier in einer Echtzeitumgebung erstellt, angeordnet und bearbeitet werden. Ist der Dialog fertig entworfen, generiert der Assistent den daf&uuml;r n&ouml;tigen RapidBATCH Code, den Sie lediglich um die Ereignisbehandlung der einzelnen Widgets erweitern brauchen. Zum Verst&auml;ndnis der Programmierung eigener Dialogfenster sollten Sie aber trotzdem dieses Kapitel durcharbeiten.<br /><br />Der &quot;Visual Dialog Designer&quot; selbst ist komplett zu 100% in RapidBATCH geschrieben worden!</div>Um Widgets zu erzeugen verwenden wir die Anweisung NEWDIALOG. NEWDIALOG ben&ouml;tigt, wie im Beispielscript zu sehen, als Parameter ein so genanntes Widget-Label, welches man auch als Namen f&uuml;r das Widget ansehen kann; &Uuml;ber diesen Namen kann das Widget sp&auml;ter angesprochen werden.<br />Des weiteren erwartet NEWDIALOG einen Widget-Typ, der angibt, welche Art von Widget wir erzeugen m&ouml;chten (z.B. Dialogfenster, Button, einzeiliges Eingabefeld, mehrzeiliges Eingabefeld, usw.) sowie die Pixelkoordinaten und -dimensionen, um das Widget zu platzieren. Die Koordinaten werden dabei durch den bereits bekannten Standard-Listenseparator (normalerweise ein &quot;|&quot;-Zeichen (Pipe)) als String in der Form &quot;X-Koordinate|Y-Koordinate|Breite|H&ouml;he&quot; angegeben.<br /><br />In unserem Beispielscript erzeugen wir also mit der Anweisung<br /><br /><!-- code BEGIN --><div class="code">newdialog <font color="#0000ff">'myDialog'</font>, <font color="#0000ff">'DIALOG'</font>, <font color="#0000ff">'1|1|300|80'</font></div><!-- code END-->ein neues Widget vom Typ &quot;DIALOG&quot; (sprich: ein Dialog-Basisfenster) mit einer Breite von 300 Pixel und einer H&ouml;he von 80 Pixel am linken oberen Bildschirmrand (X- und Y-Koordinaten 1|1). Dieses Dialogelement wird unter dem Namen &quot;myDialog&quot; angelegt, &uuml;ber den wir sp&auml;ter auf das Element zugreifen k&ouml;nnen.<br /><br />Die zwei darauffolgenden NEWDIALOG-Anweisungen<br /><br /><!-- code BEGIN --><div class="code">newdialog <font color="#0000ff">'myDialog:Eingabe'</font>, <font color="#0000ff">'INPUT'</font>, <font color="#0000ff">'10|1|273|25'</font><br />newdialog <font color="#0000ff">'myDialog:Los'</font>, <font color="#0000ff">'BUTTON'</font>, <font color="#0000ff">'80|27|140|25'</font></div><!-- code END-->erstellen ein einzeiliges Eingabefeld (Typ: &quot;INPUT&quot;) und einen Button (Typ: &quot;BUTTON&quot;) auf unserem Dialog-Basisfenster &quot;myDialog&quot;.<br />Dass diese Widgets auf dem Basisdialog &quot;myDialog&quot; platziert werden, ist an der Voranstellung von &quot;myDialog:&quot; beim Widget-Label erkennbar. Die Widgets werden daher unter genau diesem Dialoglabel angelegt; Sinn und Zweck des ganzen ist, dass jedes Dialogelement auf einem Dialog einmalig (d.h. mit einem einmaligen Namen) sein muss, denn es k&ouml;nnen auch zwei oder mehr Dialogfenster zur selben Zeit angezeigt werden. Diese Dialogelemente werden als &quot;Child-Elemente&quot; bezeichnet, sie stellen so zusagen die Kinder des Dialogs &quot;myDialog&quot; dar, da sie auf &quot;myDialog&quot; angezeigt und diesem Basisfenster hierarchisch untergeordnet sind.<br />Die Angabe der Pixelkoordinaten ist bei allen Child-Widgets relativ zur linken oberen Ecke des Fensters.<br /><br />Nachdem wir nun die Widgets erzeugt haben, setzten wir f&uuml;r diese verschiedene Werte, in unserem Fall bekommt das Dialogfenster den Titel &quot;Hello World&quot;, der Button die Beschriftung &quot;Und los...&quot; und das Textfeld den Text &quot;Dies ist ein Text!&quot;.<br /><br /><!-- code BEGIN --><div class="code"><font color="#808080">rem Setzen der Werte/Eigenschaften</font><br />letdialog <font color="#0000ff">'myDialog'</font>, <font color="#0000ff">'CAPTION'</font>, <font color="#0000ff">'Hello World'</font><br />letdialog <font color="#0000ff">'myDialog:Eingabe'</font>, <font color="#0000ff">'TEXT'</font>, <font color="#0000ff">'Dies ist ein Text!'</font><br />letdialog <font color="#0000ff">'myDialog:Los'</font>, <font color="#0000ff">'CAPTION'</font>, <font color="#0000ff">'Und &los...'</font></div><!-- code END-->Alle Werte werden mit Hilfe der Anweisung LETDIALOG gesetzt. LETDIALOG erwartet als Parameter das Label des Widgets, bei dem eine Eigenschaft gesetzt werden soll, die Bezeichnung der Eigenschaft, die gesetzt werden soll, sowie den entsprechenden Wert. Der Eigenschaftsbezeichner &quot;CAPTION&quot; setzt die Beschriftung eines Widgets, die Eigenschaft &quot;TEXT&quot; den Text im Editierbereich von Eingabefeldern; Welche Eigenschaften unterst&uuml;tzt werden ist von Widget zu Widget unterschiedlich; Ein Listenfeld kann beispielsweise keine Beschriftung (CAPTION) haben, ein Dialogfenster kann keine Liste eines Listenfeldes aufnehmen. Es ist also vom Typ des Widgets abh&auml;ngig, was wie gesetzt wird. Wir werden jedoch sp&auml;ter genauer darauf eingehen.<br /><br />Mit der Zeile <br /><br /><!-- code BEGIN --><div class="code">letdialog <font color="#0000ff">'myDialog'</font>, <font color="#0000ff">'VISIBLE'</font>, <font color="#000080">[true]</font></div><!-- code END-->machen wir zu guter letzt noch das Fenster sichtbar; Nur Dialogfenster-Widgets sind nach ihrer Erstellung mit NEWDIALOG unsichtbar, da es nicht empfehlenswert ist, das Basisfenster schon zur Anzeige zu bringen wenn noch nicht alle Dialogelemente erzeugt und gesetzt wurden.<br /><br /><div class="remark">Anmerkung: Wenn Sie eigene Dialoge in RapidBATCH programmieren, stellen Sie bitte immer sicher, dass das Basisfenster auf sichtbar gesetzt wird, bevor Sie die Funktion RUNDIALOG (zu der wir gleich kommen werden) aufrufen; Ist dies nicht der Fall, wartet das Script solange, bis ein Ereignis auf dem nicht-sichtbaren Fenster geschieht; Und das wird nie der Fall sein, denn wie soll man zum Beispiel auf einem nicht-sichtbaren Fenster etwas anklicken?</div><br />Die soeben schon er&ouml;rterte Funktion RUNDIALOG startet nun eine interne Warteschleife, die auf Ereignisse vom Dialogfenster wartet.<br /><br /><!-- code BEGIN --><div class="code">rundialog <font color="#000080">[event]</font> = <font color="#0000ff">'0'</font></div><!-- code END-->Wenn nun beispielsweise ein Button gedr&uuml;ckt wurde, wird ein Ereignis (Event) ausgel&ouml;st. Die Funktion gibt in diesem Fall einen String im Format &quot;Ereignis_Widget-Label&quot; zur&uuml;ck. In unserem Script wird z.B. der String &quot;click_myDialog:Los&quot; zur&uuml;ckgegeben, wenn der &quot;Und Los...&quot;-Button, den wir zuvor definiert haben, angeklickt wurde.<br />Die bei RUNDIALOG als Parameter &uuml;bergebene Zahl ist die Anzahl an Millisekunden, die gewartet wird, bis ein optionaler Timeout eintritt (1 Sekunde entspricht 1000 Millisekunden). Dies bedeutet, dass das Fenster nur f&uuml;r eine bestimmte Zeit auf Ereignisse wartet. Tritt kein Ereignis ein, wird der Timeout ausgel&ouml;st - die Funktion gibt dann einen Leerstring zur&uuml;ck. In unserem Fall aber ist der Millisekunden Wert 0, d.h. RUNDIALOG hat keinen Timeout und wartet solange, bis irgendetwas mit oder auf dem Dialog passiert.<br /><br />Im darauffolgenden IF-Block &uuml;berpr&uuml;fen wir nun diesen von RUNDIALOG zur&uuml;ckgegebenen Event-String; Wenn also &quot;click_myDialog:Los&quot; eintrat, lesen wir mit der GETDIALOG-Funktion den Text des Textfeldes aus und geben ihn mit Hilfe der ECHO-Anweisung aus.<br /><br /><!-- code BEGIN --><div class="code">getdialog <font color="#000080">[text]</font> = <font color="#0000ff">'myDialog:Eingabe'</font>, <font color="#0000ff">'TEXT'</font><br />echo <font color="#0000ff">'Der Wert im Textfeld lautet: '</font> # <font color="#000080">[text]</font></div><!-- code END-->GETDIALOG ist sozusagen die umgekehrte Version von LETDIALOG: Hier lesen wir eine bestimmte Eigenschaft des ebenfalls bei der Funktion spezifizierten Dialoglabels aus, in diesem Fall die Eigenschaft &quot;TEXT&quot;.<br /><br />Mit der abschlieﬂenden UNTIL-Anweisung wird gew&auml;hrleistet, dass RUNDIALOG solange wieder neu aufgerufen wird, bis der Benutzer den Schlieﬂen-Button des Basisfensters klickt. Ist dies der Fall, gibt RUNDIALOG den Ereignis-String &quot;close_myDialog&quot; zur&uuml;ck, auf den wir entsprechend abpr&uuml;fen:<br /><br /><!-- code BEGIN --><div class="code"><b>repeat</b><br /><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem Dialog starten</font><br />&nbsp;&nbsp;&nbsp;&nbsp;rundialog <font color="#000080">[event]</font> = <font color="#0000ff">'0'</font><br /><br /><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem Ereignis auswerten</font><br />&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[event]</font> = <font color="#0000ff">'click_myDialog:Los'</font><br /><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rem Textfeld auslesen</font><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getdialog <font color="#000080">[text]</font> = <font color="#0000ff">'myDialog:Eingabe'</font>, <font color="#0000ff">'TEXT'</font><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Der Wert im Textfeld lautet: '</font> # <font color="#000080">[text]</font><br />&nbsp;&nbsp;&nbsp;&nbsp;<b>endif</b><br /><b>until</b> <font color="#000080">[event]</font> = <font color="#0000ff">'close_myDialog'</font></div><!-- code END-->Ich denke, dass Sie hiermit nun das grobe Verarbeitungskonzept von benutzerdefinierten Dialogen in RapidBATCH verstanden haben. Im n&auml;chsten Abschnitt werden wir genauer auf die verschiedenen Dialogelemente sowie ihre Eigenschaften und Ereignisse eingehen.<br /><br />

		<div class="line">&nbsp;</div>

		<div id="copyright">
			Copyright &copy; 2000-2006 by J.M.K S.F. Software Technologies, Jan Max Meyer<br />
			All rights reserved.
		</div>
	</body>
</html>
