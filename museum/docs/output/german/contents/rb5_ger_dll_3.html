<html>
	<head>
		<title>Ein Beispielprojekt</title>
		<link rel="stylesheet" href="jmksf.css" type="text/css"></link>
	</head>

	<body>
		<div id="top">
			<img src="rb5.png" alt="RapidBATCH Logo" />
			Ein Beispielprojekt
		</div>
		
		<div class="line">&nbsp;</div>
		
		Hier ein kleines Beispielprojekt mit dem kompletten C-Quellcode einer einfachen DLL-Datei und dem entsprechendem RapidBATCH-Script, welches diese DLL verwendet. Beide Dateien finden sich auch im Verzeichnis DLL\DemoDLL des RapidBATCH Installationsverzeichnisses.<br /><br />An dieser Stelle ein groﬂes Lob an Klaus Fischer (radix42) f&uuml;r das schreiben dieser Einf&uuml;hrung und f&uuml;r die Entwicklung der zahlreichen Beispiel-DLLs.<pre style="border: 0px;">// &lt;windows.h&gt; wird f&uuml;r alle Windows-Funktionen ben&ouml;tigt<br />#include &lt;windows.h&gt;<br /><br />// &lt;stdio.h&gt; wird f&uuml;r die Funktion "sprintf" ben&ouml;tigt<br />#include &lt;string.h&gt;<br />#include &lt;stdio.h&gt;<br /><br />//------------------------------------------------------------------------<br /><br />// Dies ist die Start-/Stop-Routine einer jeden DLL.<br />// Diese Routine wird beim Laden und Entladen der DLL aufgerufen.<br />// F&uuml;r die Funktion gilt die WINAPI Aufrufkonvention.<br /><br />BOOL WINAPI __declspec(dllexport) LibMain( HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved )<br />{<br />    switch( fdwReason )<br />    {<br />        case DLL_PROCESS_ATTACH:<br />			/*<br />			Dieser Teil wird ausgef&uuml;hrt, wenn die DLL geladen wird. Hier k&ouml;nnen<br />			allgemeine Initialisierungsroutinen aufgerufen werden.<br />			In diesem Beispiel wird eine MessageBox angezeigt, damit das Laden<br />			der DLL verfolgt werden kann.<br />			*/<br />			MessageBox( NULL, "DemoDLL.dll wurde geladen.", "RB5 DemoDLL", MB_ICONINFORMATION );<br />            break;<br />        case DLL_PROCESS_DETACH:<br />			/*<br />			Dieser Teil wird ausgef&uuml;hrt, wenn die DLL entladen wird. Hier wird<br />			wieder aufger&auml;umt, wenn das n&ouml;tig sein sollte.<br />			In diesem Beispiel wird ebenfalls eine MessageBox angezeigt.<br />			*/<br />			MessageBox( NULL, "DemoDLL.dll wird entladen.", "RB5 DemoDLL", MB_ICONINFORMATION );<br />            break;<br />    }<br />    return TRUE;<br />}<br /><br />//------------------------------------------------------------------------<br /><br />/* Hier die erste Funktion: rbxGetTickCount<br /><br />rbxGetTickCount ruft einfach die Windowsfunktion GetTickCount auf. Diese<br />liefert die Anzahl Millisekunden seit dem Start von Windows. Damit kann sehr<br />einfach die Dauer eines Vorgangs gemessen werden: EInfach vorher und nachher<br />rbxGetTickCount aufrufen und die Differenz bilden.<br /><br />ACHTUNG: GetTickCount liefert einen 32Bit Wert. Das reicht f&uuml;r ca. 49,7 Tage!<br />Dann l&auml;uft der Z&auml;hler einfach &uuml;ber. Daher sollte in einer echten Anwendung<br />&uuml;berpr&uuml;ft werden, ob der zweite Werte kleiner als der erste ist, um darauf<br />zu reagieren.<br /><br />Alle Funktionen, die von RB aus aufgerufen werden sollen, m&uuml;ssen wie hier<br />angegeben deklariert werden( bei anderen Compilern sieht die Syntax evtl.<br />anders aus ). Wichtig sind aber immer "_cdecl" und die Typen der Parameter.<br /><br />Output einh&auml;lt einen Zeiger auf eine Variable (die dann einen Zeiger auf<br />eine Zeichenkette enth&auml;lt). Input enth&auml;lt einen Zeiger auf ein Feld von<br />Zeigern auf Zeichenketten (die in RB &uuml;bergebenen Parameter). InputCount<br />enth&auml;lt die Anzahl der &uuml;bergebenen Parameter = die Anzahl der Elemente im<br />Feld Input.<br /><br />In dieser Funktion werden die &uuml;bergebenen Parameter einfach ignoriert.<br /><br />*/<br />int __declspec(dllexport) _cdecl rbxGetTickCount( char ** Output, char ** Input, int InputCount )<br />{<br />	// Zuerst pr&uuml;fen, ob Output auf etwas zeigt.<br />	// Wenn nicht, dann hier abbrechen.<br />	// Der Wert -1 steht f&uuml;r einen RapidBATCH-Fehler - dies kommt normalerweise nicht vor!<br />	// Es wird aber f&uuml;r alle F&auml;lle gepr&uuml;ft, um auf der sicheren Seite zu sein.<br />	if( Output == NULL )<br />		return( -1 );<br /><br />	// Einen Speicherbereich von Windows anfordern. "LPTR" bedeutet, dass der<br />	// Speicherbereich &uuml;ber die zur&uuml;ckgegebene Adresse ansprechbar ist und mit<br />	// Nullen gef&uuml;llt werden soll. Die zweite Angabe gibt die gew&uuml;nschte L&auml;nge<br />	// in Bytes (Zeichen) an. Wichtig: Es muss immer mindestens ein Byte mehr<br />	// angefordert werden, als maximal Zeichen benutzt werden, da am Ende immer<br />	// noch ein Null-Byte angef&uuml;gt wird. Da eine 32Bit-Zahl zur&uuml;ckgegeben wird,<br />	// sollten 15 Stellen reichen (15 Zeichen + 1 Null-Byte).<br />	// Die Adresse des Speicherbereichs wird in die Variable geschrieben, auf<br />	// die die Variable Output zeigt.<br />	*Output = LocalAlloc( LPTR, 16 );<br /><br />	// Pr&uuml;fen, ob die Speicheranforderung erfolgreich war. Wenn z.B. nicht genug<br />	// Speicher zur Verf&uuml;gung stand, wird NULL zur&uuml;ckgegeben. In diesem Fall<br />	// ebenfalls hier abbrechen (mit Fehler -1. s.o.). Dieser Fall sollte<br />	// normalerweise ebenfalls nicht eintreten.<br />	if( *Output == NULL )<br />		return( -1 );<br /><br />	// Jetzt kommt die klassische Ausgabe<br />	// Was alles wie mit "sprintf" geht, sollte bekannt sein (sonst K&R lesen)!<br />	// "GetTickCount" klappt lt. WinAPI immer, daher ist keine Pr&uuml;fung auf<br />	// evtl. Fehler n&ouml;tig und "GetTickCount" kann direkt in "sprintf" eingesetzt werden.<br />	sprintf( *Output, "%d", GetTickCount() );<br /><br />	// Das war's. Funktion beenden( "0" steht hier f&uuml;r "Erfolgreich", s.o. )<br />	return( 0 );<br /><br />}<br /><br />//------------------------------------------------------------------------<br /><br />/* Hier die zweite Funktion: rbxCreateWindowList<br /><br />rbxCreateWindowList erzeugt eine Liste der &Uuml;berschriften aller sichtbaren Fenster.<br />Die Listenelemente werden jeweils durch die als Parameter &uuml;bergebene Zeichenkette<br />getrennt. Zum Abrufen der Fensterliste wird die Windows-Funktion "EnumWindows"<br />verwendet, die f&uuml;r jedes Fenster eine sogenannte Callback-Funktion aufruft. Das ist<br />eine anwenderdefinierte Funktion, deren Adresse an "EnumWindows" &uuml;bergeben wird.<br />Die Definition der Parameter und des R&uuml;ckgabewerts ist festgelegt. Diese Funktion<br />wird von der Windows-Funktion "EnumWindows" f&uuml;r jedes Fenster aufgerufen. Dabei wird<br />jeweils eine Fensternummer (Window-Handle) &uuml;bergeben. Diese Funktion wird im folgenden<br />definiert. Sie wird nicht exportiert, da sie nicht von RB aus benutzt wird und Windows<br />die Adresse ja beim Aufruf von "EnumWindows" &uuml;bergeben bekommt.<br /><br />Der Name der Funktion und die Namen der Parameter sind frei w&auml;hlbar, es wird hier<br />der Einfachheit halber die Definition der Funktion in der Windows-API selbst benutzt.<br /><br />Im Parameter "hwnd" wird jeweils eine Fensternummer &uuml;bergeben. Der Parameter "lParam"<br />wird vom Anwenderprogramm an "EnumWindows" &uuml;bergeben und von dort weiter an die<br />Funktion "EnumWindowsProc". Damit kann mann der Callback-Funktion noch eigene Parameter<br />&uuml;bergeben (alternativ k&ouml;nnten globale Variablen verwendet werden). In unserem Beispiel<br />wird in die Variable nicht benutzt.<br /><br />Die &Uuml;berschriften werden in einen vorher angeforderten Puffer geschrieben. Die Gr&ouml;sse<br />sollte ausreichen, trotzdem muss nat&uuml;rlich ein &Uuml;berlauf abgefangen werden. F&uuml;r die<br />Gr&ouml;sse wird eine Konstante per "#define" deklariert, so dass bei Bedarf nur eine Stelle<br />im Quelltext ge&auml;ndert werden muss.<br />*/<br /><br />#define BUFFSIZE 10000  // 10000 Bytes sollten reichen, bei Bedarf erh&ouml;hen<br />#define TEXTSIZE   100  //   100 Bytes pro Titel, l&auml;ngere Titel werden abgeschnitten<br /><br />// hier noch eine Fehlernummer<br />#define ERROR_BAD_INPUT 11<br /><br />// Hier zwei globale Variablen, die auf den Puffer f&uuml;r die &Uuml;berschriften<br />// und die Trennzeichenkette zeigem<br />char* gsSeparator	= (char*)NULL;<br />char* gsBuffer		= (char*)NULL;<br /><br />//------------------------------------------------------------------------<br /><br />/* Hier die Callback-Funktion.<br /><br />In der Variablen hwnd wird jeweils eine Fensternummer &uuml;bergeben. Der Parameter "lParam"<br />wird nicht benutzt (es wird NULL &uuml;bergeben).<br />*/<br /><br />BOOL CALLBACK EnumWindowsProc( HWND hwnd, LPARAM lParam )<br />{<br />	// Zuerst einige lokale Variablen<br />	char	Title[TEXTSIZE];<br />	memset( Title, '\0', TEXTSIZE );<br /><br />	// Titel des angegebenen Fensters holen<br />	// als max. L&auml;nge wird "TEXTSIZE-1" &uuml;bergeben, um auf jeden Fall Platz f&uuml;r<br />	// das Null-Byte am Ende zu haben.<br />	GetWindowText( hwnd, Title, TEXTSIZE-1 );<br /><br />	// Pr&uuml;fen, ob der Titel nicht leer ist, sonst die Funktion beenden<br />	if( *Title != 0 )<br />	{<br />		// Pr&uuml;fen, ob das Fenster sichtbar ist, sonst dieses Fenster<br />		// ignorieren und das evtl. n&auml;chste anfordern.<br />		if( IsWindowVisible( hwnd ) )<br />		{<br />			// Das Fenster hat eine nicht leere &Uuml;berschrift und ist sichtbar,<br />			// also in die Liste aufnehmen.<br /><br />			// Zuerst pr&uuml;fen, ob die Liste schon etwas enth&auml;lt<br />			if( *gsBuffer != 0 )<br />				// Ja, die Liste ist nicht leer,<br />				// also zuerst die Trennzeichenkette anh&auml;ngen<br />				strcat( gsBuffer, gsSeparator );<br />			// Dann den Fenstertitel des &uuml;bergebenen Fensters anh&auml;ngen<br />			strcat( gsBuffer, Title );<br /><br />			// Jetzt wird gepr&uuml;ft, ob noch gen&uuml;gend Platz im Puffer f&uuml;r<br />			// eine weitere Trennzeichenkette und eine weitere &Uuml;berschrift ist<br />			if( strlen( gsBuffer ) + strlen( gsSeparator ) + TEXTSIZE &lt; BUFFSIZE )<br />				// Ja, noch genug Platz, also TRUE zur&uuml;ckgeben,<br />			    // um evtl. weitere Fensternummer anzufordern.<br />				return( TRUE );<br />			else<br />				// Nein, der Puffer ist fast voll. Die Aufz&auml;hlung der Fenster<br />				// an dieser Stelle beenden( auch wenn noch ein kurzer<br />			    // Fenstertitel Platz gehabt h&auml;tte ).<br />				return( FALSE );<br />		}<br />	}<br />	<br />	// TRUE bedeutet, das weitere Fensternummern geliefert werden sollen<br />	//(soweit vorhanden)<br />	return( TRUE );<br />}<br /><br />//------------------------------------------------------------------------<br /><br />/* Hier die eigentliche Funktion: rbxCreateWindowList<br /><br />Diese Funktion ben&ouml;tigt einen Parameter: Den Zeiger auf eine Trennzeichenkette.<br />Sinnvollerweise wird hier die RB-Konstante [std_sep] oder [new_line] &uuml;bergeben.<br /><br />Diese Funktion ruft dann die Windows-Funktion "EnumWindows" auf, die dann f&uuml;r jedes<br />Fenster die oben definierte Callback-Funktion "EnumWIndowsProc" aufruft.<br /><br />*/<br /><br />int __declspec(dllexport) _cdecl rbxCreateWindowList( char ** Output, char ** Input, int InputCount )<br />{<br />	// Zuerst wieder die Pr&uuml;fung der Parameter. Zus&auml;tzlich zu "Output" werden<br />	// jetzt aber auch "Input" und "InputCount" &uuml;berpr&uuml;ft. Ausserdem darf die<br />	// &uuml;bergebene Trennzeichenkette nicht zu lang sein (w&auml;re sie z.B. "BUFFSIZE"<br />	// Zeichen lang, w&uuml;rde es beim zweiten Fenster, das in die Liste aufgenommen<br />	// werden soll, zu einem Puffer&uuml;berlauf kommen). Um die entsprechende Pr&uuml;fung<br />	// in der Funktion "EnumWindowsProc zu sparen, wird einfach die L&auml;nge beschr&auml;nkt.<br />	<br />	if( Output == NULL )<br />		return( -1 );<br /><br />	// Einen Speicherbereich von Windows anfordern. Als Gr&ouml;sse wird hier<br />	// die Konstannte "BUFFSIZE" benutzt. "LocalAlloc" f&uuml;llt den Speicher-<br />	// bereich mit Nullen, das entspricht einer leeren Zeichkette.<br />	*Output = LocalAlloc( LPTR, BUFFSIZE );<br /><br />	// Pr&uuml;fen, ob die Speicheranforderung erfolgreich war.<br />	if( *Output == NULL )<br />		return( -1 );<br /><br />	// Jetzt wird die Anzahl der Parameter &uuml;berpr&uuml;ft sowie die Trennzeichenkette selbst<br />	// "Input == NULL" und "*Input == NULL" d&uuml;rften nicht eintreten, wenn "InputCount == 1" gilt<br />	// "**Input == 0" pr&uuml;ft auf eine leere Zeichenkette (ist das erste Zeichen == 0)<br />	if( InputCount != 1 || Input == NULL || *Input == NULL || **Input == 0 || strlen( *Input ) &gt; TEXTSIZE )<br />	{<br />		// Es wird eine leere Zeichenkette zur&uuml;ckgegeben (LocalAlloc hat ja den<br />		//  angeforderten Speicherbereich mit Nullen gef&uuml;llt).<br />		// Der R&uuml;ckgabewert der Funktion (hier z.B. 11) wird von RapidBATCH<br />		//  in der Variablen [errorcode] gespeichert.<br />		return( ERROR_BAD_INPUT );<br />	}<br />	<br />	// Der Puffer ist verf&uuml;gbar, die Trennzeichenkette ist korrekt<br />	// Jetzt k&ouml;nnte die Funktion "EnumWindowsProc" aufgerufen werden.<br />	// Allerdings hat die Funktion keinen Zugriff auf die Variablen<br />	// und Parameter dieser Funktion, deshalb werden die ben&ouml;tigten<br />	// Werte zus&auml;tzlich in globalen Variablen gespeichert<br />	gsBuffer = *Output;<br />	gsSeparator = *Input;<br />	<br />	// Jetzt ist aber alles bereit, los geht's<br />	// Der R&uuml;ckgabewert der Funktion "EnumWindows" wird ignoriert,<br />	// da er dem letzten R&uuml;ckgabewert der Funktion "EnumWindowsProc"<br />	// entspricht und das Ergenbis ("TRUE" oder "FALSE") in diesem Beispiel<br />    // keine Rolle spielt.<br />	// Der zweite Parameter (hier "NULL") wird von "EnumWindows" an unsere<br />	// Callback-Funktion "EnumWindowsProc" weitergereicht. Da er nicht ben&ouml;tigt<br />	// wird, wird hier "NULL" &uuml;bergeben.<br />	EnumWindows( EnumWindowsProc, (LPARAM)NULL );<br />	<br />	// EnumWindows ruft jetzt unsere Funktion "EnumWindowsProc" mit allen<br />	// Fensternummern auf und kehrt dann hierhin zur&uuml;ck.<br />	// An dieser Stelle ist die Liste der Fenster&uuml;berschriften erstellt.<br />	// Bleibt nur noch das Beenden dieser Funktion. Der R&uuml;ckgabewert<br />	// ist 0 (Null), um den erfolgreichen Abschluss anzuzeigen.<br />	<br />	return( 0 );<br />	<br />}<br /><br />//------------------------------------------------------------------------<br /><br />// Das war's - viel Spass beim Selbermachen...</pre>Und das dazugeh&ouml;rige Aufruf-Script:<br /><br /><!-- code BEGIN --><div class="code"><font color="#808080">rem Dieses Skript demonstriert die Benutzung von DLLs mit dem EXT-Befehl</font><br /><font color="#808080">rem (es wird die DLL DemoDLL.dll verwendet).</font><br /><br /><font color="#808080">rem Startzeit lesen. Es wird die Funktion rbxGetTickCount aus der</font><br /><font color="#808080">rem DLL DemoDLL.dll verwendet. Diese Funktion liefert die Zeit in</font><br /><font color="#808080">rem Millisekunden seit dem Start von Windows.</font><br /><br /><font color="#808080">rem Bei diesem ersten Aufruf einer Funktion aus DemoDLL.dll wird</font><br /><font color="#808080">rem die DLL geladen - das wird &uuml;ber eine MessageBox signalisiert.</font><br /><font color="#808080">rem Bei weiteren Aufrufen wird die DLL im Speicher benutzt,</font><br /><font color="#808080">rem daher keine weiteren Meldungen der DLL.</font><br /><br /><b>ext</b> <font color="#000080">[StartTime]</font> = <font color="#0000ff">'DemoDLL.dll'</font>, <font color="#0000ff">'rbxGetTickCount'</font><br /><font color="#808080">rem Auf Fehler &uuml;berpr&uuml;fen</font><br /><b>if</b> <font color="#000080">[errorcode]</font> ! <font color="#0000ff">'0'</font><br />&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Fehler beim Aufruf von &lt;rbxGetTickCount&gt; in DemoDLL.dll'</font><br />&nbsp;&nbsp;&nbsp;&nbsp;<b>halt</b><br /><b>endif</b><br /><br /><font color="#808080">rem MessageBox anzeigen und Aktion des Benutzers abwarten.</font><br /><font color="#808080">rem Der Stil '262196' entspricht '4' + '48' + '262144',</font><br /><font color="#808080">rem d.h. ein '!' anzeigen (4) und die Auswahl Ja/Nein (48)</font><br /><font color="#808080">rem anbieten. Ausserdem soll die MessageBox immer im</font><br /><font color="#808080">rem Vordergrund bleiben (262144).</font><br />msgbox <font color="#0000ff">'DemoDLL.rb'</font>, <font color="#0000ff">'Entscheiden Sie sich!'</font>, <font color="#0000ff">'262196'</font><br /><br /><font color="#808080">rem Stopzeit holen</font><br /><b>ext</b> <font color="#000080">[StopTime]</font> = <font color="#0000ff">'DemoDLL.dll'</font>, <font color="#0000ff">'rbxGetTickCount'</font><br /><font color="#808080">rem Auf Fehler &uuml;berpr&uuml;fen</font><br /><b>if</b> <font color="#000080">[errorcode]</font> ! <font color="#0000ff">'0'</font><br />&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Fehler beim Aufruf von &lt;rbxGetTickCount&gt; in DemoDLL.dll'</font><br />&nbsp;&nbsp;&nbsp;&nbsp;<b>halt</b><br /><b>endif</b><br /><br /><font color="#808080">rem Zeitdifferenz berechnen, umrechnen in Sekunden.</font><br /><font color="#000080">[Differenz]</font> = (<font color="#000080">[StopTime]</font> - <font color="#000080">[StartTime]</font>) / <font color="#0000ff">'1000'</font><br /><br /><font color="#808080">rem Ergebnis anzeigen. Der Stil '64' zeigt das Symbol (i)</font><br /><font color="#808080">rem vor der Meldung an.</font><br />msgbox <font color="#0000ff">'DemoDLL.rb'</font>, <font color="#0000ff">'Sie haben '</font> # <font color="#000080">[Differenz]</font> # <font color="#0000ff">' Sekunden gebraucht, um sich zu entscheiden. '</font>, <font color="#0000ff">'64'</font><br /><br /><font color="#808080">rem Jetzt wird eine Liste der sichtbaren Fenster erstellt</font><br /><font color="#808080">rem mit der Funktion rbxCreateWindowList. Als Trennzeichen</font><br /><font color="#808080">rem wird ein Zeilenumbruch ([new_line]) verwendet, damit</font><br /><font color="#808080">rem das Ergebnis mit einer MessageBox angezeigt werden kann.</font><br /><b>ext</b> <font color="#000080">[WindowList]</font> = <font color="#0000ff">'DemoDLL.dll'</font>, <font color="#0000ff">'rbxCreateWindowList'</font>, <font color="#000080">[new_line]</font><br /><font color="#808080">rem Auf Fehler &uuml;berpr&uuml;fen</font><br /><b>if</b> <font color="#000080">[errorcode]</font> ! <font color="#0000ff">'0'</font><br />&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Fehler beim Aufruf von &lt;rbxCreateWindowList&gt; in DemoDLL.dll'</font><br />&nbsp;&nbsp;&nbsp;&nbsp;<b>halt</b><br /><b>endif</b><br /><br /><font color="#808080">rem Liste mit einer MessageBox anzeigen</font><br />msgbox <font color="#0000ff">'DemoDLL.rb'</font>, <font color="#0000ff">'Es wurden folgende Fenster gefunden:'</font> # <font color="#000080">[new_line]</font> # <font color="#000080">[new_line]</font> # <font color="#000080">[WindowList]</font>, <font color="#0000ff">'64'</font><br /><br /><font color="#808080">rem Jetzt wird noch die Fehlerpr&uuml;fung getestet - dazu wird die</font><br /><font color="#808080">rem Funktion rbxCreateWindowList ohne Parameter aufgerufen. Das sollte</font><br /><font color="#808080">rem den Fehler 11 liefern (s. DemoDLL.c).</font><br /><b>ext</b> <font color="#000080">[WindowList]</font> = <font color="#0000ff">'DemoDLL.dll'</font>, <font color="#0000ff">'rbxCreateWindowList'</font><br /><font color="#808080">rem Auf Fehler &uuml;berpr&uuml;fen</font><br /><b>if</b> <font color="#000080">[errorcode]</font> ! <font color="#0000ff">'11'</font><br />&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Unerwarteter Fehlercode beim Aufruf von &lt;rbxCreateWindowList&gt; in DemoDLL.dll'</font><br />&nbsp;&nbsp;&nbsp;&nbsp;<b>halt</b><br /><b>endif</b><br /><br /><font color="#808080">rem Korrekten Fehlercode melden</font><br />msgbox <font color="#0000ff">'DemoDLL.rb'</font>, <font color="#0000ff">'Die Parameterpr&uuml;fung in &lt;rbxCreateWindowList&gt; hat geklappt.'</font>, <font color="#0000ff">'64'</font><br /><br /><font color="#808080">rem Das war's.</font><br /><br /><font color="#808080">rem DemoDLL.dll wird jetzt entladen, was ebenfalls mit einer MessageBox</font><br /><font color="#808080">rem angezeigt wird.</font><br /><br /><b>end</b></div><!-- code END--><br /><br />

		<div class="line">&nbsp;</div>

		<div id="copyright">
			Copyright &copy; 2000-2006 by J.M.K S.F. Software Technologies, Jan Max Meyer<br />
			All rights reserved.
		</div>
	</body>
</html>
