template_ref_en.html§0TITLE§1SYNTAX§1DESCRIPTION§1EXAMPLE§1REMARKS
rb5ref_en_1_dec_reset.html§DEC, RESET§DEC variable1 [,variable2 [ ... variable<sup/>n</sup/>] ]<br><!-- br -->RESET variable1 [,variable2 [ ... variable<sup/>n</sup/>] ]§DEC declares one or more new variables for their use within the script.<br><!-- br -->If DEC is called within a procedure, all variables are declared locally, also, if a globally declared variable with the same name exists, DEC re-declares a new variable with this name locally. If DEC is used to declare variables outside a procedure, the variables are globally available in the whole script instance and can be read or written.<br><!-- br -->DEC can also be used to pre-dimension arrays, by specifying the desired array default sizes and dimensions.<!-- br --><br><!-- br -->Next to DEC, the RESET instruction is provided, that is used to clear an array for further use. By resetting an array or a variable, it is completely freed from the memory. Only the variable itself exists further. By specifiying a desired array dimension, only the dimension including its sub-dimensions is cleared.§<!-- CODE BEGIN --><b>dec</b> <font color="#000080">[a]</font>, <font color="#000080">[numbers:'5']</font><br /><!-- br --><br /><!-- br --><font color="#000080">[a]</font> = <font color="#0000ff">'a value'</font><br /><!-- br --><font color="#000080">[numbers:'1']</font> = <font color="#0000ff">'5'</font><br /><!-- br --><font color="#000080">[numbers:'2']</font> = <font color="#0000ff">'13'</font><br /><!-- br --><font color="#000080">[numbers:'3']</font> = <font color="#0000ff">'21'</font><br /><!-- br --><font color="#000080">[numbers:'4']</font> = <font color="#0000ff">'79'</font><br /><!-- br --><font color="#000080">[numbers:'5']</font> = <font color="#0000ff">'2005'</font><br /><!-- br --><br /><!-- br -->echo <font color="#0000ff">'[a] contains '</font> # <font color="#000080">[a]</font><br /><!-- br -->echo <font color="#0000ff">'The array currently contains '</font> # <font color="#000080">[numbers:'0']</font> # <font color="#0000ff">' items'</font><br /><!-- br --><br /><!-- br --><b>reset</b> <font color="#000080">[a]</font>, <font color="#000080">[numbers]</font><br /><!-- br --><br /><!-- br -->echo <font color="#0000ff">'[a] contains '</font> # <font color="#000080">[a]</font><br /><!-- br -->echo <font color="#0000ff">'The array contains now '</font> # <font color="#000080">[numbers:'0']</font> # <font color="#0000ff">' items'</font><br /><!-- br --><b>end</b><!-- CODE END -->§Since RapidBATCH 4.0, it is not necessary anymore to declare variables manually. If a value is assigned to an unexisting variable, it is automatically declared. By calling an undeclared variable, an empty string is returned. But DEC is also indispensable for a tidy programming style, for example it should be used within self-defined procedures to avoid conflicts with maybe existing, globally declared variables.<!-- br --><br><!-- br --><br><!-- br -->Reset is only used for manual memory management, and must not be called to free arrays or variable contents from the memory. This is done automatically by RapidBATCH when the script ends.
rb5ref_en_1_if_elseif_else_endif.html§IF...ELSEIF...ELSE...ENDIF§IF condition code<br><!-- br --><br><!-- br -->IF condition<br><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;{block of code}<br><!-- br -->[ELSEIF condition<br><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;{block of code}]<br><!-- br -->[ELSE<br><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;{block of code}]<br><!-- br -->ENDIF§The IF-instruction allows for conditional processing. It performs a comparison on two values and runs any RapidBATCH instruction if the result of the comparison is TRUE. Alternative to only one instruction, an instruction-block can be specified that is closed by the next ENDIF-instruction. Those IF-constructions can also have an ELSEIF-block, that can verify another condition (if the first IF or prior ELSEIF failed), or ELSE-block which is executed if the condition's result is false. There can be only one IF and only one ELSE in an IF-block. ELSEIF-blocks can be specified in any amount.<br><br><!-- br --><!-- br -->In RapidBATCH, a condition is a comparison of two values. The programmer is able to compare to equal (=), not-equal (!), greater-than (&gt;) and lower-than (&lt;). Also, the operators greater-equal (&gt;=) and lower-equal (&lt;=) are supported (since RapidBATCH 5.0.5). You can compare two variables, a variable with a constant value or two constant values (which is not very sensefull, but maybe useable for a condition that should always or never be executed, e.g. for debugging purposes, etc.).<br><br><!-- br --><!-- br -->To verify more than one conditon in one IF or ELSEIF, you can use the logical operators AND (&amp;) and OR (|). The &amp;-operator returns only TRUE, when all conditions linked with this operator succeded. The |-operator succeeds only when one of the conditions return TRUE. Please refer the examples below.§<b>if</b> <font color="#000080">[a]</font> = <font color="#000080">[b]</font> echo <font color="#0000ff">'A is equal to B!'</font><br /><br /><!-- br --><b>if</b> <font color="#000080">[a]</font> &gt;= <font color="#000080">[b]</font> echo <font color="#0000ff">'A is equal or greater than B!'</font><br /><!-- br --><br /><!-- br --><b>if</b> <font color="#000080">[password]</font> = <font color="#0000ff">'swordfish'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Login accomplished.'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[admin]</font> = <font color="#0000ff">'false'</font><br /><!-- br --><b>elseif</b> <font color="#000080">[password]</font> = <font color="#0000ff">'master'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'You have administrational rights.'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[admin]</font> = <font color="#0000ff">'true'</font><br /><!-- br --><b>else</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Wrong password!'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>halt</b><br /><!-- br --><b>endif</b><br /><!-- br --><br /><!-- br --><b>if</b> <font color="#000080">[a]</font> &lt; <font color="#0000ff">'10'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Error!'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>halt</b><br /><!-- br --><b>elseif</b> <font color="#000080">[b]</font> &lt;= <font color="#0000ff">'5'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Now everything is fine!'</font><br /><!-- br --><b>endif</b><br /><!-- br --><br /><!-- br --><font color="#808080">rem Logical AND-operator succeeds only when both</font><br /><!-- br --><font color="#808080">rem variables contain the value 10</font><br /><!-- br --><font color="#000080">[a]</font> = <font color="#0000ff">'10'</font><br /><!-- br --><font color="#000080">[b]</font> = <font color="#000080">[a]</font><br /><!-- br --><b>if</b> <font color="#000080">[a]</font> = <font color="#0000ff">'10'</font> & <font color="#000080">[b]</font> = <font color="#0000ff">'10'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'A and B are both containing 10!'</font><br /><!-- br --><b>endif</b><br /><!-- br --><br /><!-- br --><font color="#808080">rem Logical OR-operator succeeds only when one of the</font><br /><!-- br --><font color="#808080">rem variables contains the value 10</font><br /><!-- br --><font color="#000080">[a]</font> = <font color="#0000ff">'11'</font><br /><!-- br --><font color="#000080">[b]</font> = <font color="#0000ff">'10'</font><br /><!-- br --><b>if</b> <font color="#000080">[a]</font> = <font color="#0000ff">'10'</font> | <font color="#000080">[b]</font> = <font color="#0000ff">'10'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'A or B contains 10!'</font><br /><!-- br --><b>endif</b><br /><!-- br --><br /><!-- br --><font color="#808080">rem More complex structure of AND- and OR-operators</font><br /><!-- br --><b>if</b> <font color="#000080">[a]</font> = <font color="#0000ff">'10'</font> & <font color="#000080">[b]</font> = <font color="#0000ff">'10'</font> | <font color="#000080">[a]</font> = <font color="#0000ff">'9'</font> & <font color="#000080">[b]</font> = <font color="#0000ff">'12'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Running Calculator...'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;call <font color="#0000ff">'c:\windows\calc.exe'</font>, <font color="#0000ff">'show'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Continuing...'</font><br /><!-- br --><b>endif</b>§IF-blocks can be combined in any order.
rb5ref_en_1_repeat_until_break_cont.html§REPEAT...[CONT] ... [BREAK] ... UNTIL§REPEAT<br><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;{block of code}<br><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[CONT]<br><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;{block of code}<br><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[BREAK]<br><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;{block of code}<br><!-- br -->UNTIL breaking-condition§With REPEAT and UNTIL, you're able to construct loops, that repeat a block of instructions until the specified condition is verified to true.<br><br><!-- br --><!-- br -->In RapidBATCH, a condition is a comparison of two values. The programmer is able to compare to equal (=), not-equal (!), greater-than (&gt;) and lower-than (&lt;). Also, the operators greater-equal (&gt;=) and lower-equal (&lt;=) are supported (since RapidBATCH 5.0.5). You can compare two variables, a variable with a constant value or two constant values (which is not very sensefull, but maybe useable for a condition that should always or never be executed, e.g. for debugging).<br><br><!-- br --><!-- br -->To verify more than one conditon in one UNTIL, you can use the logical operators AND (&amp;) and OR (|). The &amp;-operator <!-- br -->returns only TRUE, when all conditions linked with this operator succeded. The |-operator succeeds only when one of the <!-- br -->conditions return TRUE. Please refer the examples below.<!-- br --><br><br><!-- br --><!-- br -->Using the BREAK-instruction, the current loop can be left before the breaking condition is reached, for example if an error occurs within the loop.<br><!-- br -->Also it is possible to continue the loop by avoiding the breaking instruction using the CONT instruction. If CONT is used, RapidBATCH will start the next loop-cycle immediatelly without executing the possible lines behind the CONT or the loops breaking-condition specified at UNTIL.§<font color="#808080">rem a simple loop, counting from 1 to 10</font><br /><!-- br --><font color="#000080">[i]</font> = <font color="#0000ff">'0'</font><br /><!-- br --><b>repeat</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> + <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Number '</font> # <font color="#000080">[i]</font><br /><!-- br --><b>until</b> <font color="#000080">[i]</font> = <font color="#0000ff">'10'</font><br /><!-- br --><br /><!-- br --><!-- br --><font color="#808080">rem a loop using a logical operator in the breaking condition</font><br /><!-- br --><font color="#000080">[a]</font> = <font color="#0000ff">'0'</font><br /><!-- br --><font color="#000080">[b]</font> = <font color="#0000ff">'0'</font><br /><!-- br --><b>repeat</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[a]</font> + <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[b]</font> + <font color="#0000ff">'2'</font><br /><!-- br --><b>until</b> <font color="#000080">[a]</font> &gt; <font color="#0000ff">'10'</font> &amp; <font color="#000080">[b]</font> &gt; <font color="#0000ff">'20'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem leaving a loop when [i] is greater than 5, using</font><br /><!-- br --><font color="#808080">rem the BREAK-instruction</font><br /><!-- br --><font color="#000080">[i]</font> = <font color="#0000ff">'0'</font><br /><!-- br --><b>repeat</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> + <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[i]</font> &gt; <font color="#0000ff">'5'</font> <b>break</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Number: '</font> # <font color="#000080">[i]</font><br /><!-- br --><b>until</b> <font color="#000080">[i]</font> = <font color="#0000ff">'10'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem skipping the output of echo when [i] equals 5, using</font><br /><!-- br --><font color="#808080">rem the CONT-instruction</font><br /><!-- br --><font color="#000080">[i]</font> = 0<br /><!-- br --><b>repeat</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> + <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[i]</font> = <font color="#0000ff">'5'</font> <b>cont</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Number: '</font> # <font color="#000080">[i]</font><br /><!-- br --><b>until</b> <font color="#000080">[i]</font> = <font color="#0000ff">'10'</font><!-- br -->§REPEAT...UNTIL-loops can be nested together without problems.<br><!-- br --><br><!-- br -->The instructions BREAK and CONT may only be used within loops.<br><!-- br --><br><!-- br -->If the breaking-condition is not reached, the script execution ends in a never-ending loop, so be sure the condition you specify is reached. Also, the CONT-instruction must be used very carefully.
rb5ref_en_1_goto.html§GOTO§GOTO label<br><!-- br -->.<br><!-- br -->.<br><!-- br -->.<br><!-- br -->%label§GOTO calls a specified label in the script, and continues the script execution behind this label. This possibility allows you to write ultra-complex scripts. A label is specified in the script with a beginning %-character.<br><br><!-- br --><!-- br -->Since RapidBATCH 5.0, it is possible to call variable labels, so that also a single variable, containing the target-label or a target-label composed of both variable and static parts can be specified.§<font color="#808080">rem performing a static label call</font><br /><!-- br -->echo <font color="#0000ff">'Welcome to the GOTO test script!'</font><br /><!-- br --><b>goto</b> <font color="#0000ff">'next'</font><br /><!-- br --><br /><!-- br -->echo <font color="#0000ff">'You will never see this message :('</font><br /><!-- br --><br /><!-- br -->%next<br /><!-- br --><br /><!-- br --><font color="#808080">rem performing a dynamic label call</font><br /><!-- br -->include <font color="#0000ff">'dialog.rb'</font><br /><!-- br -->btnmenu <font color="#000080">[speed]</font> = <font color="#0000ff">'Please select a speed:'</font>, <font color="#0000ff">'20 mph|60 mph|100 mph'</font><br /><!-- br --><br /><!-- br --><b>goto</b> <font color="#000080">[speed]</font><br /><!-- br --><br /><!-- br -->%20 mph<br /><!-- br -->echo <font color="#0000ff">'This speed is very slow.'</font><br /><!-- br --><b>goto</b> <font color="#0000ff">'continue'</font><br /><!-- br --><br /><!-- br -->%60 mph<br /><!-- br -->echo <font color="#0000ff">'This speed is well!'</font><br /><!-- br --><b>goto</b> <font color="#0000ff">'continue'</font><br /><!-- br --><br /><!-- br -->%100 mph<br /><!-- br -->echo <font color="#0000ff">'TOO FAST! You wanna race???'</font><br /><!-- br --><br /><!-- br -->%continue<br /><!-- br -->echo <font color="#0000ff">'Enjoy your '</font> # <font color="#000080">[speed]</font> # <font color="#0000ff">' ;) ...'</font>§The label specified at GOTO may not begin with the %-character.<br><!-- br -->When using GOTO within a procedure, it is not allowed to call a label out of the current or in an other procedure. In this case, the script execution stops with a corresponding error message. Calling labels that are defined in included files is possible.
rb5ref_en_1_gosub_resume.html§GOSUB, RESUME§GOSUB label<br><!-- br -->.<br><!-- br -->.<br><!-- br -->.<br><!-- br -->%label<br><!-- br -->.<br><!-- br -->.<br><!-- br -->.<br><!-- br -->RESUME§Same as GOTO, GOSUB calls a specified label in the script, and continues the script execution behind this label. The difference to GOTO is, that GOSUB calls the label as a tiny sub-routine, and executes all code until the next RESUME-instruction is called. The RESUME-instruction returns to the line behind the last GOSUB-call. This possibility allows you to write ultra-complex scripts. A label is specified in the script with a beginning %-character. GOSUB...RESUME constructions can be combined into complex structures of sub-program calls, also recoursive calls are possible.<br><br><!-- br --><!-- br -->Since RapidBATCH 5.0, it is possible to call variable labels, so that also a single variable, containing the target-label or a target-label composed of both variable and static parts can be specified.§<font color="#808080">rem performing a static GOSUB-call</font><br /><!-- br --><font color="#000080">[i]</font> = <font color="#0000ff">'0'</font><br /><!-- br --><b>repeat</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> + <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>gosub</b> <font color="#0000ff">'square'</font><br /><!-- br --><b>until</b> <font color="#000080">[i]</font> = <font color="#0000ff">'10'</font><br /><!-- br --><br /><!-- br --><b>goto</b> <font color="#0000ff">'dynamic_gosub'</font><br /><!-- br --><br /><!-- br -->%square<br /><!-- br -->echo <font color="#000080">[i]</font> # <font color="#0000ff">' * '</font> # <font color="#000080">[i]</font> # <font color="#0000ff">' = '</font> # (<font color="#000080">[i]</font> * <font color="#000080">[i]</font>)<br /><!-- br --><b>resume</b><br /><!-- br --><br /><!-- br -->%dynamic_gosub<br /><!-- br --><font color="#808080">rem performing a dynamic GOSUB-call</font><br /><!-- br --><font color="#808080">rem (this example looks the same like the one at GOTO, but has another</font><br /><!-- br --><font color="#808080">rem flow and structure)</font><br /><!-- br --><br /><!-- br -->include <font color="#0000ff">'dialog.rb'</font><br /><!-- br -->btnmenu <font color="#000080">[speed]</font> = <font color="#0000ff">'Please select a speed:'</font>, <font color="#0000ff">'20 mph|60 mph|100 mph'</font><br /><!-- br --><br /><!-- br --><b>gosub</b> <font color="#000080">[speed]</font><br /><!-- br --><br /><!-- br -->echo <font color="#0000ff">'Enjoy your '</font> # <font color="#000080">[speed]</font> # <font color="#0000ff">' ;) ...'</font><br /><!-- br --><b>halt</b><br /><!-- br --><br /><!-- br -->%20 mph<br /><!-- br -->echo <font color="#0000ff">'This speed is very slow.'</font><br /><!-- br --><b>resume</b><br /><!-- br --><br /><!-- br -->%60 mph<br /><!-- br -->echo <font color="#0000ff">'This speed is well!'</font><br /><!-- br --><b>resume</b><br /><!-- br --><br /><!-- br -->%100 mph<br /><!-- br -->echo <font color="#0000ff">'TOO FAST! You wanna race???'</font><br /><!-- br --><b>resume</b>§If no RESUME is given, the GOSUB does the same like a GOTO.<br><!-- br -->If RESUME is called without a previous call of GOSUB, RESUME will do nothing and the script is executed behind the RESUME.<br><br><!-- br --><!-- br -->In RapidBATCH 5, it is only recommended to use GOSUB...RESUME-constructions within dialog programming; For other purposes, the possibility of the procedural programming should be used by defining own procedures and functions that can be called.
rb5ref_en_1_proc_endproc.html§PROC...RET...ENDPROC§PROC procedure-name[: list-of-parameters]<br><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;{block of code}<br><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[RET]<br><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;{block of code}<br><!-- br -->ENDPROC§Defines and implements a user-defined procedure.<br><!-- br --><br><!-- br --><!-- br -->Procedures are implemented to merge a set of RapidBATCH script code, performing a certain operation, together to one new, single instruction that can be called like any other RapidBATCH instruction everywhere in the script. A procedure must be created under an arbitrary name (over that the procedure is called and identified) and can optionally receive a certain number of parameters from the position it is called from. These parameters are defined as a list of variables, which are locally declared and receive the values assigned as parameters. By using the pointer-functionality, it is also possible to assign pointers pointing to arrays and variables to the procedure, so the procedure is able to store data to the pointer or access array elements over it.<br><!-- br --><br><!-- br -->Using the RET-instruction, the procedure can be dropped out before the procedure's end is reached and the script-execution is continued behind its last call. Whereas the use of RET in functions, it does not expect any parameters if it is used within a procedure.<br><!-- br --><br><!-- br -->A procedure is able to call other user-defined procedures and functions or even itself recoursively. Function-/Procedure-declarations in procedures are not allowed.§<font color="#808080">rem implementation of the procedure "calculate" with two parameters</font><br /><!-- br --><b>proc</b> calculate: <font color="#000080">[a]</font>, <font color="#000080">[b]</font><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem local declaration of [text]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>dec</b> <font color="#000080">[text]</font><br /><!-- br --><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[text]</font> # <font color="#000080">[a]</font> # <font color="#0000ff">' + '</font> # <font color="#000080">[b]</font> # <font color="#0000ff">' = '</font> # (<font color="#000080">[a]</font> + <font color="#000080">[b]</font>) # <font color="#000080">[new_line]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[text]</font> # <font color="#000080">[a]</font> # <font color="#0000ff">' - '</font> # <font color="#000080">[b]</font> # <font color="#0000ff">' = '</font> # (<font color="#000080">[a]</font> - <font color="#000080">[b]</font>) # <font color="#000080">[new_line]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[text]</font> # <font color="#000080">[a]</font> # <font color="#0000ff">' * '</font> # <font color="#000080">[b]</font> # <font color="#0000ff">' = '</font> # (<font color="#000080">[a]</font> * <font color="#000080">[b]</font>) # <font color="#000080">[new_line]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[text]</font> # <font color="#000080">[a]</font> # <font color="#0000ff">' / '</font> # <font color="#000080">[b]</font> # <font color="#0000ff">' = '</font> # (<font color="#000080">[a]</font> / <font color="#000080">[b]</font>) # <font color="#000080">[new_line]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[text]</font> # <font color="#000080">[a]</font> # <font color="#0000ff">' ~ '</font> # <font color="#000080">[b]</font> # <font color="#0000ff">' = '</font> # (<font color="#000080">[a]</font> ~ <font color="#000080">[b]</font>)<br /><!-- br --><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem display the results</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#000080">[text]</font><br /><!-- br --><b>endproc</b><br /><!-- br --><br /><!-- br --><font color="#808080">rem calling the procedure "calculate"</font><br /><!-- br -->calculate <font color="#0000ff">'10'</font>, <font color="#0000ff">'5'</font><br /><!-- br --><br /><!-- br -->inputbox <font color="#000080">[value1]</font> = <font color="#0000ff">'Value 1'</font>, <font color="#0000ff">'Please enter a value:'</font>, <font color="#0000ff">''</font><br /><!-- br -->inputbox <font color="#000080">[value2]</font> = <font color="#0000ff">'Value 1'</font>, <font color="#0000ff">'Please enter a value:'</font>, <font color="#0000ff">''</font><br /><!-- br --><b>if</b> <font color="#000080">[value1]</font> ! <font color="#0000ff">''</font> & <font color="#000080">[value2]</font> ! <font color="#0000ff">''</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;calculate <font color="#000080">[value1]</font>, <font color="#000080">[value2]</font><br /><!-- br --><b>endif</b><br /><!-- br --><br /><!-- br --><font color="#808080">rem implementation of the procedure "output_array" using a pointer</font><br /><!-- br --><b>proc</b> output_array: <font color="#000080">[*array]</font><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem local variables</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>dec</b> <font color="#000080">[i]</font>,<font color="#000080">[text]</font><br /><!-- br --><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem return if the array has no entries</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[array:'0']</font> = <font color="#0000ff">'0'</font> <b>ret</b><br /><!-- br --><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem build output string</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> = <font color="#0000ff">'0'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>repeat</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> + <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[text]</font> # <font color="#0000ff">'Index '</font> # <font color="#000080">[i]</font> # <font color="#0000ff">' contains "'</font> # <font color="#000080">[array[i]]</font> # <font color="#0000ff">'"'</font> # <font color="#000080">[new_line]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>until</b> <font color="#000080">[i]</font> = <font color="#000080">[array'0']</font><br /><!-- br --><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem output the list of entries</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#000080">[text]</font><br /><!-- br --><b>endproc</b><br /><!-- br --><br /><!-- br --><font color="#000080">[dolphins:'1']</font> = <font color="#0000ff">'Orcinus Orca'</font><br /><!-- br --><font color="#000080">[dolphins:'2']</font> = <font color="#0000ff">'Delphinus Delphis'</font><br /><!-- br --><font color="#000080">[dolphins:'3']</font> = <font color="#0000ff">'Pseudorca crassidens'</font><br /><!-- br --><font color="#000080">[dolphins:'4']</font> = <font color="#0000ff">'Tursiops Truncatus'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem calling the procedure "output_array"</font><br /><!-- br -->output_array <font color="#000080">[dolphins]</font>§To implement user-defined functions, use the statements FUNC and ENDFUNC.<br><!-- br --><br><!-- br -->A set of procedures and functions can be collected and explicitly saved into a library-script file, that is included to scripts using these functions over the INCLUDE-instruction. A procedure can not be called before its definition.<br><!-- br -->Calling RET is only allowed in procedures and functions.<!-- br --><br><br><!-- br --><!-- br -->When declaring local variables in procedures, it is recommended to call the DEC-instruction explicitly before their first use, to avoid problems with global variables that are defined under the same name.
rb5ref_en_1_func_endfunc.html§FUNC...RET...ENDFUNC§FUNC function-name [:list-of-parameters]<br><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;{block of code}<br><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[RET [return-value] ]<br><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;{block of code}<br><!-- br -->ENDFUNC§Defines and implements a user-defined function.<br><!-- br --><br><!-- br --><!-- br -->Functions are implemented to merge a set of RapidBATCH script code, performing a certain operation, together to one new, single function that can be called like any other RapidBATCH function everywhere within the script. A function must be created under an arbitrary name (over that the function is called and identified) and can optionally receive a certain number of parameters from the position it is called from. These parameters are defined as a list of variables, which are locally declared and receive the values assigned as parameters. By using the pointer-functionality, it is also possible to assign pointers pointing to arrays and variables to the function, so the function is able to store data to the pointer or access array elements over it.<br><!-- br --><br><!-- br -->Using the RET-instruction, the function returns a value to the result variable that is specified at the function call. If no value is specified, RET automatically returns an empty-string. RET is also optional in functions, but MUST be used to finally return a value.<br><!-- br --><br><!-- br -->A function is able to call other, user-defined procedures and functions or even itself recoursively. Implementing other functions or procedures within a function is not allowed.§<font color="#808080">rem implementation of the function "square"</font><br /><!-- br --><b>func</b> square: <font color="#000080">[value]</font><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem directly return the result</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>ret</b> <font color="#000080">[value]</font> * <font color="#000080">[value]</font><br /><!-- br --><b>endfunc</b><br /><!-- br --><br /><!-- br --><font color="#808080">rem calling the function "square"</font><br /><!-- br -->square <font color="#000080">[result]</font> = <font color="#0000ff">'9'</font><br /><!-- br -->echo <font color="#0000ff">'The result is: '</font> # <font color="#000080">[result]</font><br /><!-- br --><br /><!-- br -->inputbox <font color="#000080">[square]</font> = <font color="#0000ff">'Value to square'</font>, <font color="#0000ff">'Please enter a value you want to square:'</font>, <font color="#0000ff">'5'</font><br /><!-- br -->square <font color="#000080">[result]</font> = <font color="#000080">[square]</font><br /><!-- br -->echo <font color="#0000ff">'The result is: '</font> # <font color="#000080">[result]</font><br /><!-- br --><br /><!-- br --><br /><!-- br --><font color="#808080">rem implementation of the recoursive calling function "fac"</font><br /><!-- br --><b>func</b> fac: <font color="#000080">[x]</font><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem local variable</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>dec</b> <font color="#000080">[result]</font><br /><!-- br --><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[x]</font> = <font color="#0000ff">'0'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[result]</font> = <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>else</b><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rem calling "fac" itself</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fac <font color="#000080">[result]</font> = <font color="#000080">[x]</font> - <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[result]</font> * <font color="#000080">[x]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>endif</b><br /><!-- br --><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem returning the content of [result]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>ret</b> <font color="#000080">[result]</font><br /><!-- br --><b>endfunc</b><br /><!-- br --><br /><!-- br --><font color="#808080">rem first call of "fac", starting the recoursion</font><br /><!-- br -->fac <font color="#000080">[factoral]</font> = <font color="#0000ff">'4'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem show the result</font><br /><!-- br -->echo <font color="#0000ff">'The factoral of 4 is '</font> # <font color="#000080">[factoral]</font><!-- br -->§To implement user-defined procedures, use the statements PROC and ENDPROC.<br><br><!-- br --><!-- br -->A set of procedures and functions can be collected and explicitly saved into a library-script file, that is included to scripts importing these procedures and functions over the INCLUDE-instruction. A function can not be called before its definition.<br><!-- br -->Calling RET is only allowed in procedures and functions.<br><!-- br --><br><!-- br --><!-- br -->When declaring local variables in functions, it is recommended to call the DEC-instruction explicitly before their first use, to avoid problems with global variables that are defined under the same name.
rb5ref_en_1_halt.html§HALT§HALT§Terminates the script execution immediatelly and frees all memory resources.§<!-- CODE BEGIN -->chdir <font color="#0000ff">'C:\Test'</font><br><!-- br --><b>if</b> <font color="#000080">[errorcode]</font> = <font color="#0000ff">'-1'</font><br><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'C:\Test does not exist!'</font><br><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem terminate the script</font><br><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>halt</b><br><!-- br --><b>endif</b><br><!-- br --><!-- CODE END -->§none
rb5ref_en_1_wait.html§WAIT§WAIT milliseconds§Suspends the script execution for the given time of milliseconds until it continues.<br><!-- br -->One second is 1000 milliseconds.§<!-- CODE BEGIN -->shell <font color="#0000ff">'calc.exe'</font>, <font color="#0000ff">'show'</font><br><!-- br --><font color="#808080">rem wait for two seconds...</font><br><!-- br -->wait <font color="#0000ff">'2000'</font><br><!-- br -->echo <font color="#0000ff">'You can calculate now ;)...'</font><br><!-- br --><b>end</b><br><!-- br --><!-- CODE END -->§none
rb5ref_en_1_rem.html§REM§REM comment§REM marks a comment-line in the code that is used to comment a scripts. REM does not take any action, it only advises the compiler/interpreter to ignore the current line.§<!-- CODE BEGIN --><font color="#808080">rem displaying the text "Hello World"</font><br><!-- br -->echo <font color="#0000ff">'Hello World'</font><br><!-- br --><b>end</b><br><!-- br --><!-- CODE END -->§none
rb5ref_en_1_include.html§INCLUDE, INCLUDE_ONCE§INCLUDE include-file<br /><!-- br -->INCLUDE_ONCE include-file§INCLUDE allows the import of an other, external RapidBATCH script file into the current script. The included file is virtually inserted and executed completely at the position where INCLUDE is called. Variables that are declared in the imported file are also declared in the main script and functions/procedures are imported and can be called.<br><br><!-- br --><!-- br -->The purpose of this concept is the separation of huger projects into different, smaller script files, which is more easier to maintain. Also, INCLUDE allows to import sets of functions and procedures as libraries, so that a library is once written and its functions and procedures can be used in the whole script after their include.<br><br><!-- br --><!-- br -->The INCLUDE_ONCE-statement has the same purpose as INCLUDE, but it runs the code to be imported only when it is called the first time. If INCLUDE_ONCE is executed a second time with the same file, it is ignored.§<!-- CODE BEGIN --><font color="#808080">rem include the array.rb library</font><br><!-- br --><font color="#008000">include 'array.rb'</font><br><!-- br --><br><!-- br --><font color="#808080">rem fill test array</font><br><!-- br --><font color="#000080">[test:'1']</font> = <font color="#0000ff">'Hello World'</font><br><!-- br --><font color="#000080">[test:'2']</font> = <font color="#0000ff">'Test 25'</font><br><!-- br --><font color="#000080">[test:'3']</font> = <font color="#0000ff">'Next generation'</font><br><!-- br --><br><!-- br --><font color="#808080">rem calling the imported procedure "viewarray"</font><br><!-- br -->viewarray <font color="#000080">[test]</font><!-- br --><!-- CODE END -->§It is not possible to include a variable file name, the file name MUST be static. When a script using INCLUDE or INCLUDE_ONCE is compiled, the whole code of the imported script will also be compiled into the target executable file.
