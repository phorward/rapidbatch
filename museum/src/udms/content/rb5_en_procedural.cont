template.html§0TITLE§1CONTENT
rb5_en_procedural_1.html§Procedures and Functions§One of the most effective features that comes with RapidBATCH's new version 5.0 is the introduction of user-defineable procedures and functions, a feature, that is very essencial for writing structured programs.<!-- br --><br><br><!-- br -->Procedures are making it possible to break larger computing tasks into much smaller ones, and allow the script-programmer the creation of re-useable program routines that are defined once and can be used then wherever they are needed.<!-- br --><br><!-- br -->Procedures are once defined within a script, then they can be used like any of the existing build-in instructions and functions RapidBATCH provides. Because of that it is suggestive to define all wanted procedures and functions at the beginning of each RapidBATCH-script. Are the same procedures used in different scripts, it is recommended to define them into a library that is imported to all scripts expecting them, using the INCLUDE-instruction.<!-- br --><!-- br --><br><!-- br --><br><!-- br --><!-- br -->A simple procedure (without return value) is prefaced using the PROC-statement. Behind this statement, the name of the new procedure is specified. This name may not contain any blanks or special characters, but can be any desired name, except RapidBATCH build-in statements or function names. Behind this name, an optional parameter variable list can be defined, seperated by a colon (:) that is set directly behind the procedure name. Each parameter variable is seperated again by a comma, as it is known from the DEC-statement. If no parameter variable is specified, the procedure is parameterless. In this case, the colon behind the procedure name is not required.<br><!-- br -->The next line behind the PROC-statement does already belong to the new procedure. This is the code that will be executed when the procedure is called. To close the procedure's code, the ENDPROC-statement is used. ENDPROC closes the procedure, and ordinary script-code or the next procedure/function-definition can follow.<!-- br --><br><!-- br --><br><!-- br --><!-- br -->A simple example for implementing a procedure is the following script. It defines the parameter-less procedure &quot;test&quot;, that simply outputs a messagebox. After its implementation, it is called.<br><br><!-- br --><!-- br -->[code]<font color="#808080">rem demo script using a procedure</font><br /><!-- br --><b>proc</b> test<br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'This is the procedure TEST!'</font><br /><!-- br --><b>endproc</b><br /><!-- br --><br /><!-- br -->echo <font color="#0000ff">'In front of the procedure call...'</font><br /><!-- br -->test<br /><!-- br -->echo <font color="#0000ff">'...behind the procedure call'</font><br /><!-- br -->echo <font color="#0000ff">'And again...'</font><br /><!-- br -->test<br /><!-- br --><b>end</b>[/code]<!-- br --><!-- br --><!-- br -->When a procedure using parameter variables should be defined, these parameters must be specified behind the PROC statement, as already mentioned above. All variables specified there are only declared at the procedure call, and will be removed from the memory when the procedure returns. This method is called &quot;local variable declaration&quot;, because these variables (and also all new variables declared within the procedure) are only existing at the time the procedure is executed. The difference between these &quot;local&quot; and the so called &quot;global&quot; variables we indirectly already learned to know will be discussed later in a more detailed way.<!-- br --><br><br><!-- br --><!-- br -->A simple example for a procedure using parameters is the following script. It defines the procedure &quot;sum&quot; to sum up two values that are specified as parameters. The result of this addition will be displayed in a messagebox.<!-- br --><br><br><!-- br --><!-- br -->[code]<font color="#808080">rem demo script using a procedure with parameters</font><br /><!-- br --><b>proc</b> sum: <font color="#000080">[value1]</font>, <font color="#000080">[value2]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>dec</b> <font color="#000080">[result]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[result]</font> = <font color="#000080">[value1]</font> + <font color="#000080">[value2]</font><br /><!-- br --><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'The sum of '</font> # <font color="#000080">[value1]</font> # <font color="#0000ff">' and '</font> # <font color="#000080">[value2]</font> # <font color="#0000ff">' is '</font> # <font color="#000080">[result]</font><br /><!-- br --><b>endproc</b><br /><!-- br --><br /><!-- br --><font color="#808080">rem calling sum with constant parameter values</font><br /><!-- br -->sum <font color="#0000ff">'7'</font>, <font color="#0000ff">'13'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem calling sum with variable parameter values</font><br /><!-- br -->inputbox <font color="#000080">[a]</font> = <font color="#0000ff">'Value A:'</font>, <font color="#0000ff">'Please enter a number:'</font>, <font color="#0000ff">''</font><br /><!-- br --><b>if</b> <font color="#000080">[a]</font> = <font color="#0000ff">''</font> <b>halt</b><br /><!-- br -->inputbox <font color="#000080">[b]</font> = <font color="#0000ff">'Value B:'</font>, <font color="#0000ff">'Please enter a number:'</font>, <font color="#0000ff">''</font><br /><!-- br --><b>if</b> <font color="#000080">[b]</font> = <font color="#0000ff">''</font> <b>halt</b><br /><!-- br --><br /><!-- br -->sum <font color="#000080">[a]</font>, <font color="#000080">[b]</font><br /><!-- br --><b>end</b>[/code]<!-- br --><!-- br --><br><br><!-- br --><!-- br -->Now we're also able to define the above procedure as a function, that returns the sum of the two specified values to a return variable. Defining functions is not harder that defining procedures - it is nearly the same proceeding, but with the use of other statements. Equivalently to PROC and ENDPROC, a function is defined using the statements FUNC and ENDFUNC. All code between FUNC and ENDFUNC belongs to the new function. Whereas procedures, functions use one more statement that is used to return a value to the result variable that is specified at the function's call: The RET-statement. RET can also be used in procedures, but here without a parameter variable, to return to the calling point before the ENDPROC is finally reached. That means the procedure can be stopped and returned earlier, e.g. when an error occured or something succeeded, and the procedure did its job.<br><!-- br -->If RET is used in functions, it expects a value as parameter that is returned to the result variable. This value can be optional; If it is not specified, the result variable automatically gets and empty string.<!-- br --><!-- br --><br><!-- br -->The following script implements and uses the function &quot;sum&quot; that returns the sum of the two, as parameters specified values.<br><!-- br --><br><!-- br --><!-- br -->[code]<font color="#808080">rem demo script using a function</font><br /><!-- br --><b>func</b> sum: <font color="#000080">[value1]</font>, <font color="#000080">[value2]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>dec</b> <font color="#000080">[result]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[result]</font> = <font color="#000080">[value1]</font> + <font color="#000080">[value2]</font><br /><!-- br --><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>ret</b> <font color="#000080">[result]</font><br /><!-- br --><b>endfunc</b><br /><!-- br --><br /><!-- br --><font color="#808080">rem calling sum using constant parameter values</font><br /><!-- br -->sum <font color="#000080">[sum]</font> = <font color="#0000ff">'7'</font>, <font color="#0000ff">'13'</font><br /><!-- br -->echo <font color="#0000ff">'The sum is: '</font> # <font color="#000080">[sum]</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem calling sum using variable parameter values</font><br /><!-- br -->inputbox <font color="#000080">[a]</font> = <font color="#0000ff">'Value A:'</font>, <font color="#0000ff">'Please enter a number:'</font>, <font color="#0000ff">''</font><br /><!-- br --><b>if</b> <font color="#000080">[a]</font> = <font color="#0000ff">''</font> <b>halt</b><br /><!-- br -->inputbox <font color="#000080">[b]</font> = <font color="#0000ff">'Value B:'</font>, <font color="#0000ff">'Please enter a number:'</font>, <font color="#0000ff">''</font><br /><!-- br --><b>if</b> <font color="#000080">[b]</font> = <font color="#0000ff">''</font> <b>halt</b><br /><!-- br --><br /><!-- br -->sum <font color="#000080">[sum]</font> = <font color="#000080">[a]</font>, <font color="#000080">[b]</font><br /><!-- br -->echo <font color="#0000ff">'The sum is: '</font> # <font color="#000080">[erg]</font><br /><!-- br --><b>end</b>[/code]<!-- br --><br><!-- br --><!-- br -->I know that experienced programmers will smirk, because normally such a simple addition is done like this:<!-- br --><br><!-- br --><br><!-- br -->[code]echo <font color="#0000ff">'The sum is: '</font> # <font color="#0000ff">'32'</font> + <font color="#0000ff">'5'</font><br /><!-- br --><b>end</b>[/code]<!-- br --><br><!-- br --><!-- br -->But I thought this was a nice and understandable example for writing a user-defined function in RapidBATCH.<!-- br --><br><!-- br --><br><!-- br --><!-- br -->Let's move back to one important thing that I wanted to discuss before we continue with recoursive procedure calls and variable-pointers: The difference between the local and global variables! In RapidBATCH, every variable that is declared outside a procedure or function is automatically a global variable. All procedures can read and write data from and into globally declared variables, that means, if we e.g. declare a variable [test] and then call a procedure, [test] can also be accessed from this procedure. In case of locally declared variables, this is not possible. If we declare a variable [test] in a procedure, [test] can only be used from statements and functions that belong to this procedure. Also if another procedure is called from this procedure, [test] can not be accessed.<br><!-- br -->Sometimes, this major difference between the variable types is slightly difficultly to understand, but if this possibility would not given, the possibility of writing structured programs using procedure wouldn't be possible, especially when we program recoursive procedure calls as described in the next chapter.<br><br><!-- br --><!-- br -->To be sure you're accessing a real local variable within your procedure it is recommended to declare each variable that you use in your procedure or function (except parameter variables) manually using the DEC-statement. When you have a global variable [i], and you want to use [i] as a local variable, you can declare and overwrite the global [i] variable with a local [i] variable, by using DEC.<br><!-- br --><br><!-- br -->The following example demonstrates the problem and it's solution:<!-- br --><br><!-- br --><br><!-- br -->[code]<font color="#000080">[i]</font> = <font color="#0000ff">'10'</font><br /><!-- br --><br /><!-- br --><b>proc</b> test<br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> = <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'i is here '</font> # <font color="#000080">[i]</font><br /><!-- br --><b>endproc</b><br /><!-- br --><br /><!-- br -->echo <font color="#0000ff">'i is here '</font> # <font color="#000080">[i]</font><br /><!-- br -->test<br /><!-- br -->echo <font color="#0000ff">'i is here '</font> # <font color="#000080">[i]</font><br /><!-- br --><b>end</b>[/code]<!-- br --><br><!-- br --><!-- br -->What happens is quite simple: We want to use [i] in the procedure &quot;test&quot; locally, so we just assign a value to [i] in hope that it will be re-declared. But this is wrong! [i] was already declared globally, before the procedure call was done! So what we have to do, is just re-declaring [i] as a local variable again:<!-- br --><br><!-- br --><br><!-- br -->[code]<font color="#000080">[i]</font> = <font color="#0000ff">'10'</font><br /><!-- br --><br /><!-- br --><b>proc</b> test<br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>dec</b> <font color="#000080">[i]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> = <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'i is here '</font> # <font color="#000080">[i]</font><br /><!-- br --><b>endproc</b><br /><!-- br --><br /><!-- br -->echo <font color="#0000ff">'i is here '</font> # <font color="#000080">[i]</font><br /><!-- br -->test<br /><!-- br -->echo <font color="#0000ff">'i is here '</font> # <font color="#000080">[i]</font><br /><!-- br --><b>end</b>[/code]<!-- br --><br><!-- br --><!-- br -->In this case, the locally declared variable [i] is removed from the memory again, and it's &quot;global brother&quot;, the globally declared variable [i], will stay in memory until the script finally ends, and can be accessed again behin the procedure call.<!-- br --><br><!-- br --><br><!-- br --><!-- br -->Maybe you have some problems on understanding the sense of local and global varibales, but I ensure that you will understand it after you wrote some scripts using procedures and handling with these types of variables.<!-- br --><br><!-- br --><br><!-- br --><!-- br -->So let's move to the next chapters that show how procedural programming in RapidBATCH really can be exhausted!
rb5_en_procedural_2.html§Recousive programming§When a procedure or function calls itself within its code, it performs a recoursive procedure call. Also the opposite call of two procedures is called a &quot;recoursion&quot;. When programming such structures, it is a must that a breaking condition is given, else the procedure calls itself (theoretically) again in a never-ending loop. The possibility of the recoursive programming provides a smart way of solving nested operations in a professional and quickly realized manner.<!-- br --><br><!-- br --><br><!-- br --><!-- br -->As simple example of a recoursive executed program is the calculation of the factorial. For the calculation of the factoral, the following mathematical definition is given:<br><!-- br --><!-- br --><ul/><!-- br -->	<li/>The factoral of the value zero is 1.</li/><!-- br -->         <li/>The factoral of an integer number, that is greater than 0 is the product of the number of the factoral of the next lower integer number.</li/><!-- br --></ul/><!-- br --><!-- br --><br><!-- br --><!-- br -->So let's write a script that calculates the factoral recoursively:<br><!-- br --><br><!-- br --><!-- br -->[code]<font color="#808080">rem function "fac" to calculate the factoral</font><br /><!-- br --><b>func</b> fac: <font color="#000080">[x]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>dec</b> <font color="#000080">[result]</font><br /><!-- br --><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[x]</font> = <font color="#0000ff">'0'</font><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rem this is the exit condition, no more</font><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rem recoursive call follows!</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[result]</font> = <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>else</b><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rem recoursive call of the function "fac"</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fac <font color="#000080">[result]</font> = <font color="#000080">[x]</font> - <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[result]</font> * <font color="#000080">[x]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>endif</b><br /><!-- br --><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>ret</b> <font color="#000080">[result]</font><br /><!-- br --><b>endfunc</b><br /><!-- br --><br /><!-- br --><font color="#808080">rem first call of "fac", starting the recoursion</font><br /><!-- br -->fac <font color="#000080">[factoral]</font> = <font color="#0000ff">'4'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem show the result</font><br /><!-- br -->echo <font color="#0000ff">'The factoral of 4 is '</font> # <font color="#000080">[factoral]</font><br /><!-- br --><b>end</b><!-- br -->[/code]<!-- br --><!-- br --><!-- br --><br><!-- br -->That's already all! As you surely recognized, the function FAC calls itself again from its own body code, but with a to 1 decreased value of [x]. The exit condition is the case if the parameter [x] contains the value 0. If this happens, no more recoursions will follow, and the recoursion of the function is closed. A procedure or function can call itself more hundred - or even more thousand - of times again. All these calls are stored into an internal procedure call stack. By giving the breaking instruction, this stack will be closed call by call until the script can continue its execution behind the first, beginning call, of the recoursively called procedure. If no exit condition is given, the script (or even the entire operating system) will hang up caused by a memory overflow.<!-- br --><br><br><!-- br --><!-- br -->To make the process of the recousion in our factorial-script more easier to undertand, let's insert some tracing messageboxes:<!-- br --><br><!-- br --><br><!-- br -->[code]<font color="#000080">[rlevel]</font> = <font color="#0000ff">'0'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem function "fac" to calculate the factoral</font><br /><!-- br --><b>func</b> fac: <font color="#000080">[x]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>dec</b> <font color="#000080">[result]</font><br /><!-- br --><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Calling fac in recoursion level '</font> # <font color="#000080">[rlevel]</font> # <font color="#0000ff">' with [x] = '</font> # <font color="#000080">[x]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[rlevel]</font> + <font color="#0000ff">'1'</font><br /><!-- br --><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[x]</font> = <font color="#0000ff">'0'</font><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rem this is the breaking condition, no more</font><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rem recoursive call follows!</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[result]</font> = <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>else</b><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rem recoursive call of the function "fac"</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fac <font color="#000080">[result]</font> = <font color="#000080">[x]</font> - <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[result]</font> * <font color="#000080">[x]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>endif</b><br /><!-- br --><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[rlevel]</font> - <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Leaving fac in recoursion level '</font> # <font color="#000080">[rlevel]</font> # <font color="#0000ff">' with [result] = '</font> # <font color="#000080">[result]</font><br /><!-- br --><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>ret</b> <font color="#000080">[result]</font><br /><!-- br --><b>endfunc</b><br /><!-- br --><br /><!-- br --><br /><!-- br -->echo <font color="#0000ff">'Script start...'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem first call of "fac", starting the recoursion</font><br /><!-- br -->fac <font color="#000080">[factoral]</font> = <font color="#0000ff">'4'</font><br /><!-- br --><br /><!-- br -->echo <font color="#0000ff">'Here, the script already closed the recoursion!'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem show the result</font><br /><!-- br -->echo <font color="#0000ff">'The factoral of 4 is '</font> # <font color="#000080">[factoral]</font><br /><!-- br --><b>end</b><!-- br -->[/code]<!-- br --><br><!-- br --><!-- br -->This example also demonstrates the usage of local and global variables again: In every recoursive function call, all local variables of the function are re-declared and can be used with different values. As example, some thousand instances of the variable [x] can exist in the memory, but only the one in the current call of the function is the only valid one in the calling stack. Therefore, the values of the [x] instances below the current one can not be changed. If this would be possible, the recousive programming possibiliy - and also the whole model of structured programming - would be completely senseless.<br><!-- br -->In the opposite, we also use a global variable here, the variable [rlevel], showing us the recoursion level of the current call. This variable is global, and we increment (increase by one) it at the beginning of the function and decrement (decrease by one) it when the function call ends. When the script is executed, it can be recognized that the function calls itself for at least 5 times.<!-- br --><br><!-- br --><br><!-- br --><!-- br -->The possibility of recoursive programming is very versatile and can also be very effective.<br><!-- br -->For example, to copy a complete directory, the procedure &quot;copydir&quot; was implemented into the RapidBATCH extending system functions library, SYSTEM.RB, and calls itself recoursively for each sub-directory.<!-- br --><!-- br --><br><br><!-- br -->[code]<b>proc</b> copyDir: <font color="#000080">[source]</font>, <font color="#000080">[target]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>dec</b> <font color="#000080">[tok]</font>, <font color="#000080">[i]</font>, <font color="#000080">[files]</font><br /><!-- br --><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;findfiles <font color="#000080">[files]</font> = <font color="#000080">[source]</font> # <font color="#0000ff">'\*'</font>, <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[files]</font> = <font color="#0000ff">''</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[errorcode]</font> = <font color="#0000ff">'-1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>ret</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>endif</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;mkdir <font color="#000080">[target]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>repeat</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;calcvar <font color="#000080">[i]</font> = <font color="#000080">[i]</font> + <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gettok <font color="#000080">[tok]</font> = <font color="#000080">[files]</font>, <font color="#0000ff">'|'</font>, <font color="#000080">[i]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[tok]</font> ! <font color="#0000ff">''</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getfileatt <font color="#000080">[isDir]</font> = <font color="#000080">[source]</font> # <font color="#0000ff">'\'</font> # <font color="#000080">[tok]</font>, <font color="#0000ff">'DIRECTORY'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[isDir]</font> = <font color="#0000ff">'0'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;copyDir <font color="#000080">[source]</font> # <font color="#0000ff">'\'</font> # <font color="#000080">[tok]</font>, <font color="#000080">[target]</font> # <font color="#0000ff">'\'</font> # <font color="#000080">[tok]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>else</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;copyfile <font color="#000080">[source]</font> # <font color="#0000ff">'\'</font> # <font color="#000080">[tok]</font>, <font color="#000080">[target]</font> # <font color="#0000ff">'\'</font> # <font color="#000080">[tok]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>endif</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>endif</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>until</b> <font color="#000080">[tok]</font> = <font color="#0000ff">''</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[errorcode]</font> = <font color="#0000ff">'0'</font><br /><!-- br --><b>endproc</b>[/code]
rb5_en_procedural_3.html§Pointers§In all of previous examples using procedures, we had already worked with parameters. Thereby, we applied the &quot;call-by-value&quot;-method, that means that the value that is specified at the procedure call is copied into the locally declared parameter variable of the procedure. But RapidBATCH also supports another method, the &quot;call-by-reference&quot;-method. This method does not copy a variable, but it creates a so called pointer to a variable specified at the procedure call. This locally declared &quot;pseudo-variable&quot; points to the target variable which can be a global variable or a local variable of a previously called procedure. The advantage of this method is, that it is also possible to pass arrays to procedures, so that these procedures can handle with the whole array. The call-by-reference method is also the only possibility to access variables beyond the current procedure call, for example, as already mentioned, you can pass the pointer of an already locally declared variable of a procedure to another procedure, that can access this variable.<!-- br --><!-- br --><!-- br --><br><!-- br --><br><!-- br -->A parameter is marked as a pointer by specifying a leading asterisk (*) character at the beginning of the parameter's variable name. This asterisk does not belong the the name of the variable, it is just an identifying character telling RapidBATCH that you want to get a pointer as this parameter.<!-- br -->The following script shows how pointers are declared, specified and used in a simple procedure:<!-- br --><br><!-- br --><br><!-- br -->[code]<font color="#808080">rem procedure for writing a string over a pointer to a variable</font><br /><!-- br --><b>proc</b> get_new_value: <font color="#000080">[*a]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'The value of [a] is currently: '</font> # <font color="#000080">[a]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[a]</font> = <font color="#0000ff">'This is a new value written over the pointer.'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'The value of [a] is now: '</font> # <font color="#000080">[a]</font><br /><!-- br --><b>endproc</b><br /><!-- br --><br /><!-- br --><font color="#808080">rem main script part</font><br /><!-- br --><font color="#000080">[test]</font> = <font color="#0000ff">'Hello World'</font><br /><!-- br -->echo <font color="#0000ff">'The value of [test] is currently: '</font> # <font color="#000080">[test]</font><br /><!-- br -->get_new_value <font color="#000080">[test]</font><br /><!-- br -->echo <font color="#0000ff">'The value of [test] is now: '</font> # <font color="#000080">[test]</font><br /><!-- br --><b>end</b>[/code]<!-- br --><br><!-- br --><!-- br -->As already mentioned above, pointers are also the only way to process on external arrays within procedures. The best example is the procedure &quot;viewArray&quot; defined in the RapidBATCH array help function library, ARRAY.RB.<br><!-- br --><br><!-- br -->[code]<font color="#808080">rem viewArray :: displays all elements of an array on the screen</font><br /><!-- br --><b>proc</b> viewArray: <font color="#000080">[*array]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>dec</b> <font color="#000080">[i]</font>,<font color="#000080">[text]</font><br /><!-- br --><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem on error, exit procedure!</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[array:'0']</font> = <font color="#0000ff">'0'</font> <b>ret</b><br /><!-- br --><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem build the string that will be displayed</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>repeat</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> = <font color="#000080">[i]</font> + <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[text]</font> # <font color="#0000ff">'Index '</font> # <font color="#000080">[i]</font> # <font color="#0000ff">': '</font> # <font color="#000080">[array[i]]</font> # <font color="#000080">[new_line]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>until</b> <font color="#000080">[i]</font> = <font color="#000080">[array'0']</font><br /><!-- br --><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem output the string in a messagebox</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#000080">[text]</font><br /><!-- br --><b>endproc</b><br /><!-- br --><br /><!-- br --><font color="#808080">rem --- main script part</font><br /><!-- br --><font color="#808080">rem declare and fill an array of 10 elements</font><br /><!-- br --><b>dec</b> <font color="#000080">[names:'10']</font><br /><!-- br --><font color="#000080">[names:'1']</font> = <font color="#0000ff">'Neo'</font><br /><!-- br --><font color="#000080">[names:'2']</font> = <font color="#0000ff">'Trinity'</font><br /><!-- br --><font color="#000080">[names:'3']</font> = <font color="#0000ff">'Morpheus'</font><br /><!-- br --><font color="#000080">[names:'4']</font> = <font color="#0000ff">'Roy'</font><br /><!-- br --><font color="#000080">[names:'5']</font> = <font color="#0000ff">'Earl'</font><br /><!-- br --><font color="#000080">[names:'6']</font> = <font color="#0000ff">'Dagobert'</font><br /><!-- br --><font color="#000080">[names:'7']</font> = <font color="#0000ff">'Michael'</font><br /><!-- br --><font color="#000080">[names:'8']</font> = <font color="#0000ff">'Marty'</font><br /><!-- br --><font color="#000080">[names:'9']</font> = <font color="#0000ff">'Doc Brown'</font><br /><!-- br --><font color="#000080">[names:'10']</font> = <font color="#0000ff">'Einstein'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem display the array</font><br /><!-- br -->viewarray <font color="#000080">[names]</font><br /><!-- br --><b>end</b>[/code]<!-- br --><br><!-- br --><br><!-- br --><!-- br -->As a matter of course you can also change any element in any dimension using the pointer, like if you work with an ordinary array variable. The next script squares every element of the array and writes the result back to the same element.<!-- br --><!-- br --><br><!-- br --><br><!-- br --><!-- br -->[code]<font color="#808080">rem viewArray :: displays all elements of an array on the screen</font><br /><!-- br --><b>proc</b> viewArray: <font color="#000080">[*array]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>dec</b> <font color="#000080">[i]</font>,<font color="#000080">[text]</font><br /><!-- br --><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem on error, exit procedure!</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[array:'0']</font> = <font color="#0000ff">'0'</font> <b>ret</b><br /><!-- br --><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem build the string that will be displayed</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>repeat</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> = <font color="#000080">[i]</font> + <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[text]</font> # <font color="#0000ff">'Index '</font> # <font color="#000080">[i]</font> # <font color="#0000ff">': '</font> # <font color="#000080">[array[i]]</font> # <font color="#000080">[new_line]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>until</b> <font color="#000080">[i]</font> = <font color="#000080">[array'0']</font><br /><!-- br --><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem output the string in a messagebox</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#000080">[text]</font><br /><!-- br --><b>endproc</b><br /><!-- br --><br /><!-- br --><font color="#808080">rem square_array :: squares every element of an array</font><br /><!-- br --><b>proc</b> square_array: <font color="#000080">[*array]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>dec</b> <font color="#000080">[i]</font>, <font color="#000080">[text]</font><br /><!-- br --><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[array:'0']</font> = <font color="#0000ff">'0'</font> <b>ret</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>repeat</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> + <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[array:[i]]</font> * <font color="#000080">[array:[i]]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>until</b> <font color="#000080">[i]</font> = <font color="#000080">[array:'0']</font><br /><!-- br --><b>endproc</b><br /><!-- br --><br /><!-- br --><font color="#808080">rem --- main script part</font><br /><!-- br --><font color="#808080">rem create randomized values between 0 and 100</font><br /><!-- br --><font color="#000080">[i]</font> = <font color="#0000ff">'0'</font><br /><!-- br --><b>repeat</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> + <font color="#0000ff">'1'</font><br /><!-- br --><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem calling the random number generator</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;randvar <font color="#000080">[some_numbers:[i]]</font> = <font color="#0000ff">'100'</font><br /><!-- br --><b>until</b> <font color="#000080">[i]</font> = <font color="#0000ff">'5'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem display the values</font><br /><!-- br -->viewarray <font color="#000080">[some_numbers]</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem square the values</font><br /><!-- br -->square_array <font color="#000080">[some_numbers]</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem display the values again</font><br /><!-- br -->viewarray <font color="#000080">[some_numbers]</font><br /><!-- br --><b>end</b>[/code]<!-- br --><!-- br -->It is also possible to pass an already existing pointer to another procedure pointer. For example, when you call a procedure using a pointer, this procedure can call a completely other procedure by passing its pointer as a pointer-pointer to the next procedure call. These chains of pointers can be repeated (theoretically) infinitely.
