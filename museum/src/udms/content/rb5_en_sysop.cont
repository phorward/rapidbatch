template.html§0TITLE§1CONTENT
rb5_en_sysop_1.html§Running external programs§Especially when developing batch programs it is frequently necessary to call external programs, automatizing certain methods to get the desired result. For this purpose, RapidBATCH provides even four different possibilities.<!-- br --><br /><br /><!-- br --><!-- br -->First of all, there is the classic SHELL-instruction, which is used to start any program which will run parallely to the RapidBATCH script. SHELL expects as first parameter the absolute or relative path to the file that should be exectued, and as second parameter a so called show mode. This show mode defines the application window behavior at startup, but is not supported by every Windows program that can be run.<br /><!-- br --><!-- br -->Possible show-mode values are 'SHOW', 'HIDE', 'MINIMIZED' and 'MAXIMIZED'. 'SHOW' displays the application's main window in its default size, 'HIDE' does not display the window, and is only recommended to use with programs or batch-files running in the background. The modes 'MINIMIZED' and 'MAXIMIZED' are minimizing or maximazing the window of the application that is executed.<!-- br --><br><!-- br --><br><!-- br -->Take a look at the following script, running the Windows "Notepad" text editor.<!-- br --><br><br><!-- br -->[code]shell <font color="#0000ff">'notepad.exe'</font>, <font color="#0000ff">'show'</font><br /><!-- br -->echo <font color="#0000ff">'And now we run another Notepad with a maximized window!'</font><br /><!-- br -->shell <font color="#0000ff">'notepad.exe'</font>, <font color="#0000ff">'maximized'</font><br /><!-- br -->echo <font color="#0000ff">'Finished!'</font><br /><!-- br --><b>end</b>[/code]<!-- br --><br><!-- br --><!-- br -->Next to the SHELL-instruction, RapidBATCH is also providing the CALL-instruction. CALL is nearly equal to SHELL, and also expects the same parameters, but it features one important thing that SHELL is not featuring: CALL runs a program in a modal-mode; This means, that the RapidBATCH-script that executes an external program or DOS command using CALL, is halted until the called program is finished or closed by the user. <br><!-- br --><br><!-- br -->This is an example, running Notepad again via CALL.<br><!-- br --><br><!-- br -->[code]call <font color="#0000ff">'notepad.exe'</font>, <font color="#0000ff">'show'</font><br /><!-- br -->echo <font color="#0000ff">'And now, we run Notepad again using another show mode...'</font><br /><!-- br -->call <font color="#0000ff">'notepad.exe'</font>, <font color="#0000ff">'maximized'</font><br /><!-- br -->echo <font color="#0000ff">'Ende!'</font><br /><!-- br --><b>end</b>[/code]<!-- br --><br><!-- br --><!-- br -->Oftenly it is also necessary to run the good old MS-DOS commands Windows features over the DOS prompt. There is also a way to do this using SHELL or CALL by running the CMD.EXE or COMMAND.COM command interpreter, but RapidBATCH does also feature a single instruction that directly allows the execution of any DOS commands: The SYSTEM-instruction.<!-- br --><br><!-- br --><br><!-- br -->Example:<br><!-- br --><br><!-- br -->[code]<font color="#808080">rem Pinging www.jmksf.de ...</font><br /><!-- br -->system <font color="#0000ff">'ping www.jmksf.de'</font><br /><!-- br --><b>end</b>[/code]<!-- br --><br><!-- br --><!-- br -->By using CALL or SHELL, it is also possible to run DOS-commands in the background, without an upcoming DOS-box. The next example uses the READFILE-function to read out the file DIR wrote its output to. The READFILE-function will be discussed later in a more detailed way.<!-- br --><br><!-- br --><br><!-- br -->[code]<font color="#808080">rem run DIR-command and save it temporary to test.txt</font><br /><!-- br -->call <font color="#0000ff">'cmd.exe /C dir *.exe &gt;test.txt'</font>, <font color="#0000ff">'hide'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem read test.txt and display it</font><br /><!-- br -->readfile <font color="#000080">[dir_output]</font> = <font color="#0000ff">'test.txt'</font>, <font color="#0000ff">'0'</font><br /><!-- br -->echo <font color="#000080">[dir_output]</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem finally, delete test.txt again!</font><br /><!-- br -->delfile <font color="#0000ff">'test.txt'</font><br /><!-- br --><b>end</b>[/code]<!-- br --><!-- br --><div class="image"><img src="img/sysop_call_dir.gif" alt="Messagebox, displaying the output of the DIR-command, read from the file." title="Displaying system command outputs in an ECHO-dialog." /><br /><!-- br -->The script from above, displaying the content of the current directory from the DIR-command within an ECHO-messagebox.</div><!-- br --><!-- br --><div class="remark">Note: When running the above script on Windows 95, 98 or Millenium Edition, the call of CMD.EXE must be replaced with COMMAND.COM, because Win 95/98/ME are not NT-based systems (like NT, 2000, XP and 2003) so that they use COMMAND.COM instead of CMD.EXE. The result of the script run will be the same on both system families.</div><!-- br --><br><!-- br --><!-- br -->The last, but also mostly primitive method to run external programs is the OPEN-instruction. OPEN can be used very versatile, e.g. it runs programs (same as a SHELL-instruction call using the mode 'SHOW'), opens documents with the corresponding program (e.g. by specifying a .DOC-file, the file is loaded to Word or WordPad) or opens internet URLs in the system's default-browser.<!-- br --><br><!-- br --><br><!-- br -->Some examples using OPEN:<br><!-- br --><br><!-- br -->[code]open <font color="#0000ff">'calc.exe'</font><br /><!-- br -->open <font color="#0000ff">'C:\jmksf\rb5\license.txt'</font><br /><!-- br -->open <font color="#0000ff">'http://www.rapidbatch.com'</font>[/code]
rb5_en_sysop_2.html§Directory operations§To create, change or delete directories, RapidBATCH provides three instruction: MKDIR for creating a directory, CHDIR for changing the current working directory and RMDIR to delete an existing, empty directory. The instructions had been named like the homonymous DOS operating system commands.<!-- br --><br><!-- br --><br><!-- br -->The following line creates the directory &quot;whales&quot; on drive C:.<br><!-- br --><br><!-- br -->[code]mkdir <font color="#0000ff">'C:\whales'</font>[/code]<!-- br --><br><!-- br --><!-- br -->RapidBATCH is also able to create parent directories to reach a desired sub directory that should be created. The following line creates at least three new folders (&quot;C:\whales&quot;, &quot;C:\whales\toothed whales&quot; and &quot;C:\whales\thoothed whales\orcinus orca&quot;) on drive C: (if &quot;C:\whales&quot; is not already existing).<!-- br --><br><br><!-- br -->[code]mkdir <font color="#0000ff">'C:\whales\toothed whales\orcinus orca'</font>[/code]<!-- br --><!-- br --><br><!-- br -->To change the current directory to another location, use CHDIR. Changing the directory means that all relative paths (e.g. file names or program calls) the script takes are starting from this directory. By default, the working directory of every script is the directory it is saved to.<br><!-- br --><br><!-- br -->[code]chdir <font color="#0000ff">'C:\whales\toothed whales\orcinus orca'</font>[/code]<!-- br --><br><!-- br --><!-- br -->The verification if the directory change succeeded (means also to test if the folder exists) can be done using the RapidBATCH pre-declared variable [errorcode]. [errorcode] is used by several instructions and functions to give the programmer a possibility to react on system failures, enabling him to output corresponding error messages or information to the user or a log file.<!-- br --><br><!-- br -->If [errorcode] contains the value '0' when CHDIR is executed, the directory change succeeded. If it is '-1', the directory does not exist.<!-- br --><br><br><!-- br -->[code]chdir <font color="#0000ff">'C:\whales\toothed whales\orcinus orca'</font><br /><!-- br --><b>if</b> <font color="#000080">[errorcode]</font> = <font color="#0000ff">'-1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Directory change failed!'</font><br /><!-- br --><b>else</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Directory change succeeded!'</font><br /><!-- br --><b>endif</b>[/code]<!-- br --><br><!-- br --><!-- br --><div class="remark">Please note that [errorcode] is used by many instructions RapidBATCH provides. Also already mentioned instructions like SHELL, CALL or even MKDIR return a value to [errorcode]. To get detailed information on what value [errorcode] will get in which cases, look up the language reference manual.<br>Make sure that [errorcode] is verified directly behind the call of the operation you want to check for success, else the value of [errorcode] may be overwritten by another instruction.</div><!-- br --><!-- br -->To delete a directory, use the RMDIR instruction. Before running RMDIR, make sure the folder you wish to delete is empty, else RMDIR fails, returing '-1' to the [errorcode] variable.<!-- br --><br><!-- br --><br><!-- br -->[code]rmdir <font color="#0000ff">'C:\whales\toothed whales\orcinus orca'</font>[/code]<!-- br --><div class="remark">Note: To copy or move folders, use the instructions COPYDIR and MOVEDIR provided by the SYSTEM.RB extended system function library.</div>
rb5_en_sysop_3.html§Operating on the file system§To manage with files, RapidBATCH provides the instructions NEWFILE, DELFILE, COPYFILE, RENAMEFILE as well as the functions FILEEXISTS and FINDFILES.<br><!-- br --><br><!-- br --><!-- br -->NEWFILE has the only purpose to create a new, empty file in the file system, DELFILE deletes a file. The use of both instructions is equivalent.<!-- br --><br><!-- br --><br><!-- br -->[code]<font color="#808080">rem create a file</font><br /><!-- br -->newfile <font color="#0000ff">'empty.txt'</font><br /><!-- br --><b>if</b> <font color="#000080">[errorcode]</font> = <font color="#0000ff">'0'</font> echo <font color="#0000ff">'The file empty.txt has been created!'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem delete the file again</font><br /><!-- br -->delfile <font color="#0000ff">'empty.txt'</font><br /><!-- br --><b>if</b> <font color="#000080">[errorcode]</font> = <font color="#0000ff">'0'</font> echo <font color="#0000ff">'The file empty.txt has been deleted again!'</font>[/code]<!-- br --><br><!-- br --><!-- br -->Same procedure here: We're able to verify the operation success by verifying [errorcode] to the value of '0', meaning &quot;successful&quot;.<br><!-- br --><br><!-- br --><!-- br -->To copy a file, RapidBATCH provides the COPYFILE-instruction. It creates a 1:1 copy of any file. The RENAMEFILE-instruction, expecting the same parameters as COPYFILE, renames or even moves a file into another directory or drive.<br><!-- br --><br><!-- br -->An example:<br><!-- br --><br><!-- br -->[code]<font color="#808080">rem copy C:\jmksf\rb5\readme.txt to C:\test.txt...</font><br /><!-- br -->copyfile <font color="#0000ff">'C:\jmksf\rb5\readme.txt'</font>, <font color="#0000ff">'C:\test.txt'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem open C:\TEST.TXT...</font><br /><!-- br -->open <font color="#0000ff">'C:\test.txt'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem delete C:\TEST.TXT again...</font><br /><!-- br -->delfile <font color="#0000ff">'C:\test.txt'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem rename C:\jmksf\rb5\readme.txt to C:\test.txt ...</font><br /><!-- br -->renamefile <font color="#0000ff">'C:\jmksf\rb5\readme.txt'</font>, <font color="#0000ff">'C:\test.txt'</font><br /><!-- br --><font color="#808080">rem open C:\TEST.TXT again...</font><br /><!-- br -->open <font color="#0000ff">'C:\test.txt'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem rename C:\test.txt back to C:\jmksf\rb5\readme.txt again...</font><br /><!-- br -->renamefile <font color="#0000ff">'C:\test.txt'</font>, <font color="#0000ff">'C:\jmksf\rb5\readme.txt'</font>[/code]<!-- br --><br><!-- br --><!-- br --><div class="remark"><!-- br -->Please note that COPYFILE, RENAMEFILE and DELFILE do not allow wildcards to copy/move/delete a huger amount of files. To do this, use FINDFILES to build a file list and then operate on every single file within a loop. This method is discussed below.<!-- br --></div><!-- br --><!-- br -->To check if a file is already existing or not, the FILEEXISTS-function can be used. It returns the value '0' to the return variable in case if the specified file does exist, or else the value '-1'.<br><!-- br --><br><!-- br -->[code]fileexists <font color="#000080">[fx]</font> = <font color="#0000ff">'C:\AnyFile.txt'</font><br /><!-- br --><b>if</b> <font color="#000080">[fx]</font> = <font color="#0000ff">'-1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'File is not existing.'</font><br /><!-- br --><b>else</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'The file exists!'</font><br /><!-- br --><b>endif</b>[/code]<!-- br --><br><!-- br --><br><!-- br --><!-- br -->One of the most powerful and effective functions RapidBATCH provides is the FINDFILES-function. FINDFILES has the only purpose to build and return a list of files by searching a whole directory (including its sub-directories until a desired depth) by using the wildcard-characters * and ?. In the result string the function returns, each file name is seperated by the RapidBATCH default seperation character (that is globally defined in the [std_sep]-variable and by default the pipe-character, &quot;|&quot;). Such lists are already known from the RapidBATCH build-in dialogs LISTBOX and TRAYMENU, and can be processed using the GETTOK-tokenizer function.<br><!-- br --><br><!-- br --><!-- br -->The following script generates such a file list and displays the files it found in a LISTBOX-dialog, so they can be viewed.<br><!-- br --><br><!-- br -->[code]<font color="#808080">rem generate file list of the current directory, listing ALL files (wildcard * only!)</font><br /><!-- br -->findfiles <font color="#000080">[filelist]</font> = <font color="#0000ff">'*'</font>, <font color="#0000ff">'1'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem view the files in a LISTBOX-dialog</font><br /><!-- br -->listbox <font color="#000080">[file]</font> = <font color="#000080">[current]</font>, <font color="#000080">[filelist]</font><br /><!-- br --><b>if</b> <font color="#000080">[file]</font> ! <font color="#0000ff">''</font> echo <font color="#0000ff">'You selected the file: '</font> # <font color="#000080">[file]</font><br /><!-- br --><b>end</b>[/code]<!-- br --><!-- br --><div class="image"><img src="img/sysop_filelist.gif" alt="LISTBOX listing all files of the current directory." title="Displaying the list generated by FINDFILES in a LISTBOX." /><br /><!-- br -->Displaying the list of files generated by FINDFILES within the LISTBOX-dialog.</div><!-- br --><!-- br -->FINDFILES expects as the first parameter a so called path- and file-filter, that means only files that fit to this filter are appended to the returned file list. For the file filter, FINDFILES supports wildcards. Wildcards are the characters * and ?, where * represents any string of characters and ? any single character. For example, when specifying the filter '*.txt', all files with an ending '.txt' are listed. The corresponding string in front of the '.txt' can be any string, so that &quot;hello.txt&quot; is listed same as &quot;thisisanyname.txt&quot;.<br><!-- br -->The second, numerical parameter is the directory depth FINDFILES should list. You can list the files that are only in one directory by specifying the depth-value '1', all files in one directory and all its sub-directories by specifying the depth '2' or even all of a folder's sub-directories up to a maximum depth of 255 (which is nearly impossible!) by specifying the value '0'.<!-- br --><br><!-- br --><br><!-- br -->Return value of FINDFILES is, as already mentioned, a list of relative file names where each file is seperated by the separation character defined in the [std_sep]-variable. Because of that, we can directly pass this list to LISTBOX where the files are displayed without any string modification.<br><!-- br --><br><!-- br -->To demonstrate the usage of different file filters, wildcards and directory depths, take a look at the following calls of FINDFILES.<!-- br --><br><!-- br --><br><!-- br -->[code]<font color="#808080">rem list all files in the current folder, including name of sub-folders:</font><br /><!-- br -->findfiles <font color="#000080">[file_list]</font> = <font color="#0000ff">'*'</font>, <font color="#0000ff">'1'</font><br /><!-- br --><font color="#808080">rem (the "*" filter lists every file (or even sub-folder) that exists within the folder)</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem list all txt-files within the current directory and one sub-directory level:</font><br /><!-- br -->findfiles <font color="#000080">[file_list]</font> = <font color="#0000ff">'*.txt'</font>, <font color="#0000ff">'2'</font><br /><!-- br --><font color="#808080">rem (the filter "*.txt" finds all files having the .TXT extension. That means that</font><br /><!-- br --><font color="#808080">rem "hello.txt", "x.txt" as well as "txt.txt" is listed (if they would really exist!))</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem list all files beginning with "hello" and having the ".DOC"-extension:</font><br /><!-- br -->findfiles <font color="#000080">[file_list]</font> = <font color="#0000ff">'hello*.doc'</font>, <font color="#0000ff">'1'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem list all files beginning with an "h", followed by any character, and a following</font><br /><!-- br --><font color="#808080">rem "llo". Behind the "llo", any other name is allows. The files have an extension that</font><br /><!-- br --><font color="#808080">rem is seperated by a dot:</font><br /><!-- br -->findfiles <font color="#000080">[file_list]</font> = <font color="#0000ff">'h?llo*.*'</font>, <font color="#0000ff">'1'</font><br /><!-- br --><font color="#808080">rem (in this case, the files "hallo92.sav", "hello.bak", "hullokkn.exe"</font><br /><!-- br --><font color="#808080">rem and "hhlloHELLO_funnyFileName." would be listed, if they would exist!)</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem list all files having an extension in the whole directory, including all</font><br /><!-- br --><font color="#808080">rem sub-folders that exist (up to 255 sub-folder levels):</font><br /><!-- br -->findfiles <font color="#000080">[file_list]</font> = <font color="#0000ff">'*.*'</font>, <font color="#0000ff">'0'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem list all .RB-files that only have one character in their name:</font><br /><!-- br -->findfiles <font color="#000080">[file_list]</font> = <font color="#0000ff">'?.rb'</font>, <font color="#0000ff">'1'</font><br /><!-- br --><font color="#808080">rem (the filter "?.rb" lists all files that begin with one single character in the</font><br /><!-- br --><font color="#808080">rem front (the ?-wildcard means any single character), that means only files like</font><br /><!-- br --><font color="#808080">rem "a.rb", "x.rb" or "1.rb" are listed, but not "ab.rb" or something like that)</font>[/code]<!-- br --><br><!-- br -->And finally at the end of this chapter, a procedure called &quot;copyfiles&quot;, copying files from a source-directory into a target-directory. This procedure is also a demonstration how to copy (or even move) files using wildcards.<br><!-- br --><br><!-- br -->[code]<b>proc</b> copyfiles: <font color="#000080">[source]</font>, <font color="#000080">[target]</font>, <font color="#000080">[filter]</font><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem declare locale variables</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>dec</b> <font color="#000080">[i]</font>, <font color="#000080">[file]</font>, <font color="#000080">[file_list]</font><br /><!-- br --><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem reading the file list</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;findfiles <font color="#000080">[file_list]</font> = <font color="#000080">[source]</font> # <font color="#0000ff">'\'</font> # <font color="#000080">[filter]</font>, <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[file_list]</font> = <font color="#0000ff">''</font> <b>ret</b><br /><!-- br --><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem creating the target-directory for secureness</font><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem (of course it won't be overwritten if it exists!)</font><br /><!-- br --><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;mkdir <font color="#000080">[target]</font><br /><!-- br --><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem go through the file list and copy each file</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> = <font color="#0000ff">'0'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>repeat</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> + <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gettok <font color="#000080">[file]</font> = <font color="#000080">[file_list]</font>, <font color="#0000ff">'|'</font>, <font color="#000080">[i]</font><br /><!-- br --><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rem if [file] is not empty, copy it!</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[file]</font> ! <font color="#0000ff">''</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;copyfile <font color="#000080">[source]</font> # <font color="#0000ff">'\'</font> # <font color="#000080">[file]</font>, <font color="#000080">[target]</font> # <font color="#0000ff">'\'</font> # <font color="#000080">[file]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>endif</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>until</b> <font color="#000080">[file]</font> = <font color="#0000ff">''</font><br /><!-- br --><b>endproc</b><br /><!-- br --><br /><!-- br --><font color="#808080">rem An example call of the procedure, copying all files from</font><br /><!-- br --><font color="#808080">rem "C:\jmksf\rb5" into "C:\test":</font><br /><!-- br -->copyfiles <font color="#0000ff">'C:\jmksf\rb5'</font>, <font color="#0000ff">'C:\test'</font>, <font color="#0000ff">'*.*'</font><br /><!-- br --><b>end</b>[/code]
rb5_en_sysop_4.html§Writing and reading files§To read and write files, RapidBATCH provides you four versatile, easy to use instructions and functions which can be used for text- as well as binary-oriented file operations.<br><!-- br --><br><!-- br -->To write and save data to text files, RapidBATCH provides the WRITEFILE-instruction. WRITEFILE expects as parameters a filename and the value that should be written, where each operation that is done using WRITEFILE is one line in a text file.<!-- br --><br><!-- br --><br><!-- br --><!-- br -->A simple case study is the following line of code:<!-- br --><!-- br --><br><!-- br --><br><!-- br --><!-- br -->[code]writefile <font color="#0000ff">'hello.txt'</font>, <font color="#0000ff">'This is a text we write into a text file.'</font>[/code]<!-- br --><!-- br --><br><!-- br --><!-- br -->WRITEFILE appends the content of the file each time it is called automatically, that means the value that is written to the file is automatically appended to the file's end. A line break is automatically done behind the value that is written each time WRITEFILE is called. If the file WRITEFILE should write is not existing, it is automatically created, and the value will be written to the first line of the file, at the beginning.<!-- br --><br><!-- br --><br><!-- br -->When we run the following code...<br><!-- br --><br><!-- br -->[code]writefile <font color="#0000ff">'test.txt'</font>, <font color="#0000ff">'The quick brown fox'</font><br /><!-- br -->writefile <font color="#0000ff">'test.txt'</font>, <font color="#0000ff">'jumps over'</font><br /><!-- br -->writefile <font color="#0000ff">'test.txt'</font>, <font color="#0000ff">'the lazy dog.'</font>[/code]<!-- br --><br><!-- br -->...TEST.TXT will get the content:<!-- br --><br><br><!-- br --><!-- br -->[code]<b><font color="#000000"><!-- br -->The quick brown fox<br><!-- br -->jumps over<br><!-- br -->the lazy dog.<br><!-- br --></font></b>[/code]<!-- br --><!-- br --><!-- br --><br><!-- br --><br><!-- br --><!-- br -->To read out the file again, RapidBATCH is providing the function READFILE, that you surely already learned to know in the previous chapters shortly. READFILE is likewise used to read text files, because it reads a file line by line. Parameters are the filename of the file that should be opened and read, and the line-number that should be read and returned.<br><!-- br --><!-- br -->The following script tells us the first line of the evenly created file TEST.TXT.<br><!-- br --><br><!-- br -->[code]readfile <font color="#000080">[line]</font> = <font color="#0000ff">'test.txt'</font>, <font color="#0000ff">'1'</font><br /><!-- br -->echo <font color="#0000ff">'The first line of TEST.TXT is: '</font> # <font color="#000080">[line]</font>[/code]<!-- br --><br><!-- br --><!-- br -->To read the whole file now line-by-line, READFILE has to be called in a loop, where a counting variable is incremented in each loop. Here, we use the variable [i] as line counter. If a line number is specified at READFILE that does not exist, the value &quot;EOF&quot; is returned as value, meaning &quot;End Of File&quot;. Additionally, [errorcode] (that always is set to '0' if the line was read successfully) is set to '-1' if the file's end is reached.<!-- br --><br><!-- br --><br><!-- br -->[code]<font color="#000080">[i]</font> = <font color="#0000ff">'0'</font><br /><!-- br --><b>repeat</b><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem increment [i] to 1</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> + <font color="#0000ff">'1'</font><br /><!-- br --><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem read line number [i]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;readfile <font color="#000080">[line]</font> = <font color="#0000ff">'test.txt'</font>, <font color="#000080">[i]</font><br /><!-- br --><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem display the read line</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Content of line '</font> # <font color="#000080">[i]</font> # <font color="#0000ff">' is: '</font> # <font color="#000080">[line]</font><br /><!-- br --><b>until</b> <font color="#000080">[line]</font> = <font color="#0000ff">'EOF'</font> &amp; <font color="#000080">[errorcode]</font> = <font color="#0000ff">'-1'</font>[/code]<!-- br --><!-- br --><!--<!-- br --><div class="remark">If the script is executed on the file TEST.TXT we created with three lines, you will notice that a forth, empty line is read, before READFILE tells us that it reached the file's end at line five. The reason for this is that WRITEFILE has already appended a new line break behind our third line, so that TEST.TXT contains a number of four lines instead of the three written ones.</div><!-- br -->--><!-- br --><!-- br -->The READFILE-function is also able to read a file in one go, that means it can read a whole text file and returns it to a variable. This possibility is given when the value '0' (or a lower value than '0') is specified as the line number parameter to READFILE. In such a case, the whole file's content is returned.<br><br><!-- br --><!-- br -->[code]readfile <font color="#000080">[file]</font> = <font color="#0000ff">'test.txt'</font>, <font color="#0000ff">'0'</font><br /><!-- br -->echo <font color="#0000ff">'Content of TEST.TXT:'</font> # <font color="#000080">[new_line]</font> # <font color="#000080">[new_line]</font> # <font color="#000080">[file]</font>[/code]<!-- br --><br><!-- br -->The above script does also use the pre-declared variable [new_line] to insert two line breaks within the ECHO-message, before displaying the content of the file.<!-- br --><br><!-- br --><br><!-- br --><!-- br -->Both READFILE and WRITEFILE assign values to the variable [errorcode]. [errorcode] gets '-1' if a file could not be created at WRITEFILE or if the disk is full. '-1' is assigned to [errorcode] at READFILE if the file could not be opend or EOF has been reached. If all is fine and no errors occured, [errorcode] gets '0'.<!-- br --><br><!-- br --><br><!-- br --><!-- br -->RapidBATCH is also able to work on files using the binary method, since version 5.0. For such cases, the instruction PUTFILE and the function GETFILE is provided for writing and reading files in binary-method. As binary files, all files that are no plain text files, are defined. Even Office-Files like DOC or XLS are no plain text files, it are even binary files!<br><!-- br -->But however, in the next examples, we will write and read text files again, but now on a binary basis. As a matter of course, it is also possible to write and read any desired character, including control characters and characters from the extended ASCII-character table to or from a file.<br><br><!-- br --><!-- br -->To write a file (which can also be a text file!) in binary mode, we use the already mentioned PUTFILE-instruction. PUTFILE can only write to existing files. If the file does not exist, it must be created explicitly using NEWFILE.<!-- br --><!-- br --><div class="remark"><!-- br -->ASCII is an abbreviation for &quot;American Standard Code for Information Interchange&quot;. The standard ASCII code table exists of at least 128 so called &quot;ASCII characters&quot;. Not every of these characters is printable, so that only 96 of them can really be displayed. RapidBATCH does also support the extended ASCII-table character set, so that at least 256 characters can be displayed. These additional 128 characters contain special characters like umlauts, currency symbols, and more. Each of these character has a number from 0 to 256, the so called &quot;ASCII-code&quot;, which can be specified.<!-- br --></div><!-- br --><!-- br -->The following example saves the text &quot;Hello World&quot; in binary to the file BINARY.TXT. Next to the filename of the file PUTFILE should write to, it expects as second parameter the byte-offset (as offset, a position of bytes from the beginning of the file is meaned) where the writing operation should start within the file, and as third parameter a list of ASCII-character codes that should be written. This list contains only the numerical ASCII codes of each character that should be written, not the character itself. Each character has to be seperated from the others using the RapidBATCH default list separator defined in the pre-declared variable [std_sep]. By default, this is the pipe-character &quot;|&quot; as it is used in the example below.<!-- br --><!-- br --><br><br><!-- br --><!-- br -->[code]newfile <font color="#0000ff">'binary.txt'</font><br /><!-- br -->putfile <font color="#0000ff">'binary.txt'</font>, <font color="#0000ff">'1'</font>, <font color="#0000ff">'72|101|108|108|111|32|87|111|114|108|100'</font><br /><!-- br -->open <font color="#0000ff">'binary.txt'</font>[/code]<!-- br --><br><!-- br --><!-- br -->In this case, we inserted 11 bytes to the file, where one byte (8 bits) is one ASCII-character.<!-- br --><!-- br --><div class="remark"><!-- br -->Note: To convert plain text to a list of ASCII character codes, use the following script I also used for myself to create the examples in this manual:<!-- br --><br><br><!-- br --><!-- br -->[code]<!-- br -->inputbox <font color="#000080">[plain]</font> = <font color="#0000ff">'Plain text'</font>, <font color="#0000ff">'Please enter a value that should be converted'</font>, <font color="#0000ff">''</font><br /><!-- br --><b>if</b> <font color="#000080">[plain]</font> = <font color="#0000ff">''</font> <b>halt</b><br /><!-- br --><br /><!-- br --><font color="#000080">[i]</font> = <font color="#0000ff">'0'</font><br /><!-- br -->getlen <font color="#000080">[len]</font> = <font color="#000080">[plain]</font><br /><!-- br --><font color="#000080">[list]</font> = <font color="#0000ff">''</font><br /><!-- br --><b>repeat</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> + <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;getcharat <font color="#000080">[char]</font> = <font color="#000080">[plain]</font>, <font color="#000080">[i]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;getasc <font color="#000080">[char]</font> = <font color="#000080">[char]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[list]</font> ! <font color="#0000ff">''</font> <font color="#000080">[list]</font> # <font color="#000080">[std_sep]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[list]</font> # <font color="#000080">[char]</font><br /><!-- br --><b>until</b> <font color="#000080">[i]</font> = <font color="#000080">[len]</font><br /><!-- br --><br /><!-- br --><font color="#000080">[clipboard]</font> = <font color="#000080">[list]</font><br /><!-- br -->echo <font color="#0000ff">'The text was converted to a list of ascii-codes and copied to the clipboard.'</font><br /><!-- br --><b>end</b><!-- br -->[/code]</div><!-- br --><!-- br --><!-- br -->Now, it is also possible to continue writing the file directly at another byte-offset, let's use offset 100:<br><!-- br --><br><!-- br --><!-- br -->[code]<font color="#808080">rem text: "To be continued..."</font><br /><!-- br --><font color="#000080">[text]</font> = <font color="#0000ff">'84|111|32|98|101|32|99|111|110|116|105|110|117|101|100|46|46|46'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem saving the text to offset 100 in the file "binary.txt"</font><br /><!-- br -->putfile <font color="#0000ff">'binary.txt'</font>, <font color="#0000ff">'100'</font>, <font color="#000080">[text]</font><!-- br -->[/code]<!-- br --><!-- br -->Sure, these lists of ASCII character code-values are not that easy to encode, but please remind that we're currently programming on the core RapidBATCH language without any customization. To use the binary operations more easier, it is recommended to write functions and procedures converting plain texts to ASCII lists, which can be adapted from the above converter script.<!-- br --><!-- br --><br><br><!-- br --><!-- br -->When we run the above script next to the first one, the file BINARY.TXT looks like the following when it is viewed using a hex-editor:<br><!-- br --><!-- br --><div class="image"><img src="img/hexview_binary.gif" title="Content of the file BINARY.TXT in a hex-editor."/><br /><!-- br -->Content of BINARY.TXT using a hex-editor.</div><!-- br --><!-- br -->Obviously, the second writing operation, beginning at hex-offset 64 (which is offset 100 in decimal), can be recognized. The area between our first &quot;Hello World&quot; and our second text, &quot;To be continued...&quot;, is filled with ASCII-code 0.<!-- br --><!-- br --><div class="remark">WARNING: On Windows 95, 98 and Millenium Edition (= any FAT or FAT-derivative file systems formatted drives) it was noticed that the content of deleted or overwritten files on the hard disk can become visible when starting a binary write anywhere within a file. On NTFS formatted drives, this phenomen was not noticed yet. To avoid this problem, fill out every byte until the desired position with ASCII code '0' or any other, desired character.</div><!-- br --><!-- br -->Please note, that PUTFILE does not do an append to a file like WRITEFILE, it stores its value to the specified offset, and overwrites existing values without any warning.<br><!-- br --><br><!-- br --><br><!-- br -->Reading a file in binary-mode is nearly the same way like writing it, using the GETFILE-function. GETFILE expects the path of the file that should be read, the starting-offset where the reading operation in the file should begin and a number of bytes, that should be read. Return value is, equivalently to the third parameter of PUTFILE, a list of ASCII character-codes, where each ASCII-code is seperated by the RapidBATCH default separator.<br<!-- br -->This list can be converted again to plain text (if required) using the GETCHR-function to convert a numerical ASCII-code value into a plain text character, like in the example script below that reads the text &quot;continued&quot; from the file we wrote above.<!-- br --><!-- br --><br><!-- br --><br><!-- br -->[code]<!-- br --><font color="#808080">rem read the data from the file</font><br /><!-- br -->getfile <font color="#000080">[data]</font> = <font color="#0000ff">'binary.txt'</font>, <font color="#0000ff">'100'</font> + <font color="#0000ff">'6'</font>, <font color="#0000ff">'9'</font><br /><!-- br -->echo <font color="#0000ff">'Read list of ascii-codes: '</font> # <font color="#000080">[data]</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem convert ascii-codes to ascii-characters</font><br /><!-- br --><font color="#000080">[i]</font> = <font color="#0000ff">'0'</font><br /><!-- br --><b>repeat</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> + <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;gettok <font color="#000080">[char]</font> = <font color="#000080">[data]</font>, <font color="#000080">[std_sep]</font>, <font color="#000080">[i]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[char]</font> ! <font color="#0000ff">''</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getchr <font color="#000080">[char]</font> = <font color="#000080">[char]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[plain]</font> # <font color="#000080">[char]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>endif</b><br /><!-- br --><b>until</b> <font color="#000080">[char]</font> = <font color="#0000ff">''</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem show the plain text</font><br /><!-- br -->echo <font color="#0000ff">'Plain text: '</font> # <font color="#000080">[plain]</font><br /><!-- br --><b>end</b>[/code]<!-- br --><br><!-- br --><!-- br -->Here, we read &quot;continued&quot; only by specifing the reading operation start offset to 106 because at offset 106, the word &quot;continued&quot; begins, and tell GETFILE, that 9 bytes from offset 106 should be read. The result is the string we wanted to get from the file!<br><!-- br --><!-- br -->If the offset values specified at GETFILE are huger that the file's size, an empty string or the characters until the file's end are returned by the function.<br><!-- br --><br><!-- br --><br><!-- br --><u>Why only text files in these examples?</u><br><!-- br --><!-- br -->Surely you asked yourself why we only write text files in binary mode in the above examples. For sure, only writing text files is not the sense and purpose of binary file operations, but I think that writing text files is a great lesson to get a feeling for writing files on binary basis. It is easier to write plain texts binary than writing or reading any cryptic characters to or from a file. PUTFILE and GETFILE lets you fully control a file, every information can be written and read. I guarantee you that you will use WRITEFILE and READFILE for the most file access operations, not only because they are easier to handle, but if you reach their limits, you can continue by using PUTFILE and GETFILE.
rb5_en_sysop_5.html§Controlling applications remotely§Another, effective possibility of automation is the controlling of other applications remotely. RapidBATCH has the possibility to let any other application (even other RapidBATCH scripts ;)) think, the user is typing keystrokes to use the program, but in reality, the RapidBATCH script gives the commands. For this purpose, RapidBATCH provides the SENDKEYS-instruction to control other applications by using an easy-to-use command language for sending keystrokes and key commands as they are fed from the computer's keyboard.<br><!-- br -->The following script demonstrates how to control the Windows editor &quot;Notepad&quot;. It runs Notepad and prints the text &quot;Hello World&quot; into the edit window. Then it saves the file as TEST.TXT and aborts Notepad again. The script's code:<!-- br --><br><!-- br --><br><!-- br --><!-- br -->[code]shell <font color="#000080">[windir]</font> # <font color="#0000ff">'\notepad.exe'</font>, <font color="#0000ff">'show'</font><br /><!-- br -->sendkeys <font color="#0000ff">'Untitled - Notepad'</font>, <font color="#0000ff">'Hello World^(alt)fstest.txt(enter)^(alt)(f4)'</font><br /><!-- br --><b>end</b>[/code]<!-- br --><br><!-- br --><!-- br -->As its first parameter, SENDKEYS expects the title of the application window where the keystrokes should be send to. If you want to send keystrokes to the currently activated window, use the RapidBATCH system-variable [active_window], containing the active window's text in the title-bar.<br><!-- br -->The next parameter contains commands in the already mentioned macro command language, that are send to the specified application.<br /><br /><!-- br --><!-- br -->So let's go a little bit deeper into this command language by using our example from above:<br><!-- br --><br><!-- br --><center><!-- br -->	<table class="std"><!-- br -->	<tr><!-- br -->		<td><!-- br -->			<b>Sections:</b><!-- br -->		</td><!-- br -->		<td align="center"><!-- br -->			A<!-- br -->		</td><!-- br -->		<td align="center"><!-- br -->			B<!-- br -->		</td><!-- br -->		<td align="center"><!-- br -->			C<!-- br -->		</td><!-- br -->		<td align="center"><!-- br -->			D<!-- br -->		</td><!-- br -->	</tr><!-- br -->	<tr><!-- br -->		<td><!-- br -->			<b>Commands:</b><!-- br -->		</td><!-- br -->		<td align="center"><!-- br -->			Hello World<!-- br -->		</td><!-- br -->		<td align="center"><!-- br -->			^(alt)fs<!-- br -->		</td><!-- br -->		<td align="center"><!-- br -->			test.txt(enter)<!-- br -->		</td><!-- br -->		<td align="center"><!-- br -->			^(alt)(f4)<!-- br -->		</td><!-- br -->	</tr><!-- br -->	</table><!-- br --></center><!-- br --><!-- br --><br><!-- br --><!-- br --><ul><!-- br -->	<li><!-- br -->		<b>Section A:</b><br><!-- br -->		At this point, we simply send the text &quot;Hello World&quot; to Notepad's edit field. It is important to first check if the input-cursor of the application you want to send text to is in the correct field. In the case of Notepad, the cursor is always directly set to the edit field to immediatelly start to enter text.<br /><!-- br -->	</li><!-- br -->	<li><!-- br -->		<b>Section B:</b><br><!-- br -->		Now we want to open the &quot;Save as...&quot;-dialog to store the typed text to a text-file. For this case, we have to press ALT and D at the same time on a natural keyboard. To emulate this behavior in RapidBATCH, we first push down the ALT-key and hold it. This is done by prefixing a circumflex-character to the desired key that should be pressed. Because the ALT-key is a special sort of key, this key is specified by putting it into parentheses, so the internal macro language interpreter of the SENDKEYS-instruction knows that you don't want to send the text &quot;alt&quot;, but you want to send the ALT-key.<!-- br --><br /><!-- br -->One important thing at this point: To send a left-parenthese as a character to a program, you must prefix this by a tilde-charactter (~). So the keystroke command &quot;~(&quot; will send a left-parenthese. Same with the curcumflex-character and even with the tilde-character itself. To send a circumflex, write &quot;~^&quot;, to send a single tilde, write &quot;~~&quot;.<br /><br /><!-- br --><!-- br -->Ok, now that we are pressing and holding the ALT-key at this point, we immediatelly send an &quot;f&quot; to let Notepad open its File-menu. When this &quot;d&quot; is sent, all keys that where hold down before are left again. If you want to hold more than one key at one time, you have to prefix a circumflex to each of the desired keys, so for example, the keystroke CTRL+ALT+DEL is specified in RapidBATCH's SENDKEYS-macro notation as &quot;^(control)^(alt)^(del)&quot;.<br /><!-- br --><!-- br -->To open the &quot;Save as...&quot; dialog, we simply send an &quot;s&quot afterwards. To find out which keys you have to press - especially in menus - watch out for the underlined characters. For example, the &quot;s&quot is the shortcut for the menu item &quot;Save&quot; in the Notepad-Editor's file menu.<br /><!-- br -->	</li><!-- br -->	<li><!-- br -->		<b>Section C:</b><br><!-- br -->		Now, after opening the &quot;Save as...&quot;-dialog, we &quot;type&quot; in the filename, in this case &quot;test.txt&quot;, via SENDKEYS. Because this is even an ordinary text, no special characters are required. To confirm our input we then press the Enter key, which automatically activates the &quot;Save&quot;-button of the &quot;Save as...&quot;-dialog. This is done by simply specifying the command <i>(enter)</i>.<br><!-- br -->	</li><!-- br -->	<li><!-- br -->		<b>Section D:</b><br><!-- br -->		At the end, we send an ALT+F4, to close the application. Because ALT+F4 need to be pressed at the same time, we hold down ALT first (by specifying <i>^(alt)</i>), and then we press F4, by specifying <i>(f4)</i>. By the way, it is a damn how you write special key commands. You can specify (Alt) same als (ALT) and (AlT) - it will always identify the ALT-key!<br><!-- br -->	</li><!-- br --></ul><!-- br --><br><!-- br --><!-- br -->To get an overview about the possible special keys and their naming, take a look into the RapidBATCH language reference.<!-- br --><br><!-- br --><br><!-- br --><br><!-- br --><!-- br -->Next to SENDKEYS, RapidBATCH provides another possibilty to control other applications by remote: The MOUSEEVENT-instruction. MOUSEEVENTS lets you simulate any mouse events on your screen. The RapidBATCH-script can get the full control over the mouse of the computer and can take any mouse events like moves, clicks, doubleclicks or mouse key holds.<br><!-- br --><br><!-- br -->Please note, that I only want to give a short introducion to this possibility, because it is not possible to create a well running demo-script using MOUSEEVENT that can be run the same way on any Windows-system RapidBATCH supports, additionally the different screen resolutions and languages. This means, that you should only use this feature within your scripts if you're sure that it runs on all systems your script is used on.<!-- br --><br><!-- br --><br><!-- br -->The following call of MOUSEEVENT centers the cursor on the screen, using the variables [ScreenWidth] and [ScreenHeight] to retrieve the current screen resolution.<!-- br --><br><br><!-- br --><!-- br -->[code]<!-- br -->mouseevent <font color="#0000ff">'move'</font>, (<font color="#000080">[ScreenWidth]</font>/<font color="#0000ff">'2'</font>) # <font color="#0000ff">'|'</font> # (<font color="#000080">[ScreenHeight]</font>/<font color="#0000ff">'2'</font>)<!-- br -->[/code]<!-- br --><!-- br -->As you can get from the line above, MOUSEEVENT expects two parameters. The first one is the so called mouse action identifier, and second one the screen coordinates which are again specified as a list here in the format &quot;X|Y&quot;, where X and Y is the pixel position on the corresponding axis. Here, the mouse cursor is centered on the screen by specifing the half of the screen resolution on each of the two axes.<!-- br --><br><br><!-- br --><!-- br -->As mouse action identifiers, you can specify one of the following values:<!-- br --><!-- br --><ul><!-- br -->  <li>'0' or 'MOVE' (move the mouse only, no click)</li><!-- br -->  <li>'1' or 'CLICK_LEFT' (perform single left-click)</li><!-- br -->  <li>'2' or 'DBLCLICK_LEFT' (perform double left-click)</li><!-- br -->  <li>'3' or 'CLICK_RIGHT' (perform single right-click)</li><!-- br -->  <li>'4' or 'DBLCLICK_RIGHT' (perform double right-click)</li><!-- br -->  <li>'5' or 'DOWN_LEFT' (hold left mouse key)</li><!-- br -->  <li>'6' or 'UP_LEFT' (leave left mouse key)</li><!-- br -->  <li>'7' or 'DOWN_RIGHT'  (hold right mouse key)</li><!-- br -->  <li>'8' or 'UP_RIGHT' (leave right mouse key)</li><!-- br --></ul>
rb5_en_sysop_6.html§Working on the registry§Since version 5.0, RapidBATCH is also supporting directly access to the Windows-Registry. The &quot;registry&quot; is a a configuration and customization database provided by the Windows operating system family since Windows 95 and NT4. The major purpose of the Windows registry is to customize Windows, change system settings and to provide a possibility for programs and applications on the computer where they can save user- and system-dependend configuration informations and settings. Even the RapidBATCH Builder uses the registry to store e.g. the file history of the latest files or the tools provided in the Tools-menu in the menu bar.<br><!-- br -->The registry is edited using the program &quot;regedit&quot; which also is an inherent part of the Windows operating system. Run it by clicking <i>Start -&gt; Run</i> and then type &quot;regedit&quot; and hit enter.<!-- br --><!-- br --><br><!-- br --><br><!-- br --><!-- br -->The registry is build on a Windows file system likely structure. There is a root, having five so called &quot;pre-defined keys&quot;. These keys cannot be changed or modified. Registry keys are like folders in the Windows file system, and may contain subkeys or even values. Values can be seen as files when we compare the registry with the Windows file system.<!-- br --><br><br><!-- br --><!-- br -->Now, a short description of the five pre-defined keys in the registry's root.<!-- br --><!-- br --><ul><!-- br -->	<li><b>HKEY_CLASSES_ROOT</b><br><!-- br -->	This is a subkey of HKEY_LOCAL_MACHINE\Software. The information stored here ensures that the correct program opens when you open a file by using Windows Explorer.<!-- br -->	</li><!-- br -->	<li><b>HKEY_CURRENT_USER</b><br><!-- br -->	Contains the root of the configuration information for the user who is currently logged on. The user's folders, screen colors, and Control Panel settings are stored here. This information is referred as a user's profile.</li><!-- br -->	<li><b>HKEY_LOCAL_MACHINE</b><br><!-- br -->	This key contains configuration information is important for any user.<!-- br -->	</li><!-- br -->	<li><b>HKEY_USERS</b><br><!-- br -->	Contains the root of all user profiles on the computer. HKEY_CURRENT_USER is a subkey of HKEY_USERS.<!-- br -->	</li><!-- br -->	<li><b>HKEY_CURRENT_CONFIG</b><br><!-- br -->	Contains information about the hardware profile used by the local computer at system startup.<!-- br -->	</li><!-- br --></ul><!-- br --><!-- br -->Using RapidBATCH, you can use the registry now without compromise. You can evenly use it to automate the change of settings and values of any other application or even for your script itself, storing e.g. user-dependend informations. You can create and delete keys, create and modify values and even delete them.<!-- br --><!-- br --><br><br><!-- br --><!-- br -->To create and delete a key, RapidBATCH provides the instruction NEWREGKEY and DELREGKEY. NEWREGKEY creates a new subkey, DELREGKEY deletes a subkey including all of its subkeys and values from the registry.<br><!-- br --><!-- br -->As parameter, both instructions expect a pre-defined main key identifier by specifing the values 'CLASSES_ROOT', 'CURRENT_CONFIG', 'CURRENT_USER', 'LOCAL_MACHINE' or 'USERS' for the particular key, as well as the path to the key that should be created newly. The following script generates a new key in HKEY_CURRENT_USER, that is named &quot;Test&quot;.<!-- br --><!-- br --><br><!-- br --><br><!-- br --><!-- br -->[code]<font color="#808080">rem create a new registry key </font><br /><!-- br -->newregkey <font color="#0000ff">'CURRENT_USER'</font>, <font color="#0000ff">'Test'</font><br /><!-- br --><b>if</b> <font color="#000080">[errorcode]</font> = <font color="#0000ff">'0'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Creating HKEY_CURRENT_USER\Test succeeded.'</font><br /><!-- br --><b>else</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Error when trying to create HKEY_CURRENT_USER\Test.'</font><br /><!-- br --><b>endif</b><br /><!-- br --><br /><!-- br --><font color="#808080">rem remove an existing key</font><br /><!-- br -->delregkey <font color="#0000ff">'CURRENT_USER'</font>, <font color="#0000ff">'Test'</font><br /><!-- br --><b>if</b> <font color="#000080">[errorcode]</font> = <font color="#0000ff">'0'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'HKEY_CURRENT_USER\Test has been deleted successfully.'</font><br /><!-- br --><b>else</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Error when trying to delete HKEY_CURRENT_USER\Test.'</font><br /><!-- br --><b>endif</b>[/code]<!-- br --><!-- br -->It is important that the next higher key level of the key that should be created is existing, because NEWREGKEY does not create all keys automatically to reach its path if they do not exist, as it is the case at the MKDIR-instruction. There is no equivalency.<br><br><!-- br --><!-- br -->If you now want to save into or add a value to a key, RapidBATCH provides the instruction LETREGKEY. LETREGKEY supports three different data types that can be written, these are STRING, BINARY and DWORD. Additionally, the instruction expects the pre-defined main key identifier as it is specified at NEWREGKEY/DELREGKEY as well as the path of the key. Next to this, a labeling text for the new value is optionally required (if this is left blank, the value is saved into the key itself, which is also possbile). The last parameter is finally the value in the particular format. The next example creates a new value named &quot;HelloWorld&quot; under the key &quot;Test&quot; in &quot;HKEY_CURRENT_USER&quot; (the key is created again using NEWREGKEY before the value is added).<!-- br --><!-- br --><br><br><!-- br --><!-- br -->[code]<font color="#808080">rem create testing key</font><br /><!-- br -->newregkey <font color="#0000ff">'CURRENT_USER'</font>, <font color="#0000ff">'Test'</font><br /><!-- br --><b>if</b> <font color="#000080">[errorcode]</font> = <font color="#0000ff">'0'</font><br /><!-- br --><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem write a value to the registry</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;letregval <font color="#0000ff">'string'</font>, <font color="#0000ff">'CURRENT_USER'</font>, <font color="#0000ff">'Test'</font>, <font color="#0000ff">'HelloWorld'</font>, <font color="#0000ff">'This is a value!'</font><br /><!-- br --><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem has the value been saved successfully?</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[errorcode]</font> = <font color="#0000ff">'0'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'The value has been successfully written to the registry!'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>else</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Error when trying to write the registry.'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>endif</b><br /><!-- br --><b>endif</b>[/code]<!-- br --><!-- br --><div class="image"><img src="img/sysop_regvalue1.gif" alt="The just created value in the registry editor" title="Viewing the just created value in the registry editor." /><br /><!-- br -->The value has been written successfully!</div><!-- br --><!-- br -->To write a binary value using LETREGVAL, the value has to be specified the same way as it is done at the PUTFILE-instruction: A list of ASCII character codes, separated by pipe-characters (or the as [std_sep] defined character). This example writes the string &quot;Hello World&quot; in binary form into the registry as the value name &quot;binary_HelloWorld&quot;:<!-- br --><!-- br --><br><br><!-- br --><!-- br -->[code]<font color="#808080">rem write a binary value into the registry</font><br /><!-- br --><font color="#000080">[hello]</font> = <font color="#0000ff">'72|101|108|108|111|32|87|111|114|108|100'</font><br /><!-- br -->letregval <font color="#0000ff">'binary'</font>, <font color="#0000ff">'CURRENT_USER'</font>, <font color="#0000ff">'Test'</font>, <font color="#0000ff">'binary_HelloWorld'</font>, <font color="#000080">[hello]</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem was the operation successfull?</font><br /><!-- br --><b>if</b> <font color="#000080">[errorcode]</font> = <font color="#0000ff">'0'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'The registry has been written successfully.'</font><br /><!-- br --><b>else</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Error when trying to write the registry.'</font><br /><!-- br --><b>endif</b>[/code]<!-- br --><!-- br --><div class="image"><img src="img/sysop_regvalue2.gif" alt="View of a binary saved value in the registry editor." title="Editing the binary value in the registry editor." /><br /><!-- br -->An evidence &quot;Hello World&quot; has been written in binary order to the registry!</div><!-- br --><!-- br -->If you want to save a DWORD-value, you may only save numerical 32-bit integer values into the registry.<br><br><!-- br --><!-- br -->Reading from the registry is here equivalently done by using a function call GETREGVAL. Parameters are nearly the same like at LETREGVAL, except there is no value-parameter expected because this is returned by the function.<!-- br --><br><!-- br --><br><!-- br -->This example reads the two values we wrote above from the registry again:<br><br><!-- br --><!-- br -->[code]<font color="#808080">rem reading a string value</font><br /><!-- br -->getregval <font color="#000080">[text]</font> = <font color="#0000ff">'string'</font>, <font color="#0000ff">'CURRENT_USER'</font>, <font color="#0000ff">'Test'</font>, <font color="#0000ff">'HelloWorld'</font><br /><!-- br -->echo <font color="#0000ff">'String value in "HelloWorld" is: '</font> # <font color="#000080">[text]</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem reading a binary value</font><br /><!-- br -->getregval <font color="#000080">[data]</font> = <font color="#0000ff">'binary'</font>, <font color="#0000ff">'CURRENT_USER'</font>, <font color="#0000ff">'Test'</font>, <font color="#0000ff">'binary_HelloWorld'</font><br /><!-- br -->echo <font color="#0000ff">'Read ASCII-list from "binary_HelloWorld": '</font> # <font color="#000080">[data]</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem convert ASCII-codes to ASCII-characters and build a string of these characters</font><br /><!-- br --><font color="#000080">[i]</font> = <font color="#0000ff">'0'</font><br /><!-- br --><b>repeat</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> + <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;gettok <font color="#000080">[char]</font> = <font color="#000080">[data]</font>, <font color="#000080">[std_sep]</font>, <font color="#000080">[i]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[char]</font> ! <font color="#0000ff">''</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getchr <font color="#000080">[char]</font> = <font color="#000080">[char]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[plain]</font> # <font color="#000080">[char]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>endif</b><br /><!-- br --><b>until</b> <font color="#000080">[char]</font> = <font color="#0000ff">''</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem output the plain text</font><br /><!-- br -->echo <font color="#0000ff">'Plain text converted from "binary_HelloWorld": '</font> # <font color="#000080">[plain]</font>[/code]<!-- br --><!-- br -->At the end, we delete the registry values again using the DELREGKEY instruction that is used to delete any value from the registry.<br><br><!-- br --><!-- br -->[code]<font color="#808080">rem remove "HelloWorld"</font><br /><!-- br -->delregval <font color="#0000ff">'CURRENT_USER'</font>, <font color="#0000ff">'Test'</font>, <font color="#0000ff">'HelloWorld'</font><br /><!-- br --><b>if</b> <font color="#000080">[errorcode]</font> ! <font color="#0000ff">'0'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Error when trying to delete "HelloWorld"'</font><br /><!-- br --><b>endif</b><br /><!-- br --><br /><!-- br --><font color="#808080">rem delete "binary_HelloWorld"</font><br /><!-- br -->delregval <font color="#0000ff">'CURRENT_USER'</font>, <font color="#0000ff">'Test'</font>, <font color="#0000ff">'binary_HelloWorld'</font><br /><!-- br --><b>if</b> <font color="#000080">[errorcode]</font> ! <font color="#0000ff">'0'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Error when trying to delete "binary_HelloWorld"'</font><br /><!-- br --><b>endif</b>[/code]
rb5_en_sysop_7.html§Using pre-declared variables§Maybe the chapter &quot;system operations&quot; is not the right place to discuss all pre-declared variables RapidBATCH provides, but many of the pre-declared variables are dealing with system-specific purposes. Until now, you had already learned some of the so called &quot;pre-declated variables&quot;. Pre-declared variables are automatically created and filled by the interpreter at the start-up of each script that is executed. Some of the pre-declared variables can be changed, others are directly evaluated when they are called.<br><!-- br -->In this chapter, I don't want to discuss all, system-specific variables RapidBATCH provides, but the most important ones. To get detailed information on every of the pre-declared variables RapidBATCH provides, take a look into the reference manual.<!-- br --><br><br><!-- br --><!-- br -->Oftenly it is required to pass parameters, for example options or processing informations to a program over its command-line call. This feature may not miss in RapidBATCH! The variable [command] contains all parameters which where passed on to the script file or compiled program at its start-up. If the script is executed by the interpreter, [command] contains all parameters that where specified behind the script's file name at the interpreter call (RBI32.EXE), in compiled scripts (stand-alone EXE-files), all parameters specified behind the exe-file's name can be determined from [command].<br><!-- br --><!-- br -->A good example is the following script. It simply outputs the content of [command] in a ECHO-messagebox. For testing and debugging purposes, the RapidBATCH Builder directly provides a function you can call over the &quot;Script&quot;-menu by choosing the menu item &quot;Set [command]...&quot;. A dialog will open where you can enter any desired value that is assigned by RapidBATCH Builder to the script each time it is executed.<!-- br --><!-- br --><br><br><!-- br -->[code]echo <font color="#0000ff">'Command-line parameters passed to this script call: '</font> # <font color="#000080">[command]</font><br /><!-- br --><b>end</b>[/code]<!-- br --><!-- br --><div class="image"><img src="img/sysop_pdvar1.gif" alt="Function to enter command-line parameters directly from RapidBATCH Builder" title="Setting command-line parameters" /><br /><!-- br -->The function &quot;Set [command]...&quot; is very useful to easily assign command-line parameters...</div><!-- br --><div class="image"><img src="img/sysop_pdvar2.gif" alt="Displaying the assigned command-line parameters." title="Displaying [command]" /><br /><!-- br -->...with success!</div><!-- br --><!-- br --><div class="remark">Note: The values that are assigned to [command] can be directly transferred into an array of parameters by calling the procedure <i>GETCMDLINEPARMS</i> from the SYSTEM.RB extending function library.</div><!-- br --><!-- br --><!-- Geilo: Groove Coverage - Force Of Nature hör *fieps* --><!-- br --><!-- br -->Your script should handle with texts from the clipboard? By performing a simple assignment of a value to the variable [clipboard], the value can be made accessable to all applications the current user is running. By reading [clipboard], values other applications copied to the clipboard can be read and used within the script.<br><br><!-- br --><!-- br -->A simple example is the following script, that copies a value into the clipboard and directly demonstrates its use in a Notepad editor, by pasting it remotely.<!-- br --><br><!-- br --><br><!-- br --><!-- br -->[code]<font color="#808080">rem show me the current content of the clipboard</font><br /><!-- br -->echo <font color="#0000ff">'Currently in the clipboard: '</font> # <font color="#000080">[clipboard]</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem let's write a "Hello World" into the clipboard!</font><br /><!-- br --><font color="#000080">[clipboard]</font> = <font color="#0000ff">'Hello World by RapidBATCH'</font><br /><!-- br -->echo <font color="#0000ff">'New content of the clipboard: '</font> # <font color="#000080">[clipboard]</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem demonstrating the clipboard's content in Notepad</font><br /><!-- br -->shell <font color="#000080">[windir]</font> # <font color="#0000ff">'\notepad.exe'</font>, <font color="#0000ff">'show'</font><br /><!-- br -->wait <font color="#0000ff">'500'</font><br /><!-- br -->sendkeys <font color="#000080">[active_window]</font>: <font color="#0000ff">'The current content of the clipboard is: #271v#017'</font><br /><!-- br --><b>end</b>[/code]<!-- br --><!-- br -->And there you can also find the next, pre-declared variable in the above script: [active_window]! [active_window] contains the title bar's text of the currently activated window, so in the above case it will contain &quot;Untitled - Notepad&quot;. The advantage of this variable is, that the script can be run language idependend. For example, in the german version of Windows XP, Notepad's title is &quot;Unbenannt - Editor&quot; instead of &quot;Untitled - Notepad&quot;.<br><!-- br --><!-- br -->Next to [active_window], the above script uses the variable [windir], containing the path to the Windows system directory, where notepad.exe is stored to.<br><br><!-- br --><!-- br --><!-- br -->Reading the system date and system time is also no problem for RapidBATCH. The following script displays a clock, showing the current date and time, using the INFOBOX dialog. The clock will appear for 10 seconds until the script stops, and shows its informations to the second.<br><br><!-- br --><!-- br -->[code]<font color="#000080">[i]</font> = <font color="#0000ff">'0'</font><br /><!-- br --><b>repeat</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> + <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;infobox <font color="#0000ff">'It is '</font> # <font color="#000080">[time]</font> # <font color="#0000ff">' on '</font>  # <font color="#000080">[month]</font> # <font color="#0000ff">'/'</font> # <font color="#000080">[day]</font> # <font color="#0000ff">'.'</font> # <font color="#000080">[year]</font>, <font color="#0000ff">'show'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;wait <font color="#0000ff">'1000'</font><br /><!-- br --><b>until</b> <font color="#000080">[i]</font> = <font color="#0000ff">'10'</font><br /><!-- br --><b>end</b>[/code]<!-- br --><!-- br -->The variable [time] contains the current time and is updated with the current system time always when it is called. The format [time] uses is &quot;HH:MM:SS&quot;, for example &quot;13:37:45&quot;. The date information has been explicitly splitted to three variables: [day], [month] and [year]. This has been done for a fast date formatting, because RapidBATCH is an internationally provided product, and its scripts should be easily written for optimal language customization. For example, here in Germany, we write dates in the format &quot;DD.MM.YYYY&quot;, in western countries it is &quot;MM/DD/YYYY&quot; or another formatting. So the division into three variables is the best possibility for a fast and completely individual date output formatting.<!-- br --><br><br><!-- br --><!-- br --><div class="image"><img src="img/sysop_pdvar3.gif" alt="Displaying the current time and date within an INFOBOX-dialog window." title="The current time and date within an INFOBOX-dialog." /><br /><!-- br -->The current time and date within an INFOBOX-dialog.</div><!-- br --><!-- br -->Oftenly it is also required to output special characters to files or even into messagebox-windows or dialogs. For this purpose, there had been five special character variables implemented which are the time-safing alternative instead of getting and building these values using the GETCHR-function with the particular ASCII-character codes. First of all, there is the [new_line]-variable. It contains a single line break (character code 10) and can be used both for files and for dialog outputs. On Windows operating systems, there is also a special line break used within files (e.g. text files) that is called Carriage Return/Line Feed (character codes 13 and 10). These two names, carriage return and line feed, are relicts from the stone age of the computer, where data and program output was primarily outputted to printers. There, a carriage return with a trailing line feed character was necessary to generate a line break. On Unix-based systems, the single line break as provided by [new_line] is the default, on Windows-like systems it is carriage return and line feed, that is provieded by the variable [crlf].<br><!-- br -->Next to [new_line] and [crlf], RapidBATCH provides the variable [tab] that contains a tabulator character as well as the variable [pipe], containing a pipe-character (|) that is primarily used as RapidBATCH default list separator at LISTBOX or PUTFILE, and many other functions and instructions. The last variable, [quot], contains the single quotation character (') that is used in the RapidBATCH script-code to separate strings. Using [quot], it can be displayed and saved into strings.<!-- br --><!-- br --><br><br><!-- br --><!-- br -->[code]<font color="#808080">rem line breaks</font><br /><!-- br -->echo <font color="#0000ff">'This is a'</font> # <font color="#000080">[new_line]</font> # <font color="#0000ff">'line break using'</font> # <font color="#000080">[crlf]</font> # <font color="#0000ff">'two methods'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem tabulators</font><br /><!-- br -->echo <font color="#0000ff">'It is a '</font> # <font color="#000080">[tab]</font> # <font color="#0000ff">'tabulator!'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem pipe-character</font><br /><!-- br -->echo <font color="#0000ff">'The as '</font> # <font color="#000080">[std_sep]</font> # <font color="#0000ff">' defined character is a '</font> # <font color="#000080">[pipe]</font> # <font color="#0000ff">' by default'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem quotation mark</font><br /><!-- br -->echo <font color="#0000ff">'That'</font> # <font color="#000080">[quot]</font> # <font color="#0000ff">'s it!'</font>[/code]<!-- br --><!-- br -->Also known from the previous chapters is the variable [errorcode], which mostly receives the value '0' for &quot;true&quot; or &quot;operation succeeded&quot; or '-1' for &quot;false&quot; or &quot;operation failed&quot; (the only exceptions are the instructions SHELL and CALL, returning the program's PID at success instead of '0'). To verify this value in a more professional and dynamic way, there had been introduced the variables [true] (containing a '0') and [false] (containing a '-1') to be verified within an [errorcode] examination-condition. By using these variables, you also contribute for a better code readability.<!-- br --><!-- br --><br><br><!-- br --><!-- br -->[code]<!-- br -->chdir <font color="#0000ff">'C:\test'</font><br /><!-- br --><br /><!-- br --><b>if</b> <font color="#000080">[errorcode]</font> = <font color="#000080">[false]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Error, not able to change directory!'</font><br /><!-- br --><b>else</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'The directory change succeeded!'</font><br /><!-- br --><b>endif</b>[/code]<!-- br --><!-- br -->In the end of this chapter I want to discuss a variable that does, in the truest sense of the word, nothing: [null]! This variable has for example the purpose to catch return-values of functions (mostly self-implemented functions) that are not needed or to assign an emptystring instead of specifying &quot;''&quot; to a procedure, instruction or function. The advantage is, that the use of this variable for parameters or return values that are not needed is directly caught, and superfluous memory resources are saved.
