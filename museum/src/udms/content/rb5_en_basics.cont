template.html§0TITLE§1CONTENT
rb5_en_basics_1.html§A first, simple script§Already in the preamble of this manual, we presented you a simple script, composed of only two simple lines of code, that should demonstrate the fundamental structure of a program written in the RapidBATCH scripting language:<!-- br --><!-- br --><br><!-- br --><br><!-- br -->[code]echo <font color="#0000ff">'Hello World'</font><br /><!-- br --><b>end</b><!-- br -->[/code]<!-- br --><!-- br -->To run this script, its code first needs to be inputted and saved as a RapidBATCH script-file with the .RB file extension.<br><br><!-- br --><!-- br -->To input and edit scripts, I strongly recommend to use the included script-editor RapidBATCH Builder, providing a comfortable environment to edit, run and debug your scripts. You start the Builder over the start menu (Start -&gt; Programs -&gt; RapidBATCH 5.0 Professional Edition/RapidBATCH 5.0 Personal Edition -&gt; RapidBATCH 5.0) or by double-clicking the file RBB4.EXE from the RapidBATCH setup-directory.<!-- br --><br><br><!-- br --><!-- br -->After you activated RapidBATCH Builder, insert the above source code.<!-- br --><!-- br --><div class="image"><img src="img/firstscript1.gif" alt="First steps in the RapidBATCH Builder" title="RapidBATCH Builder" /><br /><!-- br -->Inserting the code in the RapidBATCH Builder.</div><!-- br --><!-- br -->Then, save the script in a directory of your choice under the filename HELLO.RB (or any other desired filename). Now, the script can be executed by pressing F5 or the &quot;Run script&quot; button from the RapidBATCH Builder's toolbar. <!-- br --><!-- br --><!-- br --><div class="image"><img src="img/firstscript2.gif" alt="First steps in the RapidBATCH Builder" title="RapidBATCH Builder" /><br /><!-- br -->The script is running!</div><!-- br --><!-- br -->Congratulations to your first, running script in RapidBATCH!<br><br><!-- br --><!-- br -->If you're using the RapidBATCH Professional Edition, you can also directly compile your script into a stand-alone .EXE-file that can be executed on any Windows&reg; computer without an installed RapidBATCH scripting platform. To do this, select &quot;Script&quot; and then &quot;Compile&quot; from the menu bar.<!-- br --><!-- br --><div class="image"><img src="img/firstscript3.gif" alt="First steps in the RapidBATCH Builder" title="RapidBATCH Builder" /><br /><!-- br -->Compiling a script into a standalone .EXE-file.</div><!-- br --><!-- br --><div class="image"><img src="img/firstscript4.gif" alt="First steps in the RapidBATCH Builder" title="RapidBATCH Builder" /><br /><!-- br -->The compiled script will be saved to the same directory as the .RB-file.</div><!-- br --><!-- br -->Now, after you executed and compiled your script, let's describe the usage and meaning of the source code we entered above. The first instruction, ECHO, displays, as you surely noticed, a text in a messagebox window, in this case &quot;Hello World&quot;. The text is specified between singe quotation marks ('...'). These marks need always been set when a value is specified to a function or instruction. In some cases, e.g. also at ECHO, you can omit these quotation marks, which is the old-styled, classic method RapidBATCH supported in the past. This style does not fit to the modern RapidBATCH standard anymore, and is not recommended. In general, you should always set quotation marks when specifying values to write easy-to-read and consistent code.<br><br><!-- br -->The END-instruction, following to ECHO in a new line, marks the end of the script. END is also not required, but simply belongs to the script when writing smart, tidy code.<br><br><!-- br --><!-- br -->If the instructions and functions you specify are written in upper or lower letters belongs to you. RapidBATCH makes no decisions when you write &quot;ECHO&quot;, &quot;EcHo&quot; or &quot;echo&quot;. I prefer the lower case order, as it is the case in this example. Blanks can be set everywhere you want for better code readability. The end of the line (means: the line break) automatically marks the end of the instruction, that means you need to insert a new line for each instruction you want to execute.<br><br><!-- br --><!-- br -->First of all, before we now really begin to use the mighty functions and nearly endless possibilities RapidBATCH provides, I want to suggest you to the use of comments. Comments can be seen as notes in the code of your script, describing the usage of several operations or function calls your program performs. This possibility enables automatically a form of documentation for your script, if for yourself, other developers or maybe the script's users, to understand and follow the steps you made when solving your software problems without only reading tons of code. This does not mean that you always NEED to comment each line of code in your script, but sometimes, a comment is very use- and helpful. From now, I will comment all locations in the examples I demonstrate you where I think that a comment fits and is helpful.<br><!-- br -->To define a comment in a RapidBATCH script, use the REM-instruction. This instruction marks a comment in the code. The comment applies until the next line begins.<br><!-- br --><br><!-- br --><!-- br -->Here, a commented version of our &quot;Hello World&quot; script:<!-- br --><br><br><!-- br -->[code]<font color="#808080">rem display Hello World</font><br /><!-- br -->echo <font color="#0000ff">'Hello World'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem end of the script</font><br /><!-- br --><b>end</b>[/code]<!-- br --><!-- br -->Please note, that comments can not be inserted behind instructions, because REM is a RapidBATCH instruction like ECHO or any other one, and must be specified in a single line.<br><br><!-- br --><!-- br -->And now, let's begin with the RapidBATCH programming tutorial.<br><br><!-- br -->If you are not that familiar with the use of the RapidBATCH Builder yet, just try out all its functions before you continue, because the following pages are not discussing the usage of the easily useable RapidBATCH Builder anymore.
rb5_en_basics_2.html§Working with variables§Now that you have written and ran your first script, we will begin a slightly different part of programming, the <i>variables</i>. Variables are the key to complex and flexible computer programs which act and run on the basis of variable data (because the workflow of a program depends on this variable data).<br><!-- br -->The next script should now demonstrate how variables are used and what an (important) role they can play. Create a new, empty script in the RapidBATCH Builder and enter the following source code:<!-- br --><br><!-- br --><br><!-- br --><!-- br -->[code]<font color="#808080">rem Ask for the user's name</font><br /><!-- br -->inputbox <font color="#000080">[user]</font> = <font color="#0000ff">'Name?'</font>, <font color="#0000ff">'What is your name?'</font>, <font color="#0000ff">''</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem Output the prompted name</font><br /><!-- br -->echo <font color="#000080">[user]</font><br /><!-- br --><b>end</b>[/code]<!-- br --><br><!-- br --><!-- br -->This script prompts the user for his name by using the INPUTBOX-function. The name the user enters will be saved in the variable with the variable-name [user] in front of the equal-character (=). Variables are always written between brackets, and can be used anywhere you can use constant values. This is done by directly specifying the variable instead of the constant value. That's the case in the ECHO instruction following the INPUTBOX dialog. We specify the variable name instead of a constant data to the instruction, that means we output the dynamic content of the variable [user] (which can be any name or data the user entered) in this ECHO-messagebox.<!-- br --><br><br><!-- br --><!-- br -->Variables in RapidBATCH can store both texts (also called &quot;strings&quot;, even character strings) and numbers (numerical values). The conversion between the different data types occurs internally so that you, the programmer, don't have to deal with this subject.<br><!-- br -->In the past versions of the RapidBATCH-series (until RapidBATCH 4.0), it had always been necessary to declare variables explicitly before their first usage by using the DEC instruction. You can still use DEC if you like, but variables are declared automatically now right when any value is assigned to them. DEC will also play an important role later, when we build own procedures and functions.<!-- br --><br><!-- br --><br><!-- br -->Probably you have already noticed how variables are handled: You can store data into them and use this variable data instead of constant values in all instructions.<!-- br --><br><!-- br --><br><!-- br -->To assign a constant value or the value of another variable to a variable, you need to do a so called assignment by following this scheme:<!-- br --><br><!-- br --><br><!-- br -->[code]<font color="#000080">[variable]</font> = <font color="#0000ff">'Value'</font>[/code]<!-- br --><br><!-- br -->e.g.<br><!-- br --><br><!-- br -->[code]<font color="#000080">[user]</font> = <font color="#0000ff">'Neo'</font>[/code]<!-- br --><br><!-- br -->or by assigning the content of an existing variable to a new one:<br><!-- br --><br><!-- br -->[code]<font color="#000080">[user]</font> = <font color="#000080">[name]</font>[/code]<!-- br --><br><!-- br --><!-- br -->In variable assignments, values can also be joined and calculated. For this case, RapidBATCH provides six different operators which can be used to join values together or calculate values to receive a result.<!-- br --><br><!-- br -->The following script joins two values, a constant value with a variable value, using the join-operator (#), and assigns this new value to the variable [output]:<!-- br --><br><!-- br --><br><!-- br -->[code]<font color="#000080">[output]</font> = <font color="#0000ff">'Your name is: '</font> # <font color="#000080">[user]</font>[/code]<!-- br --><br><!-- br -->Such a join (and also a calculation) can also be assigned as a parameter value to any instruction/function:<br><!-- br --><br><!-- br -->[code]echo <font color="#0000ff">'Your name is: '</font> # <font color="#000080">[user]</font>[/code]<!-- br --><br><!-- br --><!-- br -->Using the operators +, -, *, / and ~ for addition, subtraction, multiplication, division and modulo, variables and also values can be calculated. The only condition that must be given is, that all values used within the calculation contain numerical data. For example, when you want to calculate a variable containing the string 'Hello', RapidBATCH internally handles it as value '0'.<!-- br --><br><!-- br --><br><!-- br -->The following script demonstrates how to sum two values together using the addition-operator (+): <br><!-- br --><br><!-- br -->[code]<font color="#000080">[a]</font> = <font color="#0000ff">'2'</font><br /><!-- br --><font color="#000080">[b]</font> = <font color="#0000ff">'5'</font><br /><!-- br --><font color="#000080">[result]</font> = <font color="#000080">[a]</font> + <font color="#000080">[b]</font><br /><!-- br -->echo <font color="#000080">[a]</font> # <font color="#0000ff">' + '</font> # <font color="#000080">[b]</font> # <font color="#0000ff">' results '</font> # <font color="#000080">[result]</font><br /><!-- br --><b>end</b>[/code]<!-- br --><br><!-- br -->Because calculations can be performed everywhere, the following scripts brings the same result<br><!-- br --><br><!-- br --><!-- br -->[code]<font color="#000080">[a]</font> = <font color="#0000ff">'2'</font><br /><!-- br --><font color="#000080">[b]</font> = <font color="#0000ff">'5'</font><br /><!-- br -->echo <font color="#000080">[a]</font> # <font color="#0000ff">' + '</font> # <font color="#000080">[b]</font> # <font color="#0000ff">' results '</font> # (<font color="#000080">[a]</font> + <font color="#000080">[b]</font>)<br /><!-- br --><b>end</b>[/code]<!-- br --><!-- br -->Here, we don't assign the result of the calculation to a variable first but we directly calculate it when we perform the output. Brackets (...) can be used within formulas and joins wherever wanted. RapidBATCH 5 is very flexible and versatile in performing calculations - It is also possible to calculate huge formulas in one single line.<br><!-- br --><br><!-- br -->[code]<font color="#000080">[a]</font> = <font color="#0000ff">'5'</font><br /><!-- br --><font color="#000080">[b]</font> = <font color="#0000ff">'12'</font><br /><!-- br -->echo <font color="#000080">[a]</font> * (<font color="#000080">[b]</font> + <font color="#0000ff">'4'</font> * (<font color="#000080">[a]</font> - <font color="#0000ff">'2'</font>)) / <font color="#000080">[b]</font><br /><!-- br --><b>end</b>[/code]<!-- br --><br><!-- br -->The above script will result the value 20 when it is executed!<br><!-- br --><br><!-- br --><!-- br -->Sometimes it is necessary to calculate a variable and assign this calculated value to the variable again. For such cases, RapidBATCH 5 provides a shortcut as used in the following assignment:<br><!-- br --><br><!-- br -->[code]<font color="#000080">[a]</font> + <font color="#0000ff">'5'</font>[/code]<!-- br --><br><!-- br -->the above line is equal to the following assignment:<br><!-- br --><br><!-- br -->[code]<font color="#000080">[a]</font> = <font color="#000080">[a]</font> + <font color="#0000ff">'5'</font>[/code]<!-- br --><br><!-- br -->The short assignments can be used with all RapidBATCH standard-operators (#,+,-,*,/,~).
rb5_en_basics_3.html§Manipulating variable data§Storing data into variables is the one thing variables are made for. The other one is to work with these variable data, to <i>manipulate</i> and <i>use</i> it. For this purpose, RapidBATCH provides so called build-in functions. &quot;Build-in&quot; means, that these functions are hard-coded into the RapidBATCH core language (the so called scripting engine), they belong to the RapidBATCH default command set it provides inherently. These build-in functions are also the base to create and design new functions for yourself that you can use within your scripts, but this topic is discussed later.<!-- br --><br><!-- br --><br><!-- br -->Functions always return a value, whereas normal instructions (e.g. the ECHO-instruction to show a messagebox dialog) do not return any value. There is also one difference to other programming languages in RapidBATCH when using functions: Functions are internally handled as instructions, so that means the return variable that receives the function's result is always specified behind the name of the functions that should be called, not in front of it as it is known from JavaScript or BASIC. Several parameter-values the function expects may follow then.<!-- br --><br><!-- br --><br><!-- br -->For a simple example of a string-manipulating function, take a look at the following script. It uses the UPVAR-function to convert all characters in the specified string variable to upper-case letters. That means, when we pass the value &quot;Hello&quot;, the RapidBATCH script will return the text in upper-case order: &quot;HELLO&quot;.<!-- br --><br><!-- br --><br><!-- br -->[code]<!-- br --><font color="#808080">rem Prompt for any value</font><br /><!-- br -->inputbox <font color="#000080">[text]</font> = <font color="#0000ff">'Text Input'</font>, <font color="#0000ff">'Please enter a short text:'</font>, <font color="#0000ff">''</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem Convert the value to upper-case letters</font><br /><!-- br -->upvar <font color="#000080">[text_in_uppercase]</font> = <font color="#000080">[text]</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem Output the converted value</font><br /><!-- br -->echo <font color="#0000ff">'Your value in capital letters: '</font> # <font color="#000080">[text_in_uppercase]</font><br /><!-- br --><b>end</b><!-- br -->[/code]<!-- br --><br><!-- br --><!-- br -->Functions normally expect a minimum of one parameter value, in this case it is the value that should be converted to upper-case letters. If a function expects more than one parameter, each parameter is separated by commas (,). Later, when you implement your own functions to your scripts, you can also create parameter-less functions.<br><!-- br --><br><!-- br -->The above example is only a short demonstration how functions are used. RapidBATCH provides more than 10 of such build-in functions to manipulate values: UPVAR, LOWVAR, TRIMVAR, GETCHR, GETASC, COPYVAR, GETCHARAT, GETTOK, GETPOS, REPLACEVAR, CNTVAR and RANDVAR. Also, some deprecated, but still supported functions from former RapidBATCH versions are available. You can identify build-in functions on their name, because every build-in function either begins with a &quot;Get&quot; or ends with a &quot;Var&quot; in its name. This is not a direct standard (you can name your own functions later whatever you want!), but it's a naming convention for build-in functions in RapidBATCH since version 1.0.<!-- br --><br><!-- br --><br><!-- br -->Also, RapidBATCH provides functions that don't manipulate values (but return a value!), e.g. the INPUTBOX-function that displays a prompting dialog and returns the value the user entered into the text field. The best definition for a function (build-in or not build-in) is: An instruction that returns a value to a variable!
rb5_en_basics_4.html§Conditional programming§Now that you have gotten to know the great features of flexible programming using variables, this chapter will discuss how to handle conditions, that means how you can operate on this variable data in your scripts using conditions and loops.<br><br><!-- br -->Let's begin with a simple script that asks for a password until the right password is entered. In this case, we use the instructions REPEAT and UNTIL to construct a loop, that repeats the PWDBOX-function (providing a hidden INPUTBOX-likely dialog to enter passwords) until the given password verification condition results true.<!-- br --><br><!-- br --><br><!-- br --><!-- br -->[code]<!-- br --><font color="#808080">rem Ask for the password until the user enters 'hello'</font><br /><!-- br --><b>repeat</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;pwdbox <font color="#000080">[password]</font> = <font color="#0000ff">'Login'</font>, <font color="#0000ff">'Please enter the password:'</font>, <font color="#0000ff">''</font><br /><!-- br --><b>until</b> <font color="#000080">[password]</font> = <font color="#0000ff">'hello'</font><br /><!-- br --><br /><!-- br -->echo <font color="#0000ff">'This password was right!'</font><br /><!-- br --><b>end</b><!-- br -->[/code]<!-- br --><!-- br --><!-- br -->When you run the script, you can see that the INPUTBOX always appears again until you enter the right password (&quot;hello&quot;). For this condition, we use the equal operator to verify the two values (which are the content of the variable [password] and the constant value 'hello') if they are equal. Possible operators are the equal-operator (=), the not-equal operator (!), the greater-than operator (&gt;), the lower-than operator (&lt;) and the greater-equal (&gt;=) and lower-equal (&lt;=) operators.<br><!-- br -->I advise insetting all the code between REPEAT and UNTIL using tabs or spaces. This contributes to a better code readability and makes it easier to find program errors (so called &quot;bugs&quot;) in huger scripts, because you're getting an overview of the script's structure much faster.<br><!-- br --><br><!-- br -->But loops are not the only possibility in the conditional programming of RapidBATCH. The other, and more frequently used possibility is the IF instruction. This can be used with the instructions ELSEIF, ELSE and ENDIF in various, very complex constructions and algorithms.<br><!-- br -->The following examples demonstrate how these instructions can be used.<br><!-- br --><br><!-- br -->A simple IF instruction would be<br><!-- br --><br><!-- br --><!-- br -->[code]<b>if</b> <font color="#000080">[input]</font> = <font color="#0000ff">'hello'</font> echo <font color="#0000ff">'The prompted word was successfully verified to "hello"'</font>[/code]<!-- br --><!-- br -->In this case, the instruction (or function), that should be executed when the condition succeeds, is directly written behind the condition. To execute more than one instructions to one IF condition, you need to construct a so called &quot;IF block&quot;. It begins with an IF and the condition, then the code that should be executed when the condition succeeds and finally a closing ENDIF instruction at the bottom that marks the end of this IF block.<!-- br --><br><!-- br --><br><!-- br --><!-- br -->[code]<!-- br --><b>if</b> <font color="#000080">[input]</font> = <font color="#0000ff">'hello'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'The prompted word was sucessfully verified to "hello"'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[x]</font> + <font color="#0000ff">'2'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[x]</font> &gt; <font color="#0000ff">'32'</font> <b>halt</b><br /><!-- br --><b>endif</b><!-- br -->[/code]<!-- br --><!-- br -->The line break behind the condition instructs the interpreter (or compiler), that the following lines belong to this instruction as an IF block, until the next ELSEIF, ELSE or ENDIF instruction.<br><!-- br -->To perform more than one verification in one IF block, use the ELSEIF instruction to verify another condition if the first condition fails:<!-- br --><br><!-- br --><br><!-- br --><!-- br -->[code]<!-- br --><b>if</b> <font color="#000080">[input]</font> = <font color="#0000ff">'hello'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'The prompted word was sucessfully verified to "hello"'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[x]</font> + <font color="#0000ff">'2'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[x]</font> &gt; <font color="#0000ff">'32'</font> <b>halt</b><br /><!-- br --><b>elseif</b> <font color="#000080">[input]</font> = <font color="#0000ff">'bye'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Goodbye!'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>halt</b><br /><!-- br --><b>endif</b><!-- br -->[/code]<!-- br --><!-- br -->If none of the conditions succeed, if all IF/ELSEIF conditions fail, you can add an ELSE block that is executed in this case.<!-- br --><!-- br -->[code]<!-- br --><b>if</b> <font color="#000080">[input]</font> = <font color="#0000ff">'hello'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'The prompted word was sucessfully verified to "hello"'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[x]</font> + <font color="#0000ff">'2'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[x]</font> &gt; <font color="#0000ff">'32'</font> <b>halt</b><br /><!-- br --><b>elseif</b> <font color="#000080">[input]</font> = <font color="#0000ff">'bye'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Goodbye!'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>halt</b><br /><!-- br --><b>else</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'ERROR: Submission undefined.'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>goto</b> restart<br /><!-- br --><b>endif</b><!-- br -->[/code]<!-- br --><!-- br -->ELSE blocks are only allowed behind all ELSEIF blocks.<br><!-- br --><!-- br -->Sometimes it is necessary to perform more than one verifications within a REPEAT...UNTIL or IF/ELSEIF condition. For such cases, RapidBATCH provides so called logical condition operators, the AND-operator (&amp;) and the OR-operator (|). These operators are used to join two or more different verifications logically together, so that the whole condition is only true when all parts of it, based on the way they are joined, result true.<br><!-- br --><br><!-- br -->When two conditions are joined with the OR-operator, only one of both verifications needs to be true. The following IF condition is executed when the prompted name is &quot;Peter&quot; or &quot;Maik&quot;.<br><!-- br --><br><!-- br --><!-- br -->[code]<!-- br -->inputbox <font color="#000080">[name]</font> = <font color="#0000ff">'Name?'</font>, <font color="#0000ff">'What is your name?'</font>, <font color="#0000ff">''</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem is the name Peter or Maik?</font><br /><!-- br --><b>if</b> <font color="#000080">[name]</font> = <font color="#0000ff">'Peter'</font> | <font color="#000080">[name]</font> = <font color="#0000ff">'Maik'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Welcome '</font> # <font color="#000080">[name]</font><br /><!-- br --><b>else</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'You are not Peter or Maik!'</font><br /><!-- br --><b>endif</b><br /><!-- br --><b>end</b><!-- br -->[/code]<!-- br --><!-- br -->When joining two conditions using the AND-operator, both verifycations need to be true, else the condition is not fulfilled. The following script displays an error message when the users leaves both values blank.<br><!-- br --><br><!-- br --><!-- br -->[code]<!-- br -->inputbox <font color="#000080">[name]</font> = <font color="#0000ff">'Surname?'</font>, <font color="#0000ff">'What is your family name?'</font>, <font color="#0000ff">''</font><br /><!-- br -->inputbox <font color="#000080">[fname]</font> = <font color="#0000ff">'First Name?'</font>, <font color="#0000ff">'And what is your first name?'</font>, <font color="#0000ff">''</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem are name and first name both not empty?</font><br /><!-- br --><b>if</b> <font color="#000080">[name]</font> ! <font color="#0000ff">''</font> & <font color="#000080">[fname]</font> ! <font color="#0000ff">''</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Hello '</font> # <font color="#000080">[fname]</font> # <font color="#0000ff">' '</font> # <font color="#000080">[name]</font><br /><!-- br --><b>else</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'You have to enter both values!'</font><br /><!-- br --><b>endif</b><br /><!-- br --><b>end</b><!-- br -->[/code]
rb5_en_basics_5.html§Labels and Subs§A proven appliance to construct a structured program flow is to jump to so called code-labels and sub-routines, the so called &quot;subs&quot;. Indeed, writing own procedures and creating loop-structures using REPEAT...UNTIL statements is the more professional way, so that this possibility is only discussed briefly.<br><br><!-- br --><!-- br -->To work with labels and subs, RapidBATCH provides the instructions GOTO, GOSUB and RESUME. GOTO allows you to &quot;jump&quot; ahead and back trough the script code to a defined label, where the program execution is continued. Many programmers hate this possibility in various programming languages because it makes the code too complex and difficult to read. Anyway, in some cases, labels and GOTOs are really essential.<br><!-- br --><br><!-- br -->The easiest example is the following script. We have three ECHO instructions, but only the first and the last one will appear. The second one will never be reached, because the script jumps behind the first ECHO instruction to the label %the_end in front of the last ECHO instruction. Labels are marked with a beginning percent-character (%) and can have any name. The percent is only assigned to the label to mark it in the code, if you specify a label at a GOTO or GOSUB instruction, you do not include the percent character.<!-- br --><!-- br --><br><br><!-- br --><!-- br -->[code]echo <font color="#0000ff">'This is ECHO-instruction 1'</font><br /><!-- br --><b>goto</b> <font color="#0000ff">'the_end'</font><br /><!-- br -->echo <font color="#0000ff">'This is ECHO-instruction 2'</font><br /><!-- br -->%the_end<br /><!-- br -->echo <font color="#0000ff">'This is ECHO-instruction 3'</font><br /><!-- br --><b>end</b>[/code]<!-- br --><br><!-- br --><!-- br -->Since version 4.0, RapidBATCH also provides the ability of creating simple sub-routines, the so called subs. These are no real procedures like those we will discuss later, but code-blocks that you can jump to from anywhere in the script and which automatically continue using the RESUME instruction as the last code line of the sub. The script execution then continues behind the last call of GOSUB.<br><br><!-- br -->The following example squares all numbers from 1 to 10 by calling the sub %square with each loop. You will see, when the sub is executed, the RESUME instruction lets the script continue from where the sub was called, so that the counter is incremented (increased by one) and the next call can be done.<br><!-- br --><!-- br -->You can also perform recoursive calls, that means you jump into a sub and call this sub again within itself until a certain recoursion deepness.<br><!-- br --><!-- br --><br><!-- br -->[code]<font color="#000080">[i]</font> = <font color="#0000ff">'1'</font><br /><!-- br --><b>repeat</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>gosub</b> <font color="#0000ff">'square'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> + <font color="#0000ff">'1'</font><br /><!-- br --><b>until</b> <font color="#000080">[i]</font> &gt; <font color="#0000ff">'10'</font><br /><!-- br --><b>halt</b><br /><!-- br --><br /><!-- br --><font color="#808080">rem Sub: square</font><br /><!-- br -->%square<br /><!-- br --><font color="#000080">[x]</font> = <font color="#000080">[i]</font> * <font color="#000080">[i]</font><br /><!-- br -->echo <font color="#000080">[i]</font> # <font color="#0000ff">' * '</font> # <font color="#000080">[i]</font> # <font color="#0000ff">' = '</font> # <font color="#000080">[x]</font><br /><!-- br --><b>resume</b><br /><!-- br --><b>end</b>[/code]<!-- br --><br><!-- br --><br><!-- br --><!-- br -->Since RapidBATCH 5.0, it is also possible to perform dynamic label calls via GOTO and GOSUB. This means that the target-label that is called by GOTO or GOSUB can be based on variable data, so a variable can be passed to GOTO or GOSUB statements to jump to a label dynamically.<!-- br --><br><!-- br --><br><!-- br -->An example for a dynamic label call:<br><!-- br --><br><!-- br -->[code]confirm <font color="#000080">[answer]</font> = <font color="#0000ff">'Yes or No?'</font><br /><!-- br --><b>goto</b> <font color="#000080">[answer]</font><br /><!-- br --><br /><!-- br -->%0<br /><!-- br -->echo <font color="#0000ff">'You hit YES!'</font><br /><!-- br --><b>halt</b><br /><!-- br --><br /><!-- br -->%-1<br /><!-- br -->echo <font color="#0000ff">'You hit NO!'</font><br /><!-- br --><b>end</b>[/code]<!-- br --><br><!-- br -->These dynamic calls will be useful for event handling later, when we create dialog-based applications.<br><!-- br --><br><!-- br --><!-- br -->But label calls and sub-routines, as already mentioned, should only be used if it's really mandatory. In RapidBATCH 5 it is more recommended to implement and use own, user defined procedures and functions, which are offering more powerful possibilities than labels and sub-routines.
rb5_en_basics_6.html§Arrays§Let's talk about one of the most powerful innovations coming along with RapidBATCH 5: Arrays!<!-- br --><br><!-- br --><br><!-- br --><!-- br -->An array is a group of variables which are stored to one shared variable-name. On the one hand, arrays are used to access and store a huge amount of variables quickly, on the other hand, arrays make it possible to access variable data directly by specifying an indexing counter value.<br><!-- br -->In general, arrays provide the possibility to store nearly unlimited values in even multi-nested dimensions, using one single variable name. An array can be imagined as a table in the memory, where each line contains a value that can be accessed by the mentioned index counter.<br><br><!-- br -->Many programming languages are providing both static and dynamic arrays. Static arrays are once defined and can only store the amount of values that has been specified. Dynamic arrays can contain a variable amount of values, that means the necessary memory for the dynamic array is completely reserved (and changed) at run-time. RapidBATCH uses only the second, even more powerful and flexible method: completely dynamic arrays. The script-programmer doesn't have to deal with the internal memory management of the array he uses - RapidBATCH handles the memory reservation and dimensioning of its arrays completely auotmated.<br><!-- br --><br><!-- br --><!-- br -->A simple demonstration for the usage of an array is the following script. It stores 10 different names in one array that is declared as [names]. In the loop below, each row of the array is read out and shown in a messagebox.<!-- br --><!-- br --><br><br><!-- br -->[code]<font color="#808080">rem declare and fill an array of 10 elements</font><br /><!-- br --><b>dec</b> <font color="#000080">[names:'10']</font><br /><!-- br --><font color="#000080">[names:'1']</font> = <font color="#0000ff">'Neo'</font><br /><!-- br --><font color="#000080">[names:'2']</font> = <font color="#0000ff">'Trinity'</font><br /><!-- br --><font color="#000080">[names:'3']</font> = <font color="#0000ff">'Morpheus'</font><br /><!-- br --><font color="#000080">[names:'4']</font> = <font color="#0000ff">'Roy'</font><br /><!-- br --><font color="#000080">[names:'5']</font> = <font color="#0000ff">'Earl'</font><br /><!-- br --><font color="#000080">[names:'6']</font> = <font color="#0000ff">'Dagobert'</font><br /><!-- br --><font color="#000080">[names:'7']</font> = <font color="#0000ff">'Michael'</font><br /><!-- br --><font color="#000080">[names:'8']</font> = <font color="#0000ff">'Marty'</font><br /><!-- br --><font color="#000080">[names:'9']</font> = <font color="#0000ff">'Doc Brown'</font><br /><!-- br --><font color="#000080">[names:'10']</font> = <font color="#0000ff">'Einstein'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem step through each array element and display it</font><br /><!-- br --><font color="#000080">[index]</font> = <font color="#0000ff">'0'</font><br /><!-- br --><b>repeat</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[index]</font> + <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Name at position '</font> # <font color="#000080">[index]</font> # <font color="#0000ff">' is: '</font> # <font color="#000080">[names:[index]]</font><br /><!-- br --><b>until</b> <font color="#000080">[index]</font> = <font color="#0000ff">'10'</font><br /><!-- br --><b>end</b>[/code]<!-- br --><!-- br --><br><!-- br --><br><!-- br -->The next table visualizes how RapidBATCH stores the data of the array that is filled up in the above script.<!-- br --><!-- br --><br><br><!-- br --><table class="std" width="200" style="margin-left: 20px;"><!-- br -->	<tr><!-- br -->		<td><b>Index:</b></td><!-- br -->		<td><b>Value:</b></td><!-- br -->	</tr><!-- br -->	<tr><!-- br -->		<td>1</td><!-- br -->		<td>Neo</td><!-- br -->	</tr><!-- br -->	<tr><!-- br -->		<td>2</td><!-- br -->		<td>Trinity</td><!-- br -->	</tr><!-- br -->	<tr><!-- br -->		<td>3</td><!-- br -->		<td>Morpheus</td><!-- br -->	</tr><!-- br -->	<tr><!-- br -->		<td>4</td><!-- br -->		<td>Roy</td><!-- br -->	</tr><!-- br -->	<tr><!-- br -->		<td>5</td><!-- br -->		<td>Earl</td><!-- br -->	</tr><!-- br -->	<tr><!-- br -->		<td>6</td><!-- br -->		<td>Dagobert</td><!-- br -->	</tr><!-- br -->	<tr><!-- br -->		<td>7</td><!-- br -->		<td>Michael</td><!-- br -->	</tr><!-- br -->	<tr><!-- br -->		<td>8</td><!-- br -->		<td>Marty</td><!-- br -->	</tr><!-- br -->	<tr><!-- br -->		<td>9</td><!-- br -->		<td>Doc Brown</td><!-- br -->	</tr><!-- br -->	<tr><!-- br -->		<td>10</td><!-- br -->		<td>Einstein</td><!-- br -->	</tr><!-- br --></table><!-- br --><!-- br --><br><!-- br -->Arrays can be defined, dimensioned and re-dimensioned using different ways. A simple array featuring for the time a number of 10 elements as used above can be pre-declared using the DEC-instruction: <!-- br --><!-- br --><br><!-- br --><br><!-- br -->[code]<b>dec</b> <font color="#000080">[myArray:'10']</font>[/code]<!-- br --><br><!-- br --><!-- br -->In RapidBATCH, it is really a damn how the index value (in this case the constant value '10') is specified. It can be passed using the following ways:<!-- br --><br><!-- br --><br><!-- br -->[code]<b>dec</b> <font color="#000080">[myArray'10']</font><br /><!-- br --><b>dec</b> <font color="#000080">[myArray '10']</font><br /><!-- br --><b>dec</b> <font color="#000080">['10'myArray]</font><br /><!-- br --><b>dec</b> <font color="#000080">[my'10'Array]</font>[/code]<!-- br --><br><!-- br --><!-- br -->Even the last line, that really looks very strange is a valid index value, and the array is declared as [myArray].<br><br><!-- br -->As a matter of course, it is also possible to use a variable as an index counter to an array:<br><!-- br --><br><!-- br -->[code]<font color="#000080">[index]</font> = <font color="#0000ff">'10'</font><br /><!-- br --><b>dec</b> <font color="#000080">[myArray:[index]]</font><br /><!-- br --><b>dec</b> <font color="#000080">[myArray[index]]</font><br /><!-- br --><b>dec</b> <font color="#000080">[my[index]Array]</font>[/code]<!-- br --><!-- br -->Colons, comas and blanks are simply ignored in the variable name, that means they are not urgently expected.<!-- br --><!-- br --><br><!-- br --><br><!-- br -->Arrays are also declared automatically if a value is passed to any dimension that does not exist. This does also mean, that any ordinary variable which is available and used in RapidBATCH can be transformed into an array just by performing one assignment to an unexisting array index. The following script creates an array with three elements without a prior declaration. The elements are shown in reverse order.<!-- br --><br><!-- br --><br><!-- br -->[code]<font color="#808080">rem fill up an array dynamically with three elements</font><br /><!-- br --><font color="#000080">[myArray:'1']</font> = <font color="#0000ff">'This is the first entry.'</font><br /><!-- br --><font color="#000080">[myArray:'2']</font> = <font color="#0000ff">'This is the second entry.'</font><br /><!-- br --><font color="#000080">[myArray:'3']</font> = <font color="#0000ff">'Finally, this is the third entry.'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem output the array in reverse order</font><br /><!-- br --><font color="#000080">[i]</font> = <font color="#0000ff">'3'</font><br /><!-- br --><b>repeat</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#000080">[myArray:[i]]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> - <font color="#0000ff">'1'</font><br /><!-- br --><b>until</b> <font color="#000080">[i]</font> = <font color="#0000ff">'0'</font><br /><!-- br --><b>end</b>[/code]<!-- br --><br><!-- br --><!-- br --><br><!-- br --><br><!-- br --><!-- br -->To receive the number of elements within one dimension of an array, the element index '0' can be used. It returns the amount of entries within the given array dimension.<br><!-- br --><br><!-- br -->[code]<font color="#000080">[myArray:'1']</font> = <font color="#0000ff">'This is the first entry.'</font><br /><!-- br --><font color="#000080">[myArray:'2']</font> = <font color="#0000ff">'This is the second entry.'</font><br /><!-- br --><font color="#000080">[myArray:'3']</font> = <font color="#0000ff">'Finally, this is the third entry.'</font><br /><!-- br --><br /><!-- br -->echo <font color="#0000ff">'The array contains currently '</font> # <font color="#000080">[myArray:'0']</font> # <font color="#0000ff">' entries.'</font><br /><!-- br --><br /><!-- br --><font color="#000080">[i]</font> = <font color="#0000ff">'0'</font><br /><!-- br --><b>repeat</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> + <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Entry No. '</font> # <font color="#000080">[i]</font> # <font color="#0000ff">': '</font> # <font color="#000080">[myArray:[i]]</font><br /><!-- br --><b>until</b> <font color="#000080">[i]</font> = <font color="#000080">[myArray:'0']</font><br /><!-- br --><b>end</b>[/code]<!-- br --><br><!-- br --><br><!-- br --><!-- br --><!-- br -->As already mentioned above, arrays can feature different, nested dimensions. One dimension can be described as a sub-array in an array element, that means one array element has again one array it is associated with. An element of this second dimension can also contain another array-dimension. This can be done up to 9 different array dimensions, an immensely huge capacity that, if possible, never will be utilized.<br><br><!-- br --><!-- br -->A multi-dimensional array is declared the same way as an &quot;ordinary&quot; array (whereas single-dimensional and multi-dimensional arrays are the same ;)) just by assigning a value to an inexistent dimension or by pre-declaring the array using the DEC statement - RapidBATCH handles the internal memory management completely itself.<br><!-- br --><br><!-- br -->An example (whereas the use of the DEC statement is even optionally!):<br><!-- br --><!-- br --><br><!-- br -->[code]<font color="#808080">rem declaring an array with 10x10x10 dimensions</font><br /><!-- br --><b>dec</b> <font color="#000080">[myArray:'10','10','10']</font><br /><!-- br --><font color="#000080">[myArray:'1','1','1']</font> = <font color="#0000ff">'Hello World'</font><br /><!-- br --><font color="#000080">[myArray:'1','1','2']</font> = <font color="#0000ff">'Arrays are very easy'</font><br /><!-- br --><font color="#000080">[myArray:'1','1','3']</font> = <font color="#0000ff">'to use and handle with'</font><br /><!-- br --><font color="#000080">[myArray:'1','2','1']</font> = <font color="#0000ff">'We currently '</font><br /><!-- br --><font color="#000080">[myArray:'1','2','2']</font> = <font color="#0000ff">'save values in'</font><br /><!-- br --><font color="#000080">[myArray:'1','2','3']</font> = <font color="#0000ff">'different dimensions!'</font>[/code]<!-- br --><br><!-- br --><!-- br -->At this point, RapidBATCH does also provide a special feature, that is never known from a programming language so far: Values can be saved into ANY dimension of an array at the same time! That means, you can save and access a value to [myArray:'1'] and also a completely different value to [myArray:'1','1'].<!-- br --><!-- br --><br><br><!-- br --><!-- br -->A concretely example:<br><!-- br --><br><!-- br -->[code]<!-- br --><font color="#808080">rem filling data to the array into different dimensions</font><br /><!-- br --><font color="#000080">[meinArray]</font> = <font color="#0000ff">'Basis'</font><br /><!-- br --><font color="#000080">[meinArray:'1']</font> = <font color="#0000ff">'First dimension, value 1'</font><br /><!-- br --><font color="#000080">[meinArray:'1','1']</font> = <font color="#0000ff">'Second dimension, value 1'</font><br /><!-- br --><font color="#000080">[meinArray:'1','1','1']</font> = <font color="#0000ff">'Third dimension, value 1'</font><br /><!-- br --><font color="#000080">[meinArray:'1','1','2']</font> = <font color="#0000ff">'Third dimension, value 2'</font><br /><!-- br --><font color="#000080">[meinArray:'1','2']</font> = <font color="#0000ff">'Second dimension, value 2'</font><br /><!-- br --><font color="#000080">[meinArray:'2']</font> = <font color="#0000ff">'First dimension, value 2'</font><!-- br -->[/code]<!-- br --><br><!-- br --><br><!-- br --><!-- br -->Especially to re-use and clean-up arrays, the RESET statement has been implemented to RapidBATCH. RESET cleans up a complete array and every dimension of it, so the array can be used again for other purposes or another run to fill it with data. E.g., this is very useful when a script maps files into an array within a REPEAT...UNTIL-loop. For each file, the array needs to be resetted using RESET and can be used again to map the next file.<br><!-- br -->RESET cleans a single variable (here, an empty string is assigned), a complete array including all dimensions, a single dimension of an array or even one single element, if it does not contain any sub-dimensions.<!-- br --><br><!-- br --><br><!-- br -->A simple example that is demonstrating the usage of RESET:<br><!-- br --><br><!-- br -->[code]<font color="#808080">rem fill an array with data</font><br /><!-- br --><font color="#000080">[myArray:'1']</font> = <font color="#0000ff">'This is the first entry.'</font><br /><!-- br --><font color="#000080">[myArray:'2']</font> = <font color="#0000ff">'This is the second entry.'</font><br /><!-- br --><font color="#000080">[myArray:'3']</font> = <font color="#0000ff">'Finally, this is the third entry.'</font><br /><!-- br -->echo <font color="#0000ff">'The array does currently contain '</font> # <font color="#000080">[myArray:'0']</font> # <font color="#0000ff">' elements'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem reset the array</font><br /><!-- br --><b>reset</b> <font color="#000080">[myArray]</font><br /><!-- br -->echo <font color="#0000ff">'The array does currently contain '</font> # <font color="#000080">[myArray:'0']</font> # <font color="#0000ff">' elements'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem refill the array again</font><br /><!-- br --><font color="#000080">[myArray:'1']</font> = <font color="#0000ff">'New content...'</font><br /><!-- br --><font color="#000080">[myArray:'2']</font> = <font color="#0000ff">'...and a second one ;)'</font><br /><!-- br -->echo <font color="#0000ff">'The array does currently contain '</font> # <font color="#000080">[myArray:'0']</font> # <font color="#0000ff">' elements'</font><br /><!-- br --><b>end</b><!-- br -->[/code]<!-- br --><!-- br --><br><!-- br -->The advantages arrays provide are very versatile, especially their flexible dynamic, that is not featured by other programming- and scripting languages in this scale as it is the case in RapidBATCH 5 so far.
