template.html§0TITLE§1CONTENT
rb5_ger_procedural_1.html§Benutzerdefinierte Prozeduren und Funktionen§Eines der effektivsten, neuen Features von RapidBATCH 5 ist die Einführung von benutzerdefinierbaren Prozeduren und Funktionen, ein Feature, das für die moderne, strukturierte Programmierung einfach unerlässlich ist. Mit Prozeduren können Sie die Programmierung Ihrer Scripts erheblich beschleunigen, indem Sie neue Befehle und Funktionen, die genau für Ihre Anwendungen zugeschnitten sind, einfach selbst in RapidBATCH als kleine Unterprogramme implementieren. Eine Prozedur lässt sich also quasi als eine Zusammenfassung von mehreren RapidBATCH-Anweisungen und -Kontrollstrukturen zu einer komplett neuen Anweisung (oder Funktion), die dann in RapidBATCH verwendet werden kann, beschreiben.<br><!-- br --><br><!-- br -->Prozeduren werden einmal in einem Script definiert und können anschließend wie ganz normale Anweisungen oder Funktionen gehandhabt werden. Es ist daher sinnvoll, Prozedurdefinitionen immer zu Anfang eines RapidBATCH-Scripts anzugeben. Werden die gleichen Prozeduren in mehreren, unterschiedlichen Scripts verwendet, so können diese in einer separaten Script-Datei als Library-Datei definiert und später zur Verwendung im eigentlichen Script mittels der INCLUDE-Anweisung eingebunden werden (mehr zu diesem Verfahren jedoch später!).<br><!-- br --><br><!-- br --><!-- br -->Eine einfache Prozedur (ohne Rückgabewert) wird mit dem Schlüsselwort PROC eingeleitet. Direkt nach PROC folgt der Name, über den die neue Prozedur aufgerufen werden soll. Dieser darf keine Leer- oder Sonderzeichen enthalten. Nach dem Prozedurnamen kann dann, gefolgt von einem Doppelpunkt, eine Liste an Parametervariablen (die pro Variable durch Kommata getrennt sein müssen) angegeben werden, wobei auch eine parameterlose Prozedur definiert werden kann (in solch einem Fall ist kein Doppelpunkt erforderlich!). Nach der PROC-Anweisung folgt dann der entsprechende Code, den die Prozedur enthält. Ausgeleitet wird dieser Code mit der Anweisung ENDPROC. Hinter ENDPROC kann dann eine neue Prozedurdefinition oder normaler Script-Code folgen. Auch hier gilt: Zwischen den Anweisungen PROC und ENDPROC sollte der Script-Code zur besseren Lesbarkeit eingerückt werden!<br><!-- br --><br><!-- br --><!-- br -->Ein einfaches Beispiel stellt nun folgendes Script dar. Es definiert eine parameterlose Prozedur &quot;test&quot;, welche ein Meldungsfenster ausgeben soll.<br><br><!-- br --><!-- br -->[code]<font color="#808080">rem Prozedur-Demoscript</font><br /><!-- br --><b>proc</b> test<br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Dies ist die Prozedur TEST!'</font><br /><!-- br --><b>endproc</b><br /><!-- br --><br /><!-- br -->echo <font color="#0000ff">'Vor der Prozedur...'</font><br /><!-- br -->test<br /><!-- br -->echo <font color="#0000ff">'...nach der Prozedur'</font><br /><!-- br -->echo <font color="#0000ff">'Und noch einmal!'</font><br /><!-- br -->test<br /><!-- br --><b>end</b>[/code]<!-- br --><!-- br -->Wenn wir nun eine Prozedur mit Parametervariablen definieren wollen, müssen diese, wie bereits oben beschrieben, als Parameterliste beim Schlüsselwort PROC angegeben werden. Die dort definierten Variablennamen werden beim Aufruf der Prozedur deklariert und bei der Beendigung der Prozedur wieder aus dem Speicher entfernt. Dies nennt man &quot;lokale Variablendeklaration&quot;, da diese Variablen (und auch alle Variablen, die in der Prozedur erzeugt werden) nur zur Laufzeit der Prozedur verwendet werden können. Wir werden später noch genauer auf den Unterschied zwischen lokalen und globalen Variablen eingehen.<br><br><!-- br --><!-- br -->Ein einfaches Beispiel für eine Prozedur mit Parametern stellt folgendes Script dar. Es definiert die Prozedur &quot;summe&quot; zur Summierung zweier Werte, die als Parameter übergeben werden. Das Ergebnis der Addition wird als Text in einem Meldungsfenster ausgegeben.<br><br><!-- br --><!-- br -->[code]<font color="#808080">rem Prozedur-Demoscript mit Parametern</font><br /><!-- br --><b>proc</b> summe: <font color="#000080">[wert1]</font>, <font color="#000080">[wert2]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>dec</b> <font color="#000080">[ergebnis]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[ergebnis]</font> = <font color="#000080">[wert1]</font> + <font color="#000080">[wert2]</font><br /><!-- br --><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Die Summe von '</font> # <font color="#000080">[wert1]</font> # <font color="#0000ff">' und '</font> # <font color="#000080">[wert2]</font> # <font color="#0000ff">' ist '</font> # <font color="#000080">[ergebnis]</font><br /><!-- br --><b>endproc</b><br /><!-- br --><br /><!-- br --><font color="#808080">rem Konstante Parameterwerte</font><br /><!-- br -->summe <font color="#0000ff">'7'</font>, <font color="#0000ff">'13'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem Variable Parameterwerte</font><br /><!-- br -->inputbox <font color="#000080">[a]</font> = <font color="#0000ff">'Wert A:'</font>, <font color="#0000ff">'Bitte geben Sie eine Zahl ein:'</font>, <font color="#0000ff">''</font><br /><!-- br --><b>if</b> <font color="#000080">[a]</font> = <font color="#0000ff">''</font> <b>halt</b><br /><!-- br -->inputbox <font color="#000080">[b]</font> = <font color="#0000ff">'Wert B:'</font>, <font color="#0000ff">'Bitte geben Sie eine Zahl ein:'</font>, <font color="#0000ff">''</font><br /><!-- br --><b>if</b> <font color="#000080">[b]</font> = <font color="#0000ff">''</font> <b>halt</b><br /><!-- br --><br /><!-- br -->summe <font color="#000080">[a]</font>, <font color="#000080">[b]</font><br /><!-- br --><b>end</b>[/code]<!-- br --><!-- br --><br><br><!-- br --><!-- br -->Aus dieser Prozedur lässt sich jetzt auch eine Funktion definieren, die als Rückgabewert die Summe beider Parameter zurückgibt. Funktionen sind dabei nicht weniger schwer programmierbar wie einfache Prozeduren, nur dass wir hier anstatt der Schlüsselwörter PROC und ENDPROC die Schlüsselwörter FUNC und ENDFUNC verwenden. Um den Wert an die Ergebnisvariable, die beim Prozeduraufruf mit angegeben werden muss, zurückzugeben, verwenden wir hier ausserdem die Anweisung RET, was soviel bedeutet wie &quot;return&quot; (zu deutsch: &quot;Zurückkehren&quot;). RET kann auch, ohne Rückgabewert als Parameter, in einfachen Prozeduren eingesetzt werden, um diese vorzeitig vor dem ENDPROC zu verlassen.<br><!-- br --><br><!-- br -->Hier nun unser obiges Script mit einer Funktion &quot;summe&quot;.<br><!-- br --><br><!-- br --><!-- br -->[code]<font color="#808080">rem Funktions-Demoscript</font><br /><!-- br --><b>func</b> summe: <font color="#000080">[wert1]</font>, <font color="#000080">[wert2]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>dec</b> <font color="#000080">[ergebnis]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[ergebnis]</font> = <font color="#000080">[wert1]</font> + <font color="#000080">[wert2]</font><br /><!-- br --><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>ret</b> <font color="#000080">[ergebnis]</font><br /><!-- br --><b>endfunc</b><br /><!-- br --><br /><!-- br --><font color="#808080">rem Konstante Parameterwerte</font><br /><!-- br -->summe <font color="#000080">[erg]</font> = <font color="#0000ff">'7'</font>, <font color="#0000ff">'13'</font><br /><!-- br -->echo <font color="#0000ff">'Summe: '</font> # <font color="#000080">[erg]</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem Variable Parameterwerte</font><br /><!-- br -->inputbox <font color="#000080">[a]</font> = <font color="#0000ff">'Wert A:'</font>, <font color="#0000ff">'Bitte geben Sie eine Zahl ein:'</font>, <font color="#0000ff">''</font><br /><!-- br --><b>if</b> <font color="#000080">[a]</font> = <font color="#0000ff">''</font> <b>halt</b><br /><!-- br -->inputbox <font color="#000080">[b]</font> = <font color="#0000ff">'Wert B:'</font>, <font color="#0000ff">'Bitte geben Sie eine Zahl ein:'</font>, <font color="#0000ff">''</font><br /><!-- br --><b>if</b> <font color="#000080">[b]</font> = <font color="#0000ff">''</font> <b>halt</b><br /><!-- br --><br /><!-- br -->summe <font color="#000080">[erg]</font> = <font color="#000080">[a]</font>, <font color="#000080">[b]</font><br /><!-- br -->echo <font color="#0000ff">'Summe: '</font> # <font color="#000080">[erg]</font><br /><!-- br --><b>end</b>[/code]<!-- br --><br><!-- br --><!-- br -->Und schon haben Sie Ihre erste, eigene Funktion in RapidBATCH programmiert! Natürlich ist dies nur ein einfaches Beispiel, denn normalerweise addiert mein zwei Werte direkt im String, also <br><!-- br --><br><!-- br -->[code]echo <font color="#0000ff">'Summe: '</font> # <font color="#0000ff">'32'</font> + <font color="#0000ff">'5'</font><br /><!-- br --><b>end</b>[/code]<!-- br --><br><!-- br --><!-- br -->Als einfaches Modell für die Programmierung von Prozeduren und Funktionen war dieses Beispiel aber doch recht leicht verständlich. Interessant wird es erst, wenn wir rekursive Prozeduren schreiben oder mit Arrays arbeiten, was in den nächsten Kapiteln folgt.<br><!-- br --><br><!-- br --><!-- br -->Eine Sache, die an dieser Stelle aber noch sehr wichtig ist, sind die bereits angesprochenen lokalen Variablen. Man unterscheidet bei der prozeduralen Programmierung immer zwischen globalen und lokalen Variablen. In RapidBATCH sind alle Variablen global, die ausserhalb von Prozeduren, irgendwo im Script-Code, deklariert werden. Auf globale Variablen können alle Prozeduren zur Laufzeit zugreifen, d.h. wenn wir eine globale Variable [test] haben, können wir auch in einer Prozedur auf sie zugreifen. Anders ist es bei Variablen, die als Parameter in Prozeduren und Funktionen definiert oder in den Prozeduren/Funktionen deklariert wurden, diese sind nämlich alle lokal. Man kann auch beim Aufruf einer weiteren Prozedur aus einer Prozedur nicht auf die lokalen Werte der aufrufenden Prozedur zugreifen. Wäre dies möglich, würde ein immenses Chaos ausbrechen, was die Programmierung rekursiver Prozeduren (siehe nächstes Kapitel) sowie die strukturierte, prozedurale Programmierung im Allgemeinen völlig unmöglich und zwecklos machen würde. Der Unterschied zwischen lokalen und globalen Variablen kann manchmal auch zu sehr viel Verwirrung führen, daher rate ich, um Probleme mit globalen Variablen zu vermeiden, immer jede lokale Variable, die nicht als Parameter übergeben wird, in der Prozedur mit Hilfe der DEC-Anweisung explizit zu deklarieren. Einfachstes Fallbeispiel ist folgendes Script:<br><!-- br --><br><!-- br -->[code]<font color="#000080">[i]</font> = <font color="#0000ff">'10'</font><br /><!-- br --><br /><!-- br --><b>proc</b> test<br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> = <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'i ist hier '</font> # <font color="#000080">[i]</font><br /><!-- br --><b>endproc</b><br /><!-- br --><br /><!-- br -->echo <font color="#0000ff">'i ist hier '</font> # <font color="#000080">[i]</font><br /><!-- br -->test<br /><!-- br -->echo <font color="#0000ff">'i ist hier '</font> # <font color="#000080">[i]</font><br /><!-- br --><b>end</b>[/code]<!-- br --><br><!-- br -->Was hier passiert ist recht einfach: Wir wollen [i] in der Prozedur &quot;test&quot; lokal verwenden. Wir weisen [i] einfach einen Wert zu und nehmen an, dass [i] automatisch neu deklariert wird. Dies wird sie jedoch nicht, da [i] bereits schon global existiert, und RapidBATCH annimmt, wir wollten auf die globale Variable [i], die ja bereits existiert, zugreifen. Deshalb müssen wir die Variable [i] nun explizit noch einmal für diese Prozedur deklarieren, indem wir die DEC-Anweisung verwenden:<br><!-- br --><br><!-- br -->[code]<font color="#000080">[i]</font> = <font color="#0000ff">'10'</font><br /><!-- br --><br /><!-- br --><b>proc</b> test<br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>dec</b> <font color="#000080">[i]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> = <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'i ist hier '</font> # <font color="#000080">[i]</font><br /><!-- br --><b>endproc</b><br /><!-- br --><br /><!-- br -->echo <font color="#0000ff">'i ist hier '</font> # <font color="#000080">[i]</font><br /><!-- br -->test<br /><!-- br -->echo <font color="#0000ff">'i ist hier '</font> # <font color="#000080">[i]</font><br /><!-- br --><b>end</b>[/code]<!-- br --><br><!-- br -->In diesem Falle wird [i] neu, als lokale Variable, in der Prozedur &quot;test&quot; deklariert. Nach Beendigung der Prozedur wird die lokale [i]-Variable aus dem Speicher entfernt, und es kann die &quot;alte&quot;, globale [i]-Variable weiter verwendet werden.<br><!-- br --><br><!-- br -->Möglicherweise haben Sie noch ein wenig Probleme, den Sinn hinter den lokalen und globalen Variablen richtig zu durchschauen, aber je mehr Sie in RapidBATCH programmieren, desto klarer werden solche Strukturen und Zusammenhänge werden.<br><!-- br --><br><!-- br -->Wie Sie professionell die prozedurale Programmierung in RapidBATCH ausnutzen können, wird in den folgenden Kapiteln genauer erläutert. Professionelle Anwendungsbeispiele finden Sie auch in den zahlreichen Beispielprogrammen und Bibliotheksfunktionen, die das RapidBATCH-Programmpaket beinhaltet.
rb5_ger_procedural_2.html§Rekursive Programmierung von Prozeduren§Bei der rekursiven Programmierung ruft sich eine Prozedur oder Funktion in einem Script selbst wieder auf. Wichtig dabei ist, dass eine Abbruchbedingung gegeben ist, weil sich das rekursive Programm sonst (theoretisch) unendlich oft selbst aufrufen würde. Die rekursive Programmierung bietet daher eine elegante Art und Weise, wie man in sich verschachtelte Operationen schnell und einfach durchführen kann. Diese darf in RapidBATCH natürlich nicht fehlen!<br><!-- br --><br><!-- br -->Ein einfaches Beispiel für ein rekursiv ablaufendes Programm ist die Berechnung der Fakultät. Die Berechnung der Fakultät ist mathematisch wie folgt definiert:<br><!-- br --><ul/><li/>Die Fakultät der Zahl 0 ist definitionsgemäß 1.</li/><li/>Die Fakultät einer ganzen Zahl, die größer als 0 ist, ist das Produkt dieser Zahl mit der Fakultät der nächstkleineren ganzen Zahl.</li/></ul/><br><!-- br -->Wir werden nun solch ein Script programmieren, welches die Fakultät rekursiv berechnet:<br><!-- br --><br><!-- br -->[code]<font color="#808080">rem Funktion fac zur Berechnung der Fakultät</font><br /><!-- br --><b>func</b> fac: <font color="#000080">[x]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>dec</b> <font color="#000080">[ergebnis]</font><br /><!-- br --><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[x]</font> = <font color="#0000ff">'0'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[ergebnis]</font> = <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>else</b><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rem Rekursiver Aufruf von fac</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fac <font color="#000080">[ergebnis]</font> = <font color="#000080">[x]</font> - <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[ergebnis]</font> * <font color="#000080">[x]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>endif</b><br /><!-- br --><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>ret</b> <font color="#000080">[ergebnis]</font><br /><!-- br --><b>endfunc</b><br /><!-- br --><br /><!-- br --><font color="#808080">rem Erstaufruf der Funktion fac</font><br /><!-- br -->fac <font color="#000080">[fakultät]</font> = <font color="#0000ff">'4'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem Ausgabe des Ergebisses</font><br /><!-- br -->echo <font color="#0000ff">'Die Fakultät von 4 ist '</font> # <font color="#000080">[fakultät]</font><br /><!-- br --><b>end</b>[/code]<!-- br --><br><!-- br -->Das ist schon alles! Wie man unschwer erkennen kann, ruft sich die Funktion FAC rekursiv aus sich selber heraus auf - allerdings mit dem dekrementierten (um 1 verminderten) Wert der Variablen [x]. Abbruchbedingung in diesem Fall ist die Prüfung, ob [x] den Wert '0' enthält. Ist dies der Fall, ruft sich die Funktion nicht mehr weiterhin selbst auf, und löst die Rekursion auf.<br><!-- br -->Da ja bei der Rekursion gleich mehrere Hundert (oder gar Tausend) Aufrufe der selben Funktion möglich sind, befinden sich natürlich alle Aufrufe in einem so genannten Stack (&quot;Stapelspeicher&quot;) im Hauptspeicher des Computers. Durch die Abbruchbedingung werden nun alle aufgerufenen Funktionen wieder sorgfältig abgearbeitet und beendet.<br><!-- br -->Würde man bei unserer Fakultäts-Berechnungsfunktion keine solche Abbruchbedingung definieren, würde es irgendwann zu einem Speicherüberlauf und damit zum Programm- oder gar Systemabsturz kommen, da sich die Funktion so lange aufruft, bis kein Speicher mehr verfügbar ist.<br><!-- br --><br><!-- br -->Um den Verlauf der Rekursion unseres Fakultäts-Scripts etwas Verständlicher zu machen, können wir auch noch ein paar ECHO-Meldungen zur Programmverfolgung einfügen:<br><!-- br --><br><!-- br -->[code]<font color="#000080">[rekebene]</font> = <font color="#0000ff">'0'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem Funktion fac zur Berechnung der Fakultät</font><br /><!-- br --><b>func</b> fac: <font color="#000080">[x]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>dec</b> <font color="#000080">[ergebnis]</font><br /><!-- br --><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem Ausgabe der Rekursionstiefe</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Start in Rekursionsebene '</font> # <font color="#000080">[rekebene]</font> # <font color="#0000ff">', Parameterwert '</font> # <font color="#000080">[x]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[rekebene]</font> + <font color="#0000ff">'1'</font><br /><!-- br --><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[x]</font> = <font color="#0000ff">'0'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[ergebnis]</font> = <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>else</b><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rem Rekursiver Aufruf von fac</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fac <font color="#000080">[ergebnis]</font> = <font color="#000080">[x]</font> - <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[ergebnis]</font> * <font color="#000080">[x]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>endif</b><br /><!-- br --><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem Ausgabe der Rekursionstiefe</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[rekebene]</font> - <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Ende in Rekursionsebene '</font> # <font color="#000080">[rekebene]</font> # <font color="#0000ff">', Ergebnis: '</font> # <font color="#000080">[ergebnis]</font><br /><!-- br --><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>ret</b> <font color="#000080">[ergebnis]</font><br /><!-- br --><b>endfunc</b><br /><!-- br --><br /><!-- br --><font color="#808080">rem Erstaufruf der Funktion fac</font><br /><!-- br -->fac <font color="#000080">[fakultät]</font> = <font color="#0000ff">'4'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem Ausgabe des Ergebisses</font><br /><!-- br -->echo <font color="#0000ff">'Die Fakultät von 4 ist '</font> # <font color="#000080">[fakultät]</font><br /><!-- br --><b>end</b>[/code]<!-- br --><br><!-- br -->Dieses Beispiel zeigt auch nochmal die Verwendung von lokalen und globalen Variablen: Bei jedem rekursiven Aufruf werden alle lokalen Variablen der Prozedur/Funktion neu deklariert und können auch mit neuen bzw. unterschiedlichen Werten gefüllt werden. Es können daher (als Beispiel) mehrere Tausend Variablen [x] im Speicher existieren, doch nur eine ist lokal für den aktuellen Aufruf der Prozedur gültig; Daher können auch nicht die Werte von darunterliegenden Rekursionen geändert werden, wäre dies möglich, wäre rekursive Programmierung völlig unnütz.<br><!-- br -->Anders verhält es sich bei den altbekannten, globalen Variablen: Diese behalten ihren Wert, so wie unsere Variable [rekebene]. Wir können [rekebene] daher bei jedem Aufruf um 1 inkrementieren (erhöhen) und vor jeder Beendigung der Funktion wieder um eins dekrementieren (verringern). Somit können wir im Meldungfenster immer genau sehen, in welcher Rekursions-Tiefe wir uns gerade befinden. Wie Sie bei der Ausführung des Scripts sicherlich bemerkt haben, ruft sich die Funktion bei Übergabe des Wertes '4' genau 5 mal wieder selber auf, also bis der Übergabe-Wert 0 ist.<br><!-- br --><br><!-- br -->Rekursive Programmierung lässt sich sehr vielfältig einsetzen und kann äusserst effektiv sein.<br><!-- br -->Um Beispielsweise ein Verzeichnis zu duplizieren wurde in die RapidBATCH-Systemfunktions-Bibliothek (SYSTEM.RB) die Prozedur &quot;copydir&quot; implementiert, die ein komplettes Verzeichnis mitsamt Unterverzeichnissen rekursiv kopieren kann.<!-- br --><br><br><!-- br -->[code]<b>proc</b> copyDir: <font color="#000080">[source]</font>, <font color="#000080">[target]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>dec</b> <font color="#000080">[tok]</font>, <font color="#000080">[i]</font>, <font color="#000080">[files]</font><br /><!-- br --><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;findfiles <font color="#000080">[files]</font> = <font color="#000080">[source]</font> # <font color="#0000ff">'\*'</font>, <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[files]</font> = <font color="#0000ff">''</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[errorcode]</font> = <font color="#0000ff">'-1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>ret</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>endif</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;mkdir <font color="#000080">[target]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>repeat</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;calcvar <font color="#000080">[i]</font> = <font color="#000080">[i]</font> + <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gettok <font color="#000080">[tok]</font> = <font color="#000080">[files]</font>, <font color="#0000ff">'|'</font>, <font color="#000080">[i]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[tok]</font> ! <font color="#0000ff">''</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getfileatt <font color="#000080">[isDir]</font> = <font color="#000080">[source]</font> # <font color="#0000ff">'\'</font> # <font color="#000080">[tok]</font>, <font color="#0000ff">'DIRECTORY'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[isDir]</font> = <font color="#0000ff">'0'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;copyDir <font color="#000080">[source]</font> # <font color="#0000ff">'\'</font> # <font color="#000080">[tok]</font>, <font color="#000080">[target]</font> # <font color="#0000ff">'\'</font> # <font color="#000080">[tok]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>else</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;copyfile <font color="#000080">[source]</font> # <font color="#0000ff">'\'</font> # <font color="#000080">[tok]</font>, <font color="#000080">[target]</font> # <font color="#0000ff">'\'</font> # <font color="#000080">[tok]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>endif</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>endif</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>until</b> <font color="#000080">[tok]</font> = <font color="#0000ff">''</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[errorcode]</font> = <font color="#0000ff">'0'</font><br /><!-- br --><b>endproc</b>[/code]
rb5_ger_procedural_3.html§Zeiger auf Variablen§Bei unseren bisherigen Beispielen mit Prozeduren haben wir schon oft mit Parametern gearbeitet. Dabei haben wir bisher nur das &quot;Call-By-Value&quot;-Verfahren angewandt, d.h. einen einzelnen Wert an eine lokale Variable der Prozedur übergeben. Bei diesem Verfahren kann aber nur intern innerhalb der aufgerufenen Prozedur mit diesen Werten gearbeitet werden, d.h. sie sind nicht veränderbar, ausserdem lassen sich somit keine Arrays an Prozeduren übergeben. Zu diesem Zwecke gibt es das &quot;Call-by-Reference&quot;-Verfahren, bei dem man einer Prozedur als Parameter nicht den Inhalt der Variablen übergibt, sondern eine lokale &quot;Pseudo-Variable&quot;, die dann auf die eigentliche Variable zeigt. Diese &quot;Pseudo-Variablen&quot; heißen Pointer, weil sie auf einen Speicherbereich, eben die Ziel-Variable, zeigen. Über solch einen Pointer kann man auf Variablen (und natürlich auch auf Arrays) uneingeschränkt zugreifen, d.h. Werte lesen und schreiben. Obwohl der Pointer eine lokale Variable ist, kann man über diesen globale Variablen oder auch die lokalen Variablen einer Prozedur verändern, welche die Prozedur mit dem Pointer aufgerufen hat. Es kommt ganz darauf an, worauf der Pointer zeigt.<br><!-- br --><br><!-- br -->Ein Parameter wird bei der Prozedurdeklaration mit einem Sternchen (*) beginnend als Pointer deklariert. Folgendes Beispiel-Script zeigt, wie man einen Pointer in einer Prozedur deklariert, übergibt und verwendet:<br><!-- br --><br><!-- br -->[code]<b>proc</b> neuer_wert: <font color="#000080">[*a]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Der Wert von [a] ist '</font> # <font color="#000080">[a]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[a]</font> = <font color="#0000ff">'Das ist der neue Wert, der über den Pointer geschrieben wurde'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Der Wert von [a] ist jetzt '</font> # <font color="#000080">[a]</font><br /><!-- br --><b>endproc</b><br /><!-- br --><br /><!-- br --><font color="#000080">[test]</font> = <font color="#0000ff">'Hello World'</font><br /><!-- br -->echo <font color="#0000ff">'Der Wert von [test] ist '</font> # <font color="#000080">[test]</font><br /><!-- br -->neuer_wert <font color="#000080">[test]</font><br /><!-- br -->echo <font color="#0000ff">'Der Wert von [test] ist jetzt '</font> # <font color="#000080">[test]</font><br /><!-- br --><b>end</b>[/code]<!-- br --><br><!-- br -->Pointer sind auch die einzige Möglichkeit, ein Array in einer Prozedur zu verarbeiten. Bestes Beispiel ist die Prozedur &quot;viewArray&quot; aus der RapidBATCH-Bibliothek ARRAY.RB.<br><!-- br --><br><!-- br -->[code]<font color="#808080">rem Prozedur viewArray zur Anzeige eines Arrays</font><br /><!-- br --><b>proc</b> viewArray: <font color="#000080">[*array]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>dec</b> <font color="#000080">[i]</font>, <font color="#000080">[text]</font><br /><!-- br --><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[array:'0']</font> = <font color="#0000ff">'0'</font> <b>ret</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>repeat</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> + <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[text]</font> # <font color="#0000ff">'Index '</font> # <font color="#000080">[i]</font> # <font color="#0000ff">': '</font> # <font color="#000080">[array[i]]</font> # <font color="#000080">[new_line]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>until</b> <font color="#000080">[i]</font> = <font color="#000080">[array:'0']</font><br /><!-- br --><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#000080">[text]</font><br /><!-- br --><b>endproc</b><br /><!-- br --><br /><!-- br --><font color="#808080">rem Array erzeugen</font><br /><!-- br --><font color="#000080">[namen:'1']</font> = <font color="#0000ff">'Jan'</font><br /><!-- br --><font color="#000080">[namen:'2']</font> = <font color="#0000ff">'Anna'</font><br /><!-- br --><font color="#000080">[namen:'3']</font> = <font color="#0000ff">'Stefan'</font><br /><!-- br --><font color="#000080">[namen:'4']</font> = <font color="#0000ff">'Matthias'</font><br /><!-- br --><font color="#000080">[namen:'5']</font> = <font color="#0000ff">'Sebastian'</font><br /><!-- br --><font color="#000080">[namen:'6']</font> = <font color="#0000ff">'Daniel'</font><br /><!-- br --><font color="#000080">[namen:'7']</font> = <font color="#0000ff">'Uli'</font><br /><!-- br --><font color="#000080">[namen:'8']</font> = <font color="#0000ff">'Andreas'</font><br /><!-- br --><font color="#000080">[namen:'9']</font> = <font color="#0000ff">'Volker'</font><br /><!-- br --><font color="#000080">[namen:'10']</font> = <font color="#0000ff">'Marco'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem Array anzeigen</font><br /><!-- br -->viewarray <font color="#000080">[namen]</font><br /><!-- br --><b>end</b>[/code]<!-- br --><br><!-- br --><br><!-- br --><!-- br -->Natürlich können auch die Werte eines Arrays beliebig verändert werden. Folgendes Script quadriert jeden Eintrag eines Arrays und schreibt ihn in das Array selbst zurück.<!-- br --><!-- br --><br><!-- br --><br><!-- br --><!-- br -->[code]<font color="#808080">rem Prozedur viewArray zur Anzeige eines Arrays</font><br /><!-- br --><b>proc</b> viewArray: <font color="#000080">[*array]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>dec</b> <font color="#000080">[i]</font>, <font color="#000080">[text]</font><br /><!-- br --><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[array:'0']</font> = <font color="#0000ff">'0'</font> <b>ret</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>repeat</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> + <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[text]</font> # <font color="#0000ff">'Index '</font> # <font color="#000080">[i]</font> # <font color="#0000ff">': '</font> # <font color="#000080">[array[i]]</font> # <font color="#000080">[new_line]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>until</b> <font color="#000080">[i]</font> = <font color="#000080">[array:'0']</font><br /><!-- br --><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#000080">[text]</font><br /><!-- br --><b>endproc</b><br /><!-- br --><br /><!-- br --><font color="#808080">rem Prozedur array_zum_quadrat quadriert jeden Eintrag eines Arrays</font><br /><!-- br --><b>proc</b> array_zum_quadrat: <font color="#000080">[*array]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>dec</b> <font color="#000080">[i]</font>, <font color="#000080">[text]</font><br /><!-- br --><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[array:'0']</font> = <font color="#0000ff">'0'</font> <b>ret</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>repeat</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> + <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[array:[i]]</font> * <font color="#000080">[array:[i]]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>until</b> <font color="#000080">[i]</font> = <font color="#000080">[array:'0']</font><br /><!-- br --><b>endproc</b><br /><!-- br --><br /><!-- br --><font color="#808080">rem Array erzeugen</font><br /><!-- br --><font color="#000080">[zahlen:'1']</font> = <font color="#0000ff">'5'</font><br /><!-- br --><font color="#000080">[zahlen:'2']</font> = <font color="#0000ff">'7'</font><br /><!-- br --><font color="#000080">[zahlen:'3']</font> = <font color="#0000ff">'2'</font><br /><!-- br --><font color="#000080">[zahlen:'4']</font> = <font color="#0000ff">'3'</font><br /><!-- br --><font color="#000080">[zahlen:'5']</font> = <font color="#0000ff">'9'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem Werte ausgeben</font><br /><!-- br -->viewarray <font color="#000080">[zahlen]</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem Alle Werte im Array quadrieren</font><br /><!-- br -->array_zum_quadrat <font color="#000080">[zahlen]</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem Werte ausgeben</font><br /><!-- br -->viewarray <font color="#000080">[zahlen]</font><br /><!-- br --><b>end</b>[/code]<!-- br --><!-- br -->Ein Pointer kann auch als Pointer an eine weitere Prozedur übergeben werden. In diesem Fall würde RapidBATCH über einen Pointer auf einen Pointer auf eine Variable zugreifen! Theoretisch könnte solch eine Kette von Pointern bis ins Unendliche fortgeführt werden.
