template.html§0TITLE§1CONTENT
rb5_ger_sysop_1.html§Programme starten§Oftmals ist es gerade in der Batch-Programmierung notwendig, externe Programme zu starten, um bestimmte Vorgehensweisen und Methoden, die zu einem Ergebnis führen, zu automatisieren.<br><!-- br --><br><!-- br -->Um Programme zu starten, bietet Ihnen RapidBATCH gleich vier verschiedene Möglichkeiten an. Klassische Methode zum Starten einer Anwendung ist die SHELL-Anweisung. Sie führt ein Programm parallel zum RapidBATCH-Script aus, d.h. das Script selbst läuft parallel zum gestarteten Programm weiter. SHELL erwartet als Parameter den Pfad des zu startenden Programms (der auch Kommandozeilen-Parameter beinhalten kann) sowie einen so genannten Anzeigemodus (Show-Mode), der angibt, wie das Programm gestartet werden soll.<br><!-- br -->Der Anzeigemodus ist nur für einige Windows-Programme interessant, nicht alle Programme unterstützen diese Möglichkeit. Als Anzeigemodi können hier die Were 'SHOW', 'HIDE', 'MINIMIZED' oder 'MAXIMIZED' angegeben werden; 'SHOW' startet ein Programm mit der normalen Fenstergröße, 'HIDE' startet es versteckt, d.h. nicht sichtbar, womit die 'HIDE'-Option für Konsolenprogramme und Batch-Jobs sehr interessant ist, da diese somit unsichtbar im Hintergrund und ohne ein DOS-Fenster ausgeführt werden können. Die Modi 'MINIMIZED' und 'MAXIMIZED' starten das Programm mit einem minimierten bzw. maximierten Programmfenster. Diese beiden Werte sind jedoch - wie bereits angesprochen - nur bei bestimmten Programmen anwendbar.<br><!-- br --><br><!-- br -->Folgendes Script starten den Editor &quot;Notepad&quot; von Windows:<br><!-- br --><br><!-- br -->[code]shell <font color="#0000ff">'notepad.exe'</font>, <font color="#0000ff">'show'</font><br /><!-- br -->echo <font color="#0000ff">'Und jetzt starten wir Notepad maximiert...'</font><br /><!-- br -->shell <font color="#0000ff">'notepad.exe'</font>, <font color="#0000ff">'maximized'</font><br /><!-- br -->echo <font color="#0000ff">'Ende!'</font><br /><!-- br --><b>end</b>[/code]<!-- br --><br><!-- br -->Neben der SHELL-Anweisung bietet RapidBATCH auch die CALL-Anweisung. CALL ist von den Parametern her identisch zu SHELL, hat aber die Eigenschaft, dass das RapidBATCH-Script, welches die Anwendung mit CALL aufgerufen hat, solange mit der Programmausführung wartet, bis das gestartete Programm abgearbeitet oder vom Benutzer beendet wurde.<br><!-- br --><br><!-- br -->Hier einmal unser Beispiel von oben, welches aber mit CALL arbeitet:<br><!-- br --><br><!-- br -->[code]call <font color="#0000ff">'notepad.exe'</font>, <font color="#0000ff">'show'</font><br /><!-- br -->echo <font color="#0000ff">'Und jetzt starten wir Notepad maximiert...'</font><br /><!-- br -->call <font color="#0000ff">'notepad.exe'</font>, <font color="#0000ff">'maximized'</font><br /><!-- br -->echo <font color="#0000ff">'Ende!'</font><br /><!-- br --><b>end</b>[/code]<!-- br --><br><!-- br -->Oftmals ist auch die Verwendung von MS-DOS-Konsolenkommandos einfach unabdingbar. Zur schnellen Ausführung eines Konsolenkommandos bietet RapidBATCH die SYSTEM-Anweisung. Als Parameter wird das entsprechene Kommando erwartet.<br><!-- br --><br><!-- br -->Beispiel:<br><!-- br --><br><!-- br -->[code]<font color="#808080">rem Ping an www.jmksf.de schicken</font><br /><!-- br -->system <font color="#0000ff">'ping www.jmksf.de'</font><br /><!-- br --><b>end</b>[/code]<!-- br --><br><!-- br -->Mit CALL bzw. SHELL lassen sich DOS-Kommandos auch versteckt ausführen (dieses Beispiel verwendet die Funktion READFILE zum Auslesen der Datei, die wir später detaillierter besprechen werden):<br><!-- br --><br><!-- br -->[code]<font color="#808080">rem dir-Kommando senden und in Datei test.txt umleiten</font><br /><!-- br -->call <font color="#0000ff">'cmd.exe /C dir *.exe &gt;test.txt'</font>, <font color="#0000ff">'hide'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem test.txt einlesen und ausgeben</font><br /><!-- br -->readfile <font color="#000080">[dir_ausgabe]</font> = <font color="#0000ff">'test.txt'</font>, <font color="#0000ff">'0'</font><br /><!-- br -->echo <font color="#000080">[dir_ausgabe]</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem test.txt wieder löschen</font><br /><!-- br -->delfile <font color="#0000ff">'test.txt'</font><br /><!-- br --><b>end</b>[/code]<!-- br --><!-- br --><div class="image"><img src="img/sysop_call_dir.gif" alt="Ausgabe eines DIR-Befehls in einer Messagebox" title="Ausgabe des DIR-Befehls" /><br /><!-- br -->Die Ausgabe des DIR-Befehls, umgeleitet und ausgelesen aus einer Datei</div><!-- br --><!-- br --><div class="remark">Anmerkung: Unter Windows 95, 98 und ME müssen Sie bei dem oben gezeigten Beispiel anstatt CMD.EXE das Programm COMMAND.COM aufrufen.</div><!-- br --><br><!-- br -->Zur letzten Möglichkeit, externe Programme zu starten, gehört die OPEN-Anweisung. OPEN kann vielseitig eingesetzt werden, beispielsweise kann hier auch anstatt eines Programmpfades der Name einer Datei (die dann mit dem entsprechend verknüpften Programm geöffnet wird) oder eine Internet-URL, die dann im Standard-Browser geladen wird, angegeben werden.<br><!-- br --><br><!-- br -->Beispiele:<br><!-- br --><br><!-- br -->[code]open <font color="#0000ff">'calc.exe'</font><br /><!-- br -->open <font color="#0000ff">'C:\jmksf\rb5\license.txt'</font><br /><!-- br -->open <font color="#0000ff">'http://www.rapidbatch.com'</font><br /><!-- br --><b>end</b>[/code]<!-- br --><br><!-- br -->Wenn OPEN zum Starten von Programmen benutzt wird, entspricht dies einem Aufruf von SHELL mit dem Anzeigemodus 'SHOW'.
rb5_ger_sysop_2.html§Verzeichnisoperationen§Zum Erstellen, Wechseln und Löschen von Verzeichnissen stellt RapidBATCH drei Anweisungen zur Verfügung: MKDIR, CHDIR und RMDIR. Diese sind äquivalent zu den gleichnamigen DOS-Kommandos.<br><!-- br --><br><!-- br -->Mit folgender Zeile erzeugen wir ein neues Verzeichnis C:\wale.<br><!-- br --><br><!-- br -->[code]mkdir <font color="#0000ff">'C:\wale'</font>[/code]<!-- br --><br><!-- br -->RapidBATCH legt auch übergeordnete Verzeichnisse mit MKDIR an, wenn wir einen Pfad angeben, der nicht existiert.<br><!-- br --><br><!-- br -->Wenn wir also die Zeile<br><!-- br --><br><!-- br -->[code]mkdir <font color="#0000ff">'C:\wale\zahnwale\schwertwal'</font>[/code]<!-- br --><br><!-- br -->ausführen, und weder der Pfad C:\wale noch C:\wale\zahnwale existiert, legt RapidBATCH alle drei Verzeichnisse automatisch hinereinander an.<br><!-- br --><br><!-- br -->Möchten wir nun das Verzeichnis wechseln, verwenden wir die CHDIR-Anweisung:<br><!-- br --><br><!-- br -->[code]chdir <font color="#0000ff">'C:\wale\zahnwale\schwertwal'</font>[/code]<!-- br --><br><!-- br -->Ob unser Verzeichniswechsel erfolgreich war oder nicht, können wir anhand der vordeklarierten Variablen [errorcode] überprüfen. Sowohl MKDIR als auch CHDIR und RMDIR geben bei einem Fehler den Wert '-1' (false) an [errorcode], ansonsten den Wert '0' (true) zurück. Wir können also wie folgt herausfinden, ob unser Verzeichnis existiert oder nicht:<br><!-- br --><br><!-- br -->[code]chdir <font color="#0000ff">'C:\wale\zahnwale\schwertwal'</font><br /><!-- br --><b>if</b> <font color="#000080">[errorcode]</font> = <font color="#0000ff">'-1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Verzeichniswechsel fehlgeschlagen!'</font><br /><!-- br --><b>else</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Verzeichniswechsel erfolgreich!'</font><br /><!-- br --><b>endif</b>[/code]<!-- br --><br><!-- br -->Mit RMDIR löschen wir ein Verzeichnis wieder. Das zu löschende Verzeichnis MUSS allerdings leer sein, darf also weder Dateien noch weitere Unterverzeichnisse enthalten.<br><!-- br --><br><!-- br -->[code]rmdir <font color="#0000ff">'C:\wale\zahnwale\schwertwal'</font>[/code]<!-- br --><br><!-- br -->Anders als bei MKDIR wird hier aber immer nur ein einziges Verzeichnis, nämlich der entsprechend angegebene Pfad gelöscht.<!-- br --><!-- br --><div class="remark">Anmerkung: Verwenden Sie zum Verschieben bzw. Kopieren von Verzeichnissen (samt deren Unterverzeichnissen) die Bibliotheks-Anweisungen MOVEDIR bzw. COPYDIR aus der RapidBATCH-Bibliothek SYSTEM.RB.</div>
rb5_ger_sysop_3.html§Dateioperationen im Filesystem§Um Dateien zu verwalten, bietet Ihnen RapidBATCH die Anweisungen und Funktionen NEWFILE, DELFILE, COPYFILE, RENAMEFILE, FILEEXISTS und FINDFILES.<br><!-- br --><br><!-- br -->Die Anweisung NEWFILE erzeugt eine leere Datei, DELFILE löscht eine existierende Datei. Die Syntax ist bei beiden Anweisungen äquivalent:<br><!-- br --><br><!-- br -->[code]<font color="#808080">rem Datei erzeugen</font><br /><!-- br -->newfile <font color="#0000ff">'leer.txt'</font><br /><!-- br --><b>if</b> <font color="#000080">[errorcode]</font> = <font color="#0000ff">'0'</font> echo <font color="#0000ff">'Datei leer.txt wurde erzeugt!'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem Datei löschen</font><br /><!-- br -->delfile <font color="#0000ff">'leer.txt'</font><br /><!-- br --><b>if</b> <font color="#000080">[errorcode]</font> = <font color="#0000ff">'0'</font> echo <font color="#0000ff">'Datei leer.txt wurde wieder gelöscht!'</font>[/code]<!-- br --><br><!-- br -->Auch hier können wir (übrigens bei jeder Datei-spezifischen Anweisung) wieder über die Variable [errorcode] prüfen, ob die jeweilige Dateioperation erfolgreich war ([errorcode] = '0') oder ob nicht ([errorcode] = '-1').<br><!-- br --><br><!-- br -->Um eine Datei zu kopieren bietet RapidBATCH die COPYFILE-Anweisung. Sie kopiert den Inhalt im Verhältnis 1:1 aus einer Quelldatei in eine Zieldatei. Die Anweisung RENAMEFILE ermöglicht das Umbenennen bzw. Verschieben einer Datei.<br><!-- br --><br><!-- br -->Beispiel:<br><!-- br --><br><!-- br -->[code]<font color="#808080">rem C:\jmksf\rb5\readme.txt in C:\test.txt kopieren...</font><br /><!-- br -->copyfile <font color="#0000ff">'C:\jmksf\rb5\readme.txt'</font>, <font color="#0000ff">'C:\test.txt'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem C:\TEST.TXT öffnen...</font><br /><!-- br -->open <font color="#0000ff">'C:\test.txt'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem C:\TEST.TXT wieder löschen...</font><br /><!-- br -->delfile <font color="#0000ff">'C:\test.txt'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem C:\jmksf\rb5\readme.txt in C:\test.txt umbenennen...</font><br /><!-- br -->renamefile <font color="#0000ff">'C:\jmksf\rb5\readme.txt'</font>, <font color="#0000ff">'C:\test.txt'</font><br /><!-- br --><font color="#808080">rem C:\TEST.TXT öffnen...</font><br /><!-- br -->open <font color="#0000ff">'C:\test.txt'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem C:\test.txt wieder zurück in C:\jmksf\rb5\readme.txt benennen...</font><br /><!-- br -->renamefile <font color="#0000ff">'C:\test.txt'</font>, <font color="#0000ff">'C:\jmksf\rb5\readme.txt'</font>[/code]<!-- br --><br><!-- br -->COPYFILE und RENAMEFILE erlauben keine Wildcards, d.h. es kann immer nur eine einzelne Datei kopiert werden. Wie man aber trotzdem mehrere Dateien kopieren/verschieben kann, besprechen wir weiter unten.<br><!-- br --><br><!-- br --><br><!-- br -->Ob eine Datei bereits existiert oder nicht lässt sich mit der Funktion FILEEXISTS überprüfen.<br><!-- br --><br><!-- br -->[code]fileexists <font color="#000080">[fx]</font> = <font color="#0000ff">'C:\AnyFile.txt'</font><br /><!-- br --><b>if</b> <font color="#000080">[fx]</font> = <font color="#0000ff">'-1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Datei existiert nicht.'</font><br /><!-- br --><b>else</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Datei existiert!'</font><br /><!-- br --><b>endif</b>[/code]<!-- br --><br><!-- br -->FILEEXISTS gibt also den Wert '-1' an die Rückgabevariable zurück, wenn die Datei nicht existiert. Ansonsten ist der Rückgabewert '0'.<!-- br --><br><!-- br --><br><!-- br -->Zu den leistungsstärksten und effektivsten Funktionen, die RapidBATCH bereitstellt, gehört die FINDFILES-Funktion. FINDFILES listet alle Dateien eines Verzeichnisses, ermöglicht aber auch das Einlesen eines Verzeichnisses mitsamt aller Unterverzeichnisse.<br><!-- br --><br><!-- br -->Folgendes Script erzeugt eine Liste aller Dateien des aktuellen Verzeichnisses und zeigt diese in einem LISTBOX-Dialog an.<br><!-- br --><br><!-- br -->[code]<font color="#808080">rem Dateiliste erzeugen</font><br /><!-- br -->findfiles <font color="#000080">[dateiliste]</font> = <font color="#0000ff">'*'</font>, <font color="#0000ff">'1'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem Anzeige der Dateiliste in einer LISTBOX</font><br /><!-- br -->listbox <font color="#000080">[datei]</font> = <font color="#000080">[current]</font>, <font color="#000080">[dateiliste]</font><br /><!-- br --><b>if</b> <font color="#000080">[datei]</font> ! <font color="#0000ff">''</font> echo <font color="#0000ff">'Gewählte Datei: '</font> # <font color="#000080">[datei]</font><br /><!-- br --><b>end</b>[/code]<!-- br --><!-- br --><div class="image"><img src="img/sysop_filelist.gif" alt="Auflistung von Dateien in einer LISTBOX" title="Auflistung der gefundenen Dateien" /><br /><!-- br -->Die mit FINDFILES erzeugte Dateiliste wird in einer LISTBOX zur Anzeige und Auswahl gebracht.</div><!-- br --><!-- br -->FINDFILES erwartet als Parameter einen so genannten Pfad-/Dateifilter, d.h. es werden nur Dateien, die sich im angegebenen Verzeichnis befinden und dem gegebene Dateifilter entsprechen, gelistet. Für den Dateifilter können so genannte Wildcards benutzt werden; Diese Wildcards (Platzhalter) werden durch die Zeichen * und ? repräsentiert und ermöglichen das Suchen nach bestimmten Mustern. Ein * ist ein Wildcard für ein beliebiges Textmuster, ? für ein einzelnes Zeichen.<br><!-- br -->Der zweite Parameter repräsentiert die Tiefe, bis zu wieviele Unterverzeichnisse eingelesen werden sollen; Der Wert 1 bedeutet, dass nur das aktuelle bzw. angegebene Verzeichnis durchsucht wird, 2 durchsucht das aktuelle bzw. angegebene Verzeichnis und alle darin enthaltenen Unterverzeichnisse. Haben diese Unterverzeichnisse wiederum Unterverzeichnisse, werden diese nicht mehr eingelesen; Wenn man diese auch einlesen will, muss man als Tiefe den Wert 3 angeben. Diese Tiefen-Angaben ließen sich jetzt bis ins Unendliche fortführen. Wird als Tiefe der Wert 0 angegeben, so wird bis zu einer maximalen Verzeichnistiefe von 255 gesucht und gelistet.<br><!-- br --><br><!-- br -->Rückgabewert von FINDFILES ist eine Dateiliste, in der jeder Dateiname durch das in der vordeklarierten Variablen [std_sep] definierte Separationszeichen (im Normalfall das Pipe-Zeichen &quot;|&quot;) getrennt ist. Wir können diese Liste daher direkt an LISTBOX als Item-Liste übergeben.<br><!-- br --><br><!-- br -->Um einmal die Verwendung der verschiedenen Filter, Wildcards und Verzeichnistiefenangaben zu demonstrieren, hier ein paar kommentierte Beispielaufrufe von FINDFILES:<br><!-- br --><br><!-- br -->[code]<font color="#808080">rem Alle Dateien im aktuellen Verzeichnis auflisten:</font><br /><!-- br -->findfiles <font color="#000080">[dateiliste]</font> = <font color="#0000ff">'*'</font>, <font color="#0000ff">'1'</font><br /><!-- br --><font color="#808080">rem (Der Filter "*" sucht nach allen Dateien, die es im Verzeichnis gibt)</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem Alle TXT-Dateien im aktuellen Verzeichnis und allen Unterverzeichnissen</font><br /><!-- br --><font color="#808080">rem bis zu einer Ebene auflisten:</font><br /><!-- br -->findfiles <font color="#000080">[dateiliste]</font> = <font color="#0000ff">'*.txt'</font>, <font color="#0000ff">'2'</font><br /><!-- br --><font color="#808080">rem (Der Filter "*.txt" sucht nach allen Dateien, die die Dateiendung</font><br /><!-- br --><font color="#808080">rem .TXT haben. Es werden also z.B. Dateinamen wie "hallo.txt", "x.txt"</font><br /><!-- br --><font color="#808080">rem und "txt.txt" eingelesen (wenn diese denn existieren)).</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem Alle Dateien im aktuellen Verzeichnis auflisten, die mit "hallo"</font><br /><!-- br --><font color="#808080">rem beginnen und mit ".DOC" enden:</font><br /><!-- br -->findfiles <font color="#000080">[dateiliste]</font> = <font color="#0000ff">'hallo*.doc'</font>, <font color="#0000ff">'1'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem Alle Dateien im aktuellen Verzeichnis auflisten, die mit "h", einem beliebigen</font><br /><!-- br --><font color="#808080">rem Buchstaben und "llo" beginnen und mit irgend einer Dateiendung enden:</font><br /><!-- br -->findfiles <font color="#000080">[dateiliste]</font> = <font color="#0000ff">'h?llo*.*'</font>, <font color="#0000ff">'1'</font><br /><!-- br --><font color="#808080">rem (Hier werden z.B. Dateinamen wie "hallo92.sav", "hello.bak", "hullokkn.exe"</font><br /><!-- br --><font color="#808080">rem und "hhlloHALLO." gefunden!)</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem Alle Dateien im aktuellen Verzeichnis und allen Unterverzeichnissen</font><br /><!-- br --><font color="#808080">rem auflisten, die eine Dateiendung haben:</font><br /><!-- br -->findfiles <font color="#000080">[dateiliste]</font> = <font color="#0000ff">'*.*'</font>, <font color="#0000ff">'0'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem Alle .RB-Dateien im aktuellen Verzeichnis auflisten, die nur einen</font><br /><!-- br --><font color="#808080">rem Buchstaben im Dateinamen haben:</font><br /><!-- br -->findfiles <font color="#000080">[dateiliste]</font> = <font color="#0000ff">'?.rb'</font>, <font color="#0000ff">'1'</font><br /><!-- br --><font color="#808080">rem (Der Filter "?.rb" sucht nach allen Dateien, die einen einzelnen</font><br /><!-- br --><font color="#808080">rem Buchstaben vor dem Punkt haben (? = einzelner Buchstabe), es werden</font><br /><!-- br --><font color="#808080">rem also nur die Dateien "a.rb", "x.rb" oder "1.rb" gelistet (wenn</font><br /><!-- br --><font color="#808080">rem diese denn existieren))</font>[/code]<!-- br --><br><!-- br -->Zum Schluss noch ein Beispiel, wie Sie mit Hilfe der Funktionen FINDFILES und GETTOK eine Prozedur programmieren, die mehrere Dateien in ein Zielverzeichnis kopiert (mit Hilfe von COPYFILE, da diese Funktion ja von sich aus keine Wildcards unterstützt):<br><!-- br --><br><!-- br -->[code]<b>proc</b> copyfiles: <font color="#000080">[quelle]</font>, <font color="#000080">[ziel]</font>, <font color="#000080">[filter]</font><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem Lokale Variablen vereinbaren</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>dec</b> <font color="#000080">[i]</font>, <font color="#000080">[datei]</font>, <font color="#000080">[dateiliste]</font><br /><!-- br --><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem Dateiliste holen</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;findfiles <font color="#000080">[dateiliste]</font> = <font color="#000080">[quelle]</font> # <font color="#0000ff">'\'</font> # <font color="#000080">[filter]</font>, <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[dateiliste]</font> = <font color="#0000ff">''</font> <b>ret</b><br /><!-- br --><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem Ziel-Verzeichnis zur Sicherheit erzeugen</font><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem (wird natürlich, wenn es schon existiert, nicht überschrieben)</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;mkdir <font color="#000080">[ziel]</font><br /><!-- br --><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem Dateiliste durchlaufen</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> = <font color="#0000ff">'0'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>repeat</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> + <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gettok <font color="#000080">[datei]</font> = <font color="#000080">[dateiliste]</font>, <font color="#0000ff">'|'</font>, <font color="#000080">[i]</font><br /><!-- br --><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rem Wenn [datei] nicht leer ist, Datei von</font><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rem Quelle nach Ziel kopieren</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[datei]</font> ! <font color="#0000ff">''</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;copyfile <font color="#000080">[quelle]</font> # <font color="#0000ff">'\'</font> # <font color="#000080">[datei]</font>, <font color="#000080">[ziel]</font> # <font color="#0000ff">'\'</font> # <font color="#000080">[datei]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>endif</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>until</b> <font color="#000080">[datei]</font> = <font color="#0000ff">''</font><br /><!-- br --><b>endproc</b><br /><!-- br --><br /><!-- br --><font color="#808080">rem Aufruf (kopiert alle Dateien mit dem Muster "*.*" aus dem</font><br /><!-- br --><font color="#808080">rem Verzeichnis "C:\jmksf\rb5" in das Verzeichnis "C:\test"):</font><br /><!-- br -->copyfiles <font color="#0000ff">'C:\jmksf\rb5'</font>, <font color="#0000ff">'C:\test'</font>, <font color="#0000ff">'*.*'</font><br /><!-- br --><b>end</b>[/code]
rb5_ger_sysop_4.html§Dateien lesen und schreiben§Um Dateien in RapidBATCH zu verarbeiten, stellt Ihnen RapidBATCH vier vielseitig anwendbare Anweisungen und Funktionen zur Verfügung. Mit Hilfe dieser Anweisungen und Funktionen können Sie sowohl Textdateien als auch binäre Dateien lesen und schreiben.<br><!-- br --><br><!-- br -->Um Daten in eine Textdatei zu schreiben, bietet RapidBATCH die Anweisung WRITEFILE. WRITEFILE erwartet als Parameter einen Dateinamen sowie den zu schreibenden Text (also die zu schreibenden Daten).<br><!-- br --><br><!-- br -->Einfachstes Fallbeispiel:<br><!-- br --><br><!-- br -->[code]writefile <font color="#0000ff">'hello.txt'</font>, <font color="#0000ff">'Dies ist ein einfacher Text in einer Textdatei!'</font>[/code]<!-- br --><br><!-- br -->WRITEFILE erweitert bei jedem Aufruf den Inhalt einer Datei, falls diese schon existiert, d.h. der zu schreibende Wert wird an das Ende der Datei angehängt. Ein Zeilenumbruch je WRITEFILE-Aufruf geschieht in der Datei automatisch. Existiert die zu schreibende Datei noch nicht, wird sie neu erstellt und der entsprechende Wert in die erste Zeile geschrieben.<br><!-- br --><br><!-- br -->Führen wir also den folgenden Code aus:<br><!-- br --><br><!-- br -->[code]writefile <font color="#0000ff">'test.txt'</font>, <font color="#0000ff">'Das ist ein Test!'</font><br /><!-- br -->writefile <font color="#0000ff">'test.txt'</font>, <font color="#0000ff">'Und jetzt sind wir in der zweiten Zeile!'</font><br /><!-- br -->writefile <font color="#0000ff">'test.txt'</font>, <font color="#0000ff">'So denn! Das ist das Ende der Datei.'</font>[/code]<!-- br --><br><!-- br -->so erhält die resultierende Datei TEST.TXT folgenden Inhalt:<br><!-- br --><br><!-- br --><!-- br -->[code]<b><font color="#000000">Das ist ein Test!<br><!-- br -->Und jetzt sind wir in der zweiten Zeile!<br><!-- br -->So denn! Das ist das Ende der Datei.</font></b>[/code]<!-- br --><!-- br --><br><!-- br --><br><!-- br -->Wollen wir nun die Datei wieder auslesen, verwenden wir die Funktion READFILE. READFILE ist ebenfalls nur zum Lesen von Textdateien geeignet, da sie eine Datei zeilenweise ausliest. Parameter sind der Dateiname der zu lesenden Datei sowie eine Zeilenangabe. Rückgabewert ist der Inhalt der angeforderten Zeile.<br><!-- br -->Folgendes Script liest die erste Zeile unserer gerade erstellten TEST.TXT aus.<br><!-- br --><br><!-- br -->[code]readfile <font color="#000080">[zeile]</font> = <font color="#0000ff">'test.txt'</font>, <font color="#0000ff">'1'</font><br /><!-- br -->echo <font color="#0000ff">'Erste Zeile von TEST.TXT: '</font> # <font color="#000080">[zeile]</font>[/code]<!-- br --><br><!-- br -->Wollen wir die Datei nun komplett Zeile-für-Zeile lesen, ist ein so genannter Zeilen-Zähler notwendig. Wir verwenden hier die Variable [i]. Wird bei READFILE eine Zeile angefordert, die nicht mehr existiert, so ist der Rückgabewert der Funktion der Wert &quot;EOF&quot;, was soviel bedeutet wie &quot;End Of File&quot;. Die Abbruchbedingung für unsere Ausleseschleife ist also der Vergleich, ob [zeile] den Wert 'EOF' erhält, womit wir nun folgendes Script erhalten:<br><!-- br --><br><!-- br -->[code]<font color="#000080">[i]</font> = <font color="#0000ff">'0'</font><br /><!-- br --><b>repeat</b><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem [i] inkrementieren (erhöhen)</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> + <font color="#0000ff">'1'</font><br /><!-- br --><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem Zeile [i] lesen</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;readfile <font color="#000080">[zeile]</font> = <font color="#0000ff">'test.txt'</font>, <font color="#000080">[i]</font><br /><!-- br --><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem Ausgabe der Zeile</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Inhalt von Zeile '</font> # <font color="#000080">[i]</font> # <font color="#0000ff">': '</font> # <font color="#000080">[zeile]</font><br /><!-- br --><b>until</b> <font color="#000080">[zeile]</font> = <font color="#0000ff">'EOF'</font>[/code]<!-- br --><!-- br --><!--<!-- br --><div class="remark">Wenn Sie das Script ausführen, werden Sie feststellen, dass die Zeile Nr. 4 leer ist. Das hat den einfachen Grund, dass wenn die Datei mit der Anweisung WRITEFILE geschrieben wurde, beim Schreiben der letzten Zeile ein neuer Zeilenumbruch erfolgt. READFILE liest daher eine leere Zeile, da die Datei ja nicht aus 3 sondern aus 4 Zeilen besteht!</div><!-- br -->--><!-- br --><!-- br -->READFILE kann auch eine Datei &quot;in einem Rutsch&quot; einlesen, also die komplette Textdatei zurückgeben. Diesen Effekt erhält man, wenn man als Zeilenindex eine Zahl kleiner oder gleich '0' angibt. Folgendes Script zeigt uns also direkt den Inhalt der Datei TEST.TXT an.<br><!-- br --><br><!-- br -->[code]readfile <font color="#000080">[datei]</font> = <font color="#0000ff">'test.txt'</font>, <font color="#0000ff">'0'</font><br /><!-- br -->echo <font color="#0000ff">'Inhalt von TEST.TXT:'</font> # <font color="#000080">[new_line]</font> # <font color="#000080">[new_line]</font> # <font color="#000080">[datei]</font>[/code]<!-- br --><br><!-- br -->Wir verwenden im obigen Script ausserdem die vordeklarierte Variable [new_line], um jeweils einen Zeilenumbruch im ECHO-Meldungsfenster zu erzeugen.<br><!-- br --><br><!-- br -->Sowohl bei READFILE als auch bei WRITEFILE kann durch Überprüfung der Variablen [errorcode] geprüft werden, ob die jeweilige Aktion erfolgreich war oder nicht. Die Vorgehensweise ist dieselbe wie bei den bisher besprochenenen Anwendungsfällen für [errorcode], '-1' bei einem Fehler (z.B. bei READFILE, wenn EOF eintritt oder die Datei nicht existiert, '0' bei erfolgreicher Durchführung.<br><!-- br --><br><!-- br -->Neben dem Schreiben und Lesen von Textdateien ist es in RapidBATCH 5 auch erstmals möglich, Binärdateien zu bearbeiten. Als Binärdateien definiert man alle Dateien, die keine direkten Textdateien sind. Selbst Office-Dateien wie .XLS oder .DOC sind KEINE Textdateien.<br><!-- br --><!-- br -->Wir werden in diesen Beispielen hier auch nur lesbare Texte in die Binärdateien schreiben, es können aber auch beliebige Sonder- und Steuerzeichen in die Binärdateien geschrieben werden.<br><!-- br --><br><!-- br --><!-- br -->Um eine Datei (es kann auch eine Textdatei sein!) binär zu schreiben, bietet RapidBATCH die Anweisung PUTFILE. Wenn man mit PUTFILE in eine nicht existierende Datei schreiben will, schlägt dies fehl, daher MUSS die Datei vorher mit NEWFILE explizit erzeugt werden. Folgendes Beispiel schreibt den Text &quot;Hello World&quot; binär in eine Datei BINARY.TXT. Neben dem Dateinamen und dem zu schreibenden Wert muss bei PUTFILE als zweiter Parameter der Byte-Offset, wo der Text in die Datei eingefügt werden soll, angegeben werden. Als Offset bezeichnet man die Position eines Zeichens ab dem Anfang der Datei. Da unsere Datei leer ist, beginnen wir also bei Offset 1. Es ist also das erste Byte der Datei. Die Zeichen, die binär in die Datei geschrieben werden, werden nicht im Klartext angegeben, sondern als Liste von ASCII-Zeichencodes der zu schreibenden ASCII-Zeichen, in der jeder Wert durch das bereits bekannte Standard-Separatorzeichen, welches über die Variable [std_sep] definiert werden kann, getrennt ist. Wie bereits bekannt sein sollte ist dies im Normalfall das Pipe-Zeichen &quot;|&quot;.<!-- br --><!-- br --><br><!-- br --><br><!-- br -->[code]newfile <font color="#0000ff">'binary.txt'</font><br /><!-- br -->putfile <font color="#0000ff">'binary.txt'</font>, <font color="#0000ff">'1'</font>, <font color="#0000ff">'72|101|108|108|111|32|87|111|114|108|100'</font><br /><!-- br -->open <font color="#0000ff">'binary.txt'</font>[/code]<!-- br --><br><!-- br -->In diesem Fall haben wir gerade 11 Byte in die Datei eingefügt, also 11 ASCII-Zeichen.<!-- br --><!-- br --><div class="remark"><!-- br -->Anmerkung: Um einen Klartext ganz einfach in eine Liste von ASCII-Zeichen zu konvertieren, verwenden Sie einfach folgendes Script, welches ich auch zum Erstellen der Beispiele in diesem Handbuch verwendet habe:<br><br><!-- br --><!-- br -->[code]<!-- br -->inputbox <font color="#000080">[eingabe]</font> = <font color="#0000ff">'Klartext'</font>, <font color="#0000ff">'Bitte geben Sie einen Text ein:'</font>, <font color="#0000ff">''</font><br /><!-- br --><b>if</b> <font color="#000080">[eingabe]</font> = <font color="#0000ff">''</font> <b>halt</b><br /><!-- br --><br /><!-- br --><font color="#000080">[i]</font> = <font color="#0000ff">'0'</font><br /><!-- br -->getlen <font color="#000080">[len]</font> = <font color="#000080">[eingabe]</font><br /><!-- br --><font color="#000080">[ausgabe]</font> = <font color="#0000ff">''</font><br /><!-- br --><b>repeat</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> + <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;getcharat <font color="#000080">[ch]</font> = <font color="#000080">[eingabe]</font>, <font color="#000080">[i]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;getasc <font color="#000080">[ch]</font> = <font color="#000080">[ch]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[ausgabe]</font> ! <font color="#0000ff">''</font> <font color="#000080">[ausgabe]</font> # <font color="#000080">[std_sep]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[ausgabe]</font> # <font color="#000080">[ch]</font><br /><!-- br --><b>until</b> <font color="#000080">[i]</font> = <font color="#000080">[len]</font><br /><!-- br --><br /><!-- br --><font color="#000080">[clipboard]</font> = <font color="#000080">[ausgabe]</font><br /><!-- br -->echo <font color="#0000ff">'Der Text wurde als ASCII-Liste dekodiert und in die Zwischenablage kopiert.'</font><br /><!-- br --><b>end</b><!-- br -->[/code]</div><!-- br --><!-- br --><!-- br --><!-- br -->Wir könnten jetzt auch beispielsweise direkt an Byte-Position 100 mit dem Schreiben der Datei fortfahren:<br><!-- br --><br><!-- br --><!-- br -->[code]<font color="#808080">rem Text: &quot;Und dies ist ein weiterer&quot;</font><br /><!-- br --><font color="#000080">[text]</font> = <font color="#0000ff">'85|110|100|32|100|97|115|32'</font><br /><!-- br --><font color="#000080">[text]</font> # <font color="#0000ff">'|105|115|116|32|101|105|110|32'</font><br /><!-- br --><font color="#000080">[text]</font> # <font color="#0000ff">'|119|101|105|116|101|114|101|114'</font><br /><!-- br -->putfile <font color="#0000ff">'binary.txt'</font>, <font color="#0000ff">'100'</font>, <font color="#000080">[text]</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem Text: &quot;Binär-Schreibvorgang ;)&quot;</font><br /><!-- br --><font color="#000080">[text]</font> = <font color="#0000ff">'32|66|105|110|228|114|45|83|99'</font><br /><!-- br --><font color="#000080">[text]</font> # <font color="#0000ff">'|104|114|101|105|98|118|111'</font><br /><!-- br --><font color="#000080">[text]</font> # <font color="#0000ff">'|114|103|97|110|103|32|59|41'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem Da wir jetzt 24 Zeichen geschrieben haben,</font><br /><!-- br --><font color="#808080">rem müssen wir ab Pos 100 + 24 weiterschreiben</font><br /><!-- br -->putfile <font color="#0000ff">'binary.txt'</font>, <font color="#0000ff">'100'</font> + <font color="#0000ff">'24'</font>, <font color="#000080">[text]</font>[/code]<!-- br --><!-- br --><!-- br -->Diese Zeilen und Mengen an ASCII-Codewerten mögen vielleich im ersten Moment etwas chaotisch aussehen, da wir hier auf reiner RapidBATCH-Sprachbasis arbeiten. Wenn Sie später die Binärfunktionen produktiv einsetzen wollen ist es natürlich ratsam, sich entsprechende Hilfsfunktionen zu programmieren, die einem die Arbeit erheblich sparen können und sich völlig individuell an die entsprechenden Einsatzumgebungen abändern lassen.<!-- br --><br><br><!-- br --><!-- br -->Wenn wir nun zusätzlich auch obige Zeilen ausgeführt haben, sieht die Datei, wenn man sie in einem HEX-Editor betrachtet, so aus:<br><!-- br --><!-- br --><div class="image"><img src="img/hexview_binary.gif" title="Inhalt der Datei BINARY.TXT in einem Hex-Editor"/><br /><!-- br -->Inhalt der Datei BINARY.TXT in einem Hex-Editor</div><!-- br --><!-- br -->Deutlich zu sehen ist, dass unser zweiter, binärer Schreibvorgang bei Hex-Offset 64 beginnt, also Dezimal der Offset 100. Der Bereich zwischen unserem &quot;Hello World&quot; und dem Text &quot;Und das ist ein weiterer Binär-Schreibvorgang ;)&quot; wird mit dem ASCII-Zeichencode 0 aufgefüllt, was soviel heißt wie &quot;nichts&quot; (NUL).<br><!-- br --><!-- br --><div class="remark">ACHTUNG: Bei Windows 95, 98 und ME bzw. FAT und Derivate formatierten Speichermedien wurde beobachtet, dass anstatt ASCII-Zeichencode 0 der Inhalt von gelöschten Daten auf der Festplatte in der Datei auftauchen können, da PUTFILE die Daten ja binär einfach irgendwo auf die Festplatte an die angegebene Position schreibt; Der Grund dafür ist, dass einfach die neu hinzugekommenen Daten zur Datei selbst hinzugefügt werden. Daher bitte, um diesen Effekt zu vermeinden, die entsprechenden Stellen vorher manuell mit NUL- oder einem anderem ASCII-Zeichen auffüllen.</div><!-- br --><!-- br -->Wenn Sie mit PUTFILE in eine bestehende Datei schreiben, werden alle Zeichen, die Sie an einer bestimmten Byteposition angeben, einfach in die Datei geschrieben, d.h. vorhandene Zeichen werden einfach überschrieben. Es erfolgt also kein append (Anhängen von Daten), denn dies wäre ja für binäre Dateiverarbeitung nicht angebracht, bzw. ohne größeren Sinn (Dateien werden ja automatisch erweitert, wenn Daten über das Dateiende hinaus geschrieben wurden, wie wir es im obigen Beispiel gemacht haben).<br><!-- br --><br><!-- br --><br><!-- br -->Das Auslesen einer Binärdatei funktioniert so ähnlich wie das Schreiben - hierzu benutzen wir gegensätzlich zu PUTFILE die Funktion GETFILE. GETFILE erwartet als Funktionsparameter den Pfad der zu lesenden Datei, den Anfangs-Offset sowie die Anzahl der Bytes, die vom Anfangs-Offset aus gelesen werden. Wenden wir nun GETFILE auf unsere im obigen Beispiel erstellte Datei BINARY.TXT an. Zu beachten sei auch hier, dass die Rückgabe von GETFILE eine Liste an ASCII-Codes ist, die wir zuerst wieder mit der Funktion GETCHR zu entsprechenden Zeichen umwandeln müssen, was aber kein größeres Problem darstellt.<br><!-- br --><br><!-- br -->[code]<font color="#808080">rem Daten lesen</font><br /><!-- br -->getfile <font color="#000080">[data]</font> = <font color="#0000ff">'binary.txt'</font>, <font color="#0000ff">'100'</font> + <font color="#0000ff">'25'</font>, <font color="#0000ff">'20'</font><br /><!-- br -->echo <font color="#0000ff">'Gelesene ASCII-Liste: '</font> # <font color="#000080">[data]</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem ASCII-Codes in ASCII-Zeichen umwandeln und an Ausgabestring hängen</font><br /><!-- br --><font color="#000080">[i]</font> = <font color="#0000ff">'0'</font><br /><!-- br --><b>repeat</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> + <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;gettok <font color="#000080">[zeichen]</font> = <font color="#000080">[data]</font>, <font color="#000080">[std_sep]</font>, <font color="#000080">[i]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[zeichen]</font> ! <font color="#0000ff">''</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getchr <font color="#000080">[zeichen]</font> = <font color="#000080">[zeichen]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[klartext]</font> # <font color="#000080">[zeichen]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>endif</b><br /><!-- br --><b>until</b> <font color="#000080">[zeichen]</font> = <font color="#0000ff">''</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem Den Klartext ausgeben</font><br /><!-- br -->echo <font color="#0000ff">'Klartext: '</font> # <font color="#000080">[klartext]</font><br /><!-- br --><b>end</b>[/code]<!-- br --><br><!-- br --><!-- br -->Wir lesen hier den Text &quot;Binär-Schreibvorgang&quot; aus der oben erstellten und geschriebenen Datei. Wir setzen dabei den Start-Offset auf 125 (dort wo der Text anfängt) und lesen von dort aus 20 Zeichen. Ergebnis ist der entsprechende String!<br><!-- br -->Wenn Sie mit GETFILE über das Dateiende hinaus lesen wollen, wird entweder ein Leerstring oder aber alle Bytes bis zum Dateiende zurückgegeben.<br><!-- br --><br><!-- br --><br><!-- br --><u>Wozu das alles?</u><br><!-- br -->Sicherlich haben Sie sich gefragt, warum wir hier einfache Textdateien binär schreiben. Das ist natürlich nicht der eigentliche Sinn und Zweck von Binärdateien. Sie haben aber mit PUTFILE und GETFILE die volle Kontrolle über eine Datei; Bei READFILE und WRITEFILE werden reine text-basierende Dateien verwaltet, doch mit PUTFILE und GETFILE haben Sie einfach mehr Möglichkeiten, eine Datei zu verarbeiten. Sie stellen sozusagen die &quot;professionelle Alternative&quot; zu WRITEFILE und READFILE dar, welche Sie aber mit höchster Warscheinlichkeit vermehrt bei der Programmierung von Scripts in RapidBATCH einsetzen werden, da WRITEFILE und READFILE für die meisten Anwendungsfälle mehr als ausreichend und natürlich viel einfacher zu handhaben sind.
rb5_ger_sysop_5.html§Programme fernsteuern§Eine effektive Möglichkeit der Automatisierung ist auch das Fernsteuern von fremden Anwendungen. RapidBATCH ist dabei in der Lage, anderen Windows-Programmen vorzugaukeln, der PC-Benutzer würde das Programm selbst bedienen, indem es Tastaturbefehle und Tastenkombinationen an das entsprechende Fenster sendet.<br><!-- br --><!-- br -->Zu diesem Zweck stellt RapidBATCH die SENDKEYS-Anweisung zur Verfügung. Mit einer sehr einfach zu erlernenden und primitiv aufgebauten Makrosprache kann der RapidBATCH-Programmierer über diese Anweisung Tastenkombinationen und Tastatureingaben an theoretisch jedes beliebige Windows-Programm senden.<br><!-- br --><!-- br -->Folgendes Script demonstriert, wie sich der Windows Editor &quot;Notepad&quot; fernsteuern lässt: Es startet Notepad und gibt den Text &quot;Hello World&quot; ein. Danach wird die Datei gespeichert und das Programm anschliessend beendet, wozu das Script die entsprechenden Tastenkombinationen schickt, um das Menü zu öffnen und den Menüpunkt &quot;Datei -> Speichern&quot; auszuwählen.<br><!-- br --><br><!-- br -->[code]shell <font color="#000080">[windir]</font> # <font color="#0000ff">'\notepad.exe'</font>, <font color="#0000ff">'show'</font><br /><!-- br -->sendkeys <font color="#0000ff">'Unbenannt - Editor'</font>: <font color="#0000ff">'Hello World^(alt)dstest.txt(enter)^(alt)(f4)'</font><br /><!-- br --><b>end</b>[/code]<!-- br --><br><!-- br --><!-- br -->Als ersten Parameter erwartet SENDKEYS den Titel des Fensters, an dem das Programm identifiziert wird. Dieser Titel kann zum Beispiel auch über die Variable [active_window] geholt werden, die den Titel des aktiven Vordergrundfensters enthält.<br><!-- br -->Anschliessend folgt ein in der bereits angesprochenen Makrosprache definierter Satz an Tastenkombinationen, die an das fernzusteuernde Programm geschickt werden sollen.<br /><br /><!-- br --><!-- br -->Nehmen wir nun einmal diese Tastaturkommandos und Tastenkombinationen, welches wir bei SENDKEYS an den Notepad-Editor senden, genauer unter die Lupe:<br><!-- br --><br><!-- br --><center><!-- br -->	<table class="std"><!-- br -->	<tr><!-- br -->		<td><!-- br -->			<b>Abschnitt:</b><!-- br -->		</td><!-- br -->		<td align="center"><!-- br -->			A<!-- br -->		</td><!-- br -->		<td align="center"><!-- br -->			B<!-- br -->		</td><!-- br -->		<td align="center"><!-- br -->			C<!-- br -->		</td><!-- br -->		<td align="center"><!-- br -->			D<!-- br -->		</td><!-- br -->	</tr><!-- br -->	<tr><!-- br -->		<td><!-- br -->			<b>Kommandos:</b><!-- br -->		</td><!-- br -->		<td align="center"><!-- br -->			Hello World<!-- br -->		</td><!-- br -->		<td align="center"><!-- br -->			^(alt)ds<!-- br -->		</td><!-- br -->		<td align="center"><!-- br -->			test.txt(enter)<!-- br -->		</td><!-- br -->		<td align="center"><!-- br -->			^(alt)(f4)<!-- br -->		</td><!-- br -->	</tr><!-- br -->	</table><!-- br --></center><!-- br --><!-- br --><br><!-- br --><!-- br --><ul><!-- br -->	<li><!-- br -->		<b>Abschnitt A:</b><br><!-- br -->		Hier schreiben wir einfach den Text &quot;Hello World&quot; in das Eingabefeld des Editors. Es muss darauf geachtet werden, dass der Cursor im richtigem Feld steht, wo der Text rein soll (das Eingabefeld hat beim Notepad nach dem starten IMMER den Eingabefokus!).<br /><!-- br -->	</li><!-- br -->	<li><!-- br -->		<b>Abschnitt B:</b><br><!-- br -->		Jetzt wollen wir den Dialog zum Speichern der Datei öffnen. Dazu müssen wir ALT und D gleichzeitig drücken. Um eine Taste gedrückt zu halten, wird ihr ein Zirkumflex-Zeichen (^) vorangestellt. Da die ALT-Taste eine Sondertaste ist, wird diese in Klammern angegeben, damit der interne Interpreter für die SENDKEYS-Makrosprache weiß, das man eine Sondertaste ausgeben möchte.<br /><!-- br -->Hier sei zu erwähen, daß man, wenn man wirklich ein Klammerzeichen ausgeben möchte, diesem ein Tilde-Zeichen (~) voranstellen muß. Das Tilde-Zeichen erzwingt die Ausgabe des ihm nachfolgendem Zeichens, womit ~^ ein Zirkumflex an das Programm schickt und ~( eine offene Klammer. Um ein Tilde-Zeichen selbst an das fernzusteuernde Programm zu senden, schreibt man ~~.<br /><br /><!-- br --><!-- br -->Da wir nun die ALT-Taste gedrückt halten, senden wir direkt ein &quot;d&quot; hinterher. Mit ALT+D wählen wir also - via Tastenkombination - das Datei-Menü des Editors. Es sei hier auch zu erwähnen, das man, bevor man eine Anwendung mit RapidBATCH fernsteuert, sich vorher in der Anwendung das genaue Vorgehen selber anschaut, indem man seine Tastenkombinationen drückt. Beachten Sie bitte, daß direkt, nachdem das &quot;d&quot; an die Anwendung geschickt wurde, beide Tasten, also &quot;d&quot; und die ALT-Taste wieder automatisch &quot;losgelassen&quot; werden. Möchte man z.B. Mehrere Tasten gleichzeitig drücken, z.B. STRG, ALT und ENTF, so schreibt man als SENDKEYS-Makro &quot;^(control)^(alt)^(del)&quot;.<br /><!-- br --><!-- br -->Um nun dem Speichern-Dialog zu laden, drücken wir noch direkt ein &quot;s&quot; hinterher.<br />Wie Sie an dieser Stelle schon gemerkt haben, können &quot;normale&quote; Zeichen wie Buchstaben und Zahlen direkt angegeben werden, nur reine Sondertasten, für die es kein lesbares Zeichen gibt, werden geklammert geschrieben.<br><!-- br -->	</li><!-- br -->	<li><!-- br -->		<b>Abschnitt C:</b><br><!-- br -->		Hier &quot;tippen&quot; wir wieder einfach einen Text, in diesem Fall den Dateinamen &quot;test.txt&quot; ein, und bestätigen den Dialog mit der Taste Enter über den Sondertastenbefehl <i>(enter)</i>.<br><!-- br -->	</li><!-- br -->	<li><!-- br -->		<b>Abschnitt D:</b><br><!-- br -->		Zum Schluss &quot;drücken&quot; wir noch einmal ALT+F4, um die Anwendung zu beenden. Auch F1 ist hier ein Sonderzeichen, und wird als <i>(f1)</i> kodiert. Es ist übrigens völlig Frei, ob Sie Groß- oder Kleinschreibung bei den Sondertastennamen angeben, <i>(ALT)</i> oder <i>(Alt)</i> wäre genauso richtig wie <i>(alt)</i>.<br><!-- br --><!-- br -->	</li><!-- br --></ul><!-- br --><br><!-- br --><!-- br -->Um eine Übersicht über die möglichen Sondertasten und ihrer Benennung zu erhalten, lohnt sich ein Blick in die Befehlsreferenz, in der auch nochmal die Syntax der SENDKEYS-Makrosprache Stichpunktartig erklärt wird.<!-- br --><br><!-- br --><br><!-- br --><br><!-- br --><!-- br -->Neben SENDKEYS bietet RapidBATCH noch eine weitere Möglichkeit, Programme fernzusteuern: Mit der MOUSEEVENT-Anweisung lassen sich alle nur erdenklichen Mausereignisse simulieren und damit fernsteuern, d.h. ein RapidBATCH-Script kann die volle Kontrolle über die Maus des Computers übernehmen und Klicks, Doppelklicks oder einfach nur Bewegungen simulieren.<br><!-- br --><br>Dieses Thema möchte ich jedoch nur kurz anreissen, da man aufgrund verschiedener Ausflösungen und Programme kein allgemeines Demo-Script, welches Mausereignisse vollzieht, durchführen kann. Scripts, die Mausereignisse simulieren, sollten Sie daher nur für den Eigengebrauch programmieren oder wenn Sie sich wirklich sicher sind, dass Ihre Mausroutine tadellos auch auf jedem System, wo Sie Ihr Script einsetzen, funktioniert.<!-- br --><br><!-- br --><br><!-- br -->Folgender Aufruf von MOUSEEVENT setzt den Mauszeiger exakt auf die Mitte des Bildschirmes:<!-- br --><br><br><!-- br --><!-- br -->[code]<!-- br -->mouseevent <font color="#0000ff">'move'</font>, (<font color="#000080">[ScreenWidth]</font>/<font color="#0000ff">'2'</font>) # <font color="#0000ff">'|'</font> # (<font color="#000080">[ScreenHeight]</font>/<font color="#0000ff">'2'</font>)<!-- br -->[/code]<!-- br --><!-- br -->Wie aus dem obigen Beispiel ersichtlich, erwartet MOUSEEVENT zwei Parameter.  Zuerst einen Aktionsbezeichner, der MOUSEVENT anweist, eine bestimmte Aktion durchzuführen, als zweites zwei Koordinatenwerte, die in der Form &quot;X|Y&quot; übergeben werden, wobei als Trennzeichen jedes beliebige, in der vordeklarierten Systemvariablen [std_sep] definierte Trennzeichen sein kann (wie auch bei Listen, die man an die LISTBOX-Funktion übergibt). Diese Koordinaten setzen den Mauszeiger pixelgenau auf die entsprechende Stelle auf dem Bildschirm, bzw. führen dort die entsprechend definierte Mausoperation durch.<br><br><!-- br --><!-- br -->Als Mausoperationen können folgende Werte an MOUSEEVENT übergeben werden:<!-- br --><!-- br --><ul><!-- br -->  <li>'0' oder 'MOVE' (Maus nur bewegen, kein Tastendruck)</li><!-- br -->  <li>'1' oder 'CLICK_LEFT' (einfachen Linksklick simulieren)</li><!-- br -->  <li>'2' oder 'DBLCLICK_LEFT' (doppelten Linksklick simulieren)</li><!-- br -->  <li>'3' oder 'CLICK_RIGHT' (einfachen Rechtsklick simulieren)</li><!-- br -->  <li>'4' oder 'DBLCLICK_RIGHT' (doppelten Rechtsklick simulieren)</li><!-- br -->  <li>'5' oder 'DOWN_LEFT' (Linke Maustaste gedrückt halten)</li><!-- br -->  <li>'6' oder 'UP_LEFT' (Linke Maustaste loslassen)</li><!-- br -->  <li>'7' oder 'DOWN_RIGHT'  (Rechte Maustaste gedrückt halten)</li><!-- br -->  <li>'8' oder 'UP_RIGHT' (Rechte Maustaste loslassen)</li><!-- br --></ul>
rb5_ger_sysop_6.html§Bearbeiten der Registry§Mit der Version 5.0 ermöglicht RapidBATCH nun auch erstmals das direkte Bearbeiten der Windows-Registry. Die Registry ist eine mit Windows 95 eingeführte Datenbank, welche ein fester Bestandteil der Windows-Betriebssystemreihe geworden ist. Der hauptsächliche Zweck der Registry besteht darin, Konfgurationswerte und individualisierende Schalter für Programme abzulegen bzw. sogar benutzerorientiert zu speichern. Auch Informationen über Dateiendungstypen sowie alle nur erdenklichen Systemeinstellungen sind in der Registry hinterlegt. Damit entfällt auch die Vermüllung der Festplatte durch Konfigurations- und INI-Dateien fast gänzlich.<br><!-- br -->Editiert und betrachtet werden kann die Registry mit dem Windows-eigenen Werkzeug &quot;regedit&quot;, welches bei jeder Windows-Version mitgeliefert wird.<!-- br --><br><!-- br --><br><!-- br --><!-- br -->Die Registry ist ähnlich dem Dateisystem von Windows aufgebaut, wobei es 5 so genannte Hauptschlüssel gibt. Ein Registrierungsschlüssel ist eine Art &quot;Ordner&quot; in der Registry, und kann theoretisch gesehen unendlich viele Unterschlüssel haben. In jedem Schlüssel können zusätzlich eine unbegrenzte Anzahl von Werten abgelegt werden, welche einen Namen und den ensprechend hinterlegten Wert haben.<br><br><!-- br --><!-- br -->Folgend eine Auflistung der 5 Hauptschlüssel und deren Bedeutung.<!-- br --><!-- br --><ul><!-- br -->	<li><b>HKEY_CLASSES_ROOT</b><br><!-- br -->	Hier werden Informationen über die verschiedenen Dateitypen gespeichert. Darunter fallen die Beschreibung, das Symbol und die verknüpfte Anwendung.<!-- br -->	</li><!-- br -->	<li><b>HKEY_CURRENT_USER</b><br><!-- br -->	Hier werden Einstellungen und Informationen zu Software gespeichert, die nur für den aktuellen Windows-Benutzer gelten.<!-- br -->	</li><!-- br -->	<li><b>HKEY_LOCAL_MACHINE</b><br><!-- br -->	Hier werden von allen Benutzern geteilte Einstellungen und Informationen gespeichert.<!-- br -->	</li><!-- br -->	<li><b>HKEY_USERS</b><br><!-- br -->	Enthält den Stamm aller Benutzerprofile auf dem Computer.<!-- br -->	</li><!-- br -->	<li><b>HKEY_CURRENT_CONFIG</b><br><!-- br -->	Grundlegende Einstellungen des Betriebssystemes.<!-- br -->	</li><!-- br --></ul><!-- br --><!-- br -->Mit RapidBATCH lässt sich die Registry nun zunutze machen. Ob man nun via RapidBATCH bestehende Registry-Werte automatisiert verändert, um z.B. das Verhalten einer Software zu ändern oder zu bestimmen oder selbst einen eigenen Schlüssel für sein Script anlegt, um dort beispielsweise benutzerdefinierte Einstellungen und Schalter zu speichern, ist jedem selbst überlassen. Natürlich kommt es immer ganz auf den Zweck des jeweiligen Scripts an.<br><br><!-- br --><!-- br -->Zum Erstellen und Entfernen von Schlüsseln stellt RapidBATCH die Anweisungen NEWREGKEY und DELREGKEY zur Verfügung. NEWREGKEY erstellt einen Unterschlüssel, DELREGKEY entfernt einen Schlüssel samt Unterschlüssel und Werten aus der Registry.<!-- br --><!-- br -->Als Parameter erwarten beide Anweisungen zuerst den Bezeichner des Hauptschlüssels, welcher durch die Werte 'CLASSES_ROOT', 'CURRENT_CONFIG', 'CURRENT_USER', 'LOCAL_MACHINE' und 'USERS' spezifiziert wird, sowie den Pfad des neu zu erstellenden Schlüssels. Folgendes Script erzeugt einen Schlüssel unter HKEY_CURRENT_USER mit dem Namen &quot;Test&quot;.<!-- br --><!-- br --><br><!-- br --><br><!-- br --><!-- br -->[code]<font color="#808080">rem Einen neuen Schlüssel erstellen</font><br /><!-- br -->newregkey <font color="#0000ff">'CURRENT_USER'</font>, <font color="#0000ff">'Test'</font><br /><!-- br --><b>if</b> <font color="#000080">[errorcode]</font> = <font color="#0000ff">'0'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Erstellen von HKEY_CURRENT_USER\Test war erfolgreich.'</font><br /><!-- br --><b>else</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Fehler beim Erstellen von HKEY_CURRENT_USER\Test.'</font><br /><!-- br --><b>endif</b><br /><!-- br --><br /><!-- br --><font color="#808080">rem Einen existierenden Schlüssel entfernen</font><br /><!-- br -->delregkey <font color="#0000ff">'CURRENT_USER'</font>, <font color="#0000ff">'Test'</font><br /><!-- br --><b>if</b> <font color="#000080">[errorcode]</font> = <font color="#0000ff">'0'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Löschen von HKEY_CURRENT_USER\Test war erfolgreich.'</font><br /><!-- br --><b>else</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Fehler beim Entfernen von HKEY_CURRENT_USER\Test.'</font><br /><!-- br --><b>endif</b>[/code]<!-- br --><!-- br -->Wichtig beim Erstellen eines Schlüssels ist, dass die nächsthöhere Ebene des zu erstellenden Schlüssels bereits existiert, d.h. es besteht hier keine Äquivalenz zu MKDIR.<br><br><!-- br --><!-- br -->Um nun einen Wert in den Schlüssel selbst zu schreiben oder dem Schlüssel einen Wert hinzuzufügen bietet RapidBATCH die Anweisung LETREGKEY. LETREGKEY unsterstützt dabei drei unterschiedliche Datentypen (&quot;String&quot;, &quot;Binary&quot; und &quot;Long&quot; (DWORD)), die sich als Werte in der Registry ablegen lassen. Desweiteren erwartet die Anweisung den Hauptschlüsselnamen, den Schlüsselpfad, den Wertnamen sowie den zu setzenden Wert in der je nach Datentyp angegebenen Form. Folgendes Beispiel erzeugt einen neuen Wert &quot;HelloWorld&quot; im Schlüssel &quot;Test&quot; unter &quot;HKEY_CURRENT_USER&quot; (der Schlüssel wird hier vorher auch nochmal mit NEWREGKEY angelegt).<!-- br --><br><br><!-- br --><!-- br -->[code]<font color="#808080">rem Testschlüssel anlegen</font><br /><!-- br -->newregkey <font color="#0000ff">'CURRENT_USER'</font>, <font color="#0000ff">'Test'</font><br /><!-- br --><b>if</b> <font color="#000080">[errorcode]</font> = <font color="#0000ff">'0'</font><br /><!-- br --><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem Wert in Registry schreiben</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;letregval <font color="#0000ff">'string'</font>, <font color="#0000ff">'CURRENT_USER'</font>, <font color="#0000ff">'Test'</font>, <font color="#0000ff">'HelloWorld'</font>, <font color="#0000ff">'Das ist der Wert!'</font><br /><!-- br --><br /><!-- br --><font color="#808080">&nbsp;&nbsp;&nbsp;&nbsp;rem War das Schreiben des Wertes erfolgreich?</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[errorcode]</font> = <font color="#0000ff">'0'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Schreiben der Registry war erfolgreich!'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>else</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Fehler beim Schreiben der Registry'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>endif</b><br /><!-- br --><b>endif</b>[/code]<!-- br --><!-- br --><div class="image"><img src="img/sysop_regvalue1.gif" alt="Der Registry-Editor mit dem erstellten Wert." title="Betrachtung des mit RapidBATCH geschriebenen Wertes im Registry-Editor" /><br /><!-- br -->Erfolgreich geschriebener Wert in der Registry.</div><!-- br --><!-- br -->Es kann auch ein Wert direkt in den Schlüssel geschrieben werden; Hier lässt man einfach den Parameter für den Registry-Wertnamen leer.<!-- br --><br><br><!-- br --><!-- br -->[code]letregval <font color="#0000ff">'string'</font>, <font color="#0000ff">'CURRENT_USER'</font>, <font color="#0000ff">'Test'</font>, <font color="#0000ff">''</font>, <font color="#0000ff">'Das ist der Wert!'</font>[/code]<!-- br --><!-- br -->Um einen Binärwert zu schreiben, wird bei der LETREGVAL genauso verfahren wie bei PUTFILE: Eine Liste an ASCII-Zeichencodes, bei der jeder Wert zwischen 0 und 255 liegen kann, also 8 Bit je Zeichen. Hier ein &quot;Hello World&quot; in binär:<!-- br --><!-- br --><br><br><!-- br --><!-- br -->[code]<font color="#808080">rem Wert in Registry schreiben</font><br /><!-- br --><font color="#000080">[hello]</font> = <font color="#0000ff">'72|101|108|108|111|32|87|111|114|108|100'</font><br /><!-- br -->letregval <font color="#0000ff">'binary'</font>, <font color="#0000ff">'CURRENT_USER'</font>, <font color="#0000ff">'Test'</font>, <font color="#0000ff">'binary_HelloWorld'</font>, <font color="#000080">[hello]</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem War das Schreiben des Wertes erfolgreich?</font><br /><!-- br --><b>if</b> <font color="#000080">[errorcode]</font> = <font color="#0000ff">'0'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Schreiben der Registry war erfolgreich!'</font><br /><!-- br --><b>else</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Fehler beim Schreiben der Registry'</font><br /><!-- br --><b>endif</b>[/code]<!-- br --><!-- br --><div class="image"><img src="img/sysop_regvalue2.gif" alt="Ansicht eines Binärwertes im Registry-Editor" title="Der Binärwert im Registry-Editor" /><br /><!-- br -->Ein deutlich erkennbares &quot;Hello World&quot; wurde binär in die Registry geschrieben!</div><!-- br --><!-- br -->Soll ein DWORD-Wert in die Registry geschrieben werden, können nur numerische 32-Bit Ganzzahlwerte in die Registry geschrieben werden.<br><br><!-- br --><!-- br -->Das Auslesen von Registry-Werten erfolgt auch hier wieder äquivalent über eine Funktion namens GETREGVAL. Parameter sind hier die selben wie bei LETREGVAL, nur dass hier natürlich kein Wert, dafür aber eine Rückgabevariable angegeben werden muss.<br><!-- br --><br><!-- br -->Dieses Beispiel liest die oben geschriebenen Werte wieder aus der Registry aus:<br><br><!-- br --><!-- br -->[code]<font color="#808080">rem Stringwert aus Registry lesen</font><br /><!-- br -->getregval <font color="#000080">[text]</font> = <font color="#0000ff">'string'</font>, <font color="#0000ff">'CURRENT_USER'</font>, <font color="#0000ff">'Test'</font>, <font color="#0000ff">'HelloWorld'</font><br /><!-- br -->echo <font color="#0000ff">'Stringwert in "HelloWorld": '</font> # <font color="#000080">[text]</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem Binärwert aus Registry lesen</font><br /><!-- br -->getregval <font color="#000080">[data]</font> = <font color="#0000ff">'binary'</font>, <font color="#0000ff">'CURRENT_USER'</font>, <font color="#0000ff">'Test'</font>, <font color="#0000ff">'binary_HelloWorld'</font><br /><!-- br -->echo <font color="#0000ff">'Gelesene ASCII-Liste aus "binary_HelloWorld": '</font> # <font color="#000080">[data]</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem ASCII-Codes in ASCII-Zeichen umwandeln und an Ausgabestring hängen</font><br /><!-- br --><font color="#000080">[i]</font> = <font color="#0000ff">'0'</font><br /><!-- br --><b>repeat</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> + <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;gettok <font color="#000080">[zeichen]</font> = <font color="#000080">[data]</font>, <font color="#000080">[std_sep]</font>, <font color="#000080">[i]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <font color="#000080">[zeichen]</font> ! <font color="#0000ff">''</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getchr <font color="#000080">[zeichen]</font> = <font color="#000080">[zeichen]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[klartext]</font> # <font color="#000080">[zeichen]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<b>endif</b><br /><!-- br --><b>until</b> <font color="#000080">[zeichen]</font> = <font color="#0000ff">''</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem Den Klartext ausgeben</font><br /><!-- br -->echo <font color="#0000ff">'Klartext aus "binary_HelloWorld": '</font> # <font color="#000080">[klartext]</font>[/code]<!-- br --><!-- br -->Zu guter Letzt entfernen wir noch die geschriebenen Werte mit Hilfe der DELREGVAL-Anweisung aus der Registy.<br><br><!-- br --><!-- br -->[code]<font color="#808080">rem "HelloWorld" entfernen</font><br /><!-- br -->delregval <font color="#0000ff">'CURRENT_USER'</font>, <font color="#0000ff">'Test'</font>, <font color="#0000ff">'HelloWorld'</font><br /><!-- br --><b>if</b> <font color="#000080">[errorcode]</font> ! <font color="#0000ff">'0'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Fehler beim Löschen von "HelloWorld"'</font><br /><!-- br --><b>endif</b><br /><!-- br --><br /><!-- br --><font color="#808080">rem "binary_HelloWorld" entfernen</font><br /><!-- br -->delregval <font color="#0000ff">'CURRENT_USER'</font>, <font color="#0000ff">'Test'</font>, <font color="#0000ff">'binary_HelloWorld'</font><br /><!-- br --><b>if</b> <font color="#000080">[errorcode]</font> ! <font color="#0000ff">'0'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Fehler beim Löschen von "binary_HelloWorld"'</font><br /><!-- br --><b>endif</b>[/code]
rb5_ger_sysop_7.html§Systemspezifische, vordeklarierte Variablen§Es mag vielleicht sein, dass der Abschnitt &quot;Systemoperationen&quot; nicht ganz passend ist, um alle vordeklarierten Variablen, die RapidBATCH bietet, zu behandeln, aber es haben auch sehr viele der vordeklarierten Variablen ihre Bestimmung bei der Programmierung von Scripts, die system-basierende Operationen ver- und bearbeiten. Bis jetzt haben Sie bereits viele der so genannten &quot;vordeklarierten Variablen&quot; kennen gelernt. Vordeklarierte Variablen werden vor der Ausführung eines jeden Scripts automatisch vom Interpreter deklariert. Bei einigen vordeklarierten Variablen ist der darin enthaltene Wert änderbar, bei anderen wird er bei jedem Aufruf der Variable direkt neu ermittelt.<br><!-- br -->Ich werde in diesem Kapitel zwar nicht alle vordeklarierten Variablen behandeln, aber die wichtigsten, besonders solche, die für Systemoperationen von Bedeutung und Nutzen sind.<!-- br --><br><br><!-- br --><!-- br -->Oftmals ist es von großem Nutzen, ein Programm bzw. Optionen und Informationen an ein Programm über die Kommandozeile zu übergeben. Dies darf natürlich auch bei RapidBATCH nicht fehlen! Die Variable [command] enthält alle Kommandozeilenparameter, die hinter dem Dateinamen des Script-Files (wenn das Script mit dem Interpreter ausgeführt wird) bzw. bei compilierten Scripts alle an die EXE-Datei übergebenen Kommandozeilenparameter, übergeben wurden.<br><!-- br -->Bestes Beispiel stellt folgendes Script dar. Es gibt einfach den Inhalt der Variablen [command] in einem Meldungsfenster aus. Im RapidBATCH Builder können Sie zum direkten Testen Ihrer Scripts die Funktion &quot;Setze [command]...&quot; im Menü &quot;Script&quot; benutzen.<!-- br --><br><br><!-- br -->[code]echo <font color="#0000ff">'Das hier wurde diesem Script mitgeschickt: '</font> # <font color="#000080">[command]</font><br /><!-- br --><b>end</b>[/code]<!-- br --><!-- br --><div class="image"><img src="img/sysop_pdvar1.gif" alt="Eingabe eines Kommandozeilenwertes an das Script im RapidBATCH Builder" title="Eingabe eines Wertes, welcher an [command] beim Starten des Scripts übergeben wird." /><br /><!-- br -->Die Funktion &quot;Setze [command]...&quot;, ideal zum Testen von Kommandozeilen-Parametern...</div><!-- br --><div class="image"><img src="img/sysop_pdvar2.gif" alt="Ausgabe des über die Kommandozeile übergebenen Wertes." title="Ausgabe von [command]" /><br /><!-- br -->...mit Erfolg!</div><!-- br --><!-- br --><div class="remark">Anmerkung: Die über [command] übergebenen Werte können direkt in ein Array transferiert werden, indem Sie die Prozedur getcmdlineparms aus der SYSTEM.RB Bibliothek verwenden.</div><!-- br --><!-- br --><!-- Geilo: E Nomine - Hexenjagd  (Anthony Hopkins) hör *fieps* --><!-- br --><!-- br -->Sie möchten einen beliebigen Wert für jedes andere Windows-Programm zugänglich machen? Mit RapidBATCH ist auch dies kein Problem. Durch Zuweisung eines beliebigen Wertes an die Variable [clipboard] wird dieser sofort in die Windows-Zwischenablage kopiert. Ein Auslesen von [clipboard] ermöglicht das sofortige Auslesen des Zwischenablagen-Inhaltes.<br><br><!-- br --><!-- br -->Ein einfaches Beispiel, welches sogar den Inhalt der Zwischenablage in einem anderen Programm einfügt:<!-- br --><br><!-- br --><br><!-- br --><!-- br -->[code]<font color="#808080">rem Zeige mir den Inhalt der Zwischenablage!</font><br /><!-- br -->echo <font color="#0000ff">'Aktueller Inhalt der Zwischenablage: '</font> # <font color="#000080">[clipboard]</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem So und jetzt schreiben wir mal ein "Hello World" rein!</font><br /><!-- br --><font color="#000080">[clipboard]</font> = <font color="#0000ff">'Hello World by RapidBATCH'</font><br /><!-- br -->echo <font color="#0000ff">'Neuer Inhalt der Zwischenablage: '</font> # <font color="#000080">[clipboard]</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem Und jetzt via Fernsteuerung den Text mal im Notepad "einfügen"</font><br /><!-- br -->shell <font color="#000080">[windir]</font> # <font color="#0000ff">'\notepad.exe'</font>, <font color="#0000ff">'show'</font><br /><!-- br -->wait <font color="#0000ff">'500'</font><br /><!-- br -->sendkeys <font color="#000080">[active_window]</font>: <font color="#0000ff">'Und das ist der Inhalt Ihrer Zwischenablage in einem anderem Programm: #271v#017'</font><br /><!-- br --><b>end</b>[/code]<!-- br --><!-- br -->Und da findet man auch direkt schon die nächste, vordeklarierte Variable: [active_window]! [active_window] enthält den Titel des aktuellen Vordergrundfensters und kann idealerweise von SENDKEYS exzellent genutzt werden, wenn man den genauen Titel eines Fensters nicht kennt oder dieser variabel ist, wie es z.B. bei Word - oder anderen Office-Programmen - der Fall ist, wenn man ein Dokument geladen hat.<br><!-- br --><!-- br -->Auch die bereits kennen gelernte Variable [windir] wird im obigen Script benutzt; Sie enthält den absoluten Pfad des Windows-Systemverzeichnisses.<br><br><!-- br --><!-- br -->Auch das Auslesen von Systemdatum und Systemzeit ist in RapidBATCH kein Problem. Folgendes Script zeigt für 10 Sekunden die aktuelle Uhrzeit und das aktuelle Datum in einer INFOBOX sekundengenau an.<br><br><!-- br --><!-- br -->[code]<font color="#000080">[i]</font> = <font color="#0000ff">'0'</font><br /><!-- br --><b>repeat</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;<font color="#000080">[i]</font> + <font color="#0000ff">'1'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;infobox <font color="#0000ff">'Es ist '</font> # <font color="#000080">[time]</font> # <font color="#0000ff">' am '</font>  # <font color="#000080">[day]</font> # <font color="#0000ff">'.'</font> # <font color="#000080">[month]</font> # <font color="#0000ff">'.'</font> # <font color="#000080">[year]</font>, <font color="#0000ff">'show'</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;wait <font color="#0000ff">'1000'</font><br /><!-- br --><b>until</b> <font color="#000080">[i]</font> = <font color="#0000ff">'10'</font><br /><!-- br --><b>end</b>[/code]<!-- br --><!-- br -->Die Variable [time] enthält die Uhrzeit, wird also bei jedem Auslesen aktuell und neu gefüllt. Das Format der [time]-Variablen ist HH:MM:SS, also Stunden, Minuten und Sekunden. Anders ist es bei dem Datum. Da RapidBATCH ein international eingesetztes Softwareprodukt ist, wurde hier Wert auf einfache Datumsformatierung gelegt, und die drei Informationen &quot;Tag&quot;, &quot;Monat&quot; und &quot;Jahr&quot; in drei Variablen, [day], [month] und [year] aufgeteilt. Man kann also durch einfaches &quot;Zusammenbauen&quot; des Datums mit dem Join-Operator (#) das Format völlig frei bestimmen.<br><br><!-- br --><!-- br --><div class="image"><img src="img/sysop_pdvar3.gif" alt="Ausgabe von Uhrzeit und Datum in einem INFOBOX-Dialogfenster." title="Die aktuelle Zeit und das aktuelle Datum in der INFOBOX." /><br /><!-- br -->Ausgabe der aktuellen Zeit und des aktuellen Tagesdatums im INFOBOX-Dialog.</div><!-- br --><!-- br -->Oftmals ist es auch nötig, ob nun bei der Ausgabe von Informationen oder direkt beim Schreiben von Dateien, beispielsweise Tabulatoren oder Zeilenumbrüche einzufügen. Da ein Tabulator oder Zeilenumbruch intern nichts anderes als ein weiteres ASCII-Zeichen ist, könnte man sich dieses auch mit der Funktion GETCHR holen, aber RapidBATCH hat auch bereits vordeklarierte Variablen, welche einem an dieser Stelle die Arbeit abnehmen: [new_line], [tab], [crlf], [pipe] und [quot]. [new_line] und [crlf] stellen jeweils Zeilenumbrüche dar, allerdings mit einem wichtigem Unterschied. Unter Windows-Systemen ist es besonders bei Texten üblich, Zeilenumbrüche mit zwei anstatt mit einem Zeichen einzuleiten. Diese heissen &quot;carriage return&quot; und &quot;line feed&quot; (ASCII-Zeichencodes 13 und 10, daher auch [crlf], Carriage Return + Line Feed). Diese beiden Begriffe kommen noch aus der Urzeit der Computer, wo die Ausgabe aller Programme noch vornehmlich auf Nadeldruckern erfolgte, daher &quot;carriage return&quot;, was übersetzt soviel heisst wie &quot;Schreibkopfrücklauf&quot; und &quot;line feed&quot;, was nicht mehr als &quot;Zeilenvorschub&quot; heisst. I.d.R. reicht meist aber ein einfaches [new_line], welches nur ein &quot;line feed&quot; bewirkt, um einen Zeilenumbruch darzustellen. [tab] enthält ein Tabulatorzeichen, [pipe] das Zeichen &quot;|&quot;, welches auch als RapidBATCH Standard Separator bei Listen verwendet wird. Die Variable [quot] enthält ein einfaches Anführungszeichen, welches in RapidBATCH selber zur Ein- und Ausleitung von Strings im Script-Code verwendet wird, und daher nicht direkt ausgegeben werden kann. Um dieses Zeichen selber in einem String zu verketten, verwenden Sie [quot], welche dieses Zeichen (') enthält.<!-- br --><!-- br --><br><br><!-- br --><!-- br -->[code]<font color="#808080">rem Zeilenumbrüche</font><br /><!-- br -->echo <font color="#0000ff">'Dies ist'</font> # <font color="#000080">[new_line]</font> # <font color="#0000ff">'ein Zeilenumbruch in '</font> # <font color="#000080">[crlf]</font> # <font color="#0000ff">'zwei Versionen'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem Tabulatoren</font><br /><!-- br -->echo <font color="#0000ff">'Ein'</font> # <font color="#000080">[tab]</font> # <font color="#0000ff">'Tabulator!'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem Pipe-Zeichen</font><br /><!-- br -->echo <font color="#0000ff">'Das als '</font> # <font color="#000080">[std_sep]</font> # <font color="#0000ff">' definierte Zeichen ist Standardmäßig ein '</font> # <font color="#000080">[pipe]</font> # <font color="#0000ff">' ;)'</font><br /><!-- br --><br /><!-- br --><font color="#808080">rem Einfaches Anführungszeichen</font><br /><!-- br -->echo <font color="#0000ff">'echo '</font> # <font color="#000080">[quot]</font> # <font color="#0000ff">'Dies ist der Code für eine einfache Ausgabe'</font> # <font color="#000080">[quot]</font> # <font color="#000080">[crlf]</font> # <font color="#0000ff">'end'</font>[/code]<!-- br --><!-- br -->Bereits in vorherigen Abschnitten haben Sie die Variable [errorcode] kennen gelernt. Diese werden Sie auch am häufigsten zur Abfrage von Fehlern verwenden. [errorcode] gibt in fast allen Fällen (bis auf Ausnahmen bei SHELL und CALL) die Werte '0' für &quot;kein Fehler&quot; bzw. &quot;wahr&quot; und '-1' für &quot;Fehler&quot; bzw. &quot;falsch&quot; zurück. Um eine IF- oder UNTIL-Bedinung etwas professioneller zu realisieren, wurden während der Entwicklung von RapidBATCH 5 noch die Variablen [true] und [false] hinzugenommen. [true] enthält standardmäßig den Wert '0',  [false] standardmäßig den Wert '-1'. Eine IF-Abgrage kann also zum besseren Verständnis sowie zur erhöhten Dynamik so programmiert werden:<!-- br --><!-- br --><br><br><!-- br --><!-- br -->[code]<!-- br -->chdir <font color="#0000ff">'C:\test'</font><br /><!-- br --><br /><!-- br --><b>if</b> <font color="#000080">[errorcode]</font> = <font color="#000080">[false]</font><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Fehler, das Verzeichnis wurde nicht gefunden!'</font><br /><!-- br --><b>else</b><br /><!-- br -->&nbsp;&nbsp;&nbsp;&nbsp;echo <font color="#0000ff">'Das Verzeichnis wurde erolgreich gewechselt.'</font><br /><!-- br --><b>endif</b>[/code]<!-- br --><!-- br -->Zu guter Letzt noch eine Variable, die im wahrsten Sinne des Wortes gar nichts tut: [null]!<br><!-- br -->Diese Variable hat u.a. den Zweck, Funktions-Rückgabewerte abzufangen, die nicht benötigt werden, denn nicht immer wird der Rückgabewert einer Funktion wirklich gebraucht. Bei Zuweisung an die Variable [null] wird der Wert im Speicher direkt verworfen, muss also nicht erst in eine Pseudo-Returnvariable kopiert werden, was wiederum unnützen Speicherverbrauch zur Folge hat. Des weiteren kann [null] auch als Parameter bei Anweisungen oder Funktionen übergeben werden, wenn man einen Leerstring übergeben will. [null] ist also die aussagekräftigere Alternative zur Angabe eines Leerstrings.
